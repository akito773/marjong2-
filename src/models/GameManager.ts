import { GameState, GameAction, GameSettings } from '../../shared/types/Game';
import { Player as IPlayer, PlayerAction } from '../../shared/types/Player';
import { Tile } from '../../shared/types/Tile';
import { TileManager } from './TileManager';
import { Player } from './Player';

export class GameManager {
  private gameState: GameState;
  private tileManager: TileManager;
  private players: Player[] = [];
  private actionQueue: PlayerAction[] = [];

  constructor(
    gameId: string,
    playerNames: string[],
    settings: GameSettings = {
      maxPlayers: 4,
      botCount: 0,
      initialScore: 25000,
      endScore: 30000,
      redDora: true,
      openTanyao: true,
      doubleRon: false,
      nagashiMangan: false,
    }
  ) {
    if (playerNames.length !== 4) {
      throw new Error('Game requires exactly 4 players');
    }

    // „Éó„É¨„Ç§„É§„ÉºÂàùÊúüÂåñ
    this.initializePlayers(playerNames, settings);

    // ÁâåÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É†ÂàùÊúüÂåñ
    this.tileManager = new TileManager(settings.redDora);

    // „Ç≤„Éº„É†Áä∂ÊÖãÂàùÊúüÂåñ
    this.gameState = this.createInitialGameState(gameId, settings);

    console.log(`üéÆ „Ç≤„Éº„É†ÈñãÂßã: ${gameId}`);
    console.log(`üë• „Éó„É¨„Ç§„É§„Éº: ${playerNames.join(', ')}`);
  }

  // „Éó„É¨„Ç§„É§„ÉºÂàùÊúüÂåñ
  private initializePlayers(playerNames: string[], settings: GameSettings): void {
    this.players = playerNames.map((name, index) => {
      const isBot = index < settings.botCount;
      return new Player(
        `player_${index}`,
        name,
        index,
        isBot,
        settings.initialScore
      );
    });

    // Ë¶™Ë®≠ÂÆöÔºàÊúÄÂàù„ÅØÂ∫ßÂ∏≠0Ôºâ
    this.players[0].setDealer(true);
  }

  // ÂàùÊúü„Ç≤„Éº„É†Áä∂ÊÖã‰ΩúÊàê
  private createInitialGameState(gameId: string, settings: GameSettings): GameState {
    const now = Date.now();
    const debugInfo = this.tileManager.getDebugInfo();

    return {
      id: gameId,
      players: this.players.map(p => ({
        id: p.id,
        name: p.name,
        hand: p.hand,
        score: p.score,
        position: p.position,
        isDealer: p.isDealer,
        isBot: p.isBot,
        status: p.status,
        wind: p.wind,
      })),
      currentPlayer: 0,
      phase: 'waiting',
      round: {
        roundNumber: 1,
        dealerPosition: 0,
        prevailingWind: 'east',
        honbaCount: 0,
        riichiSticks: 0,
      },
      wall: [],
      deadWall: [],
      doraIndicators: debugInfo.doraIndicators,
      uraDoraIndicators: [],
      remainingTiles: debugInfo.wallRemaining,
      availableActions: [],
      gameLog: [],
      createdAt: now,
      updatedAt: now,
    };
  }

  // „Ç≤„Éº„É†ÈñãÂßã
  startGame(): void {
    if (this.gameState.phase !== 'waiting') {
      throw new Error('Game is already started');
    }

    this.startRound();
  }

  // Â±ÄÈñãÂßã
  private startRound(): void {
    console.log(`üÄÑ Êù±${this.gameState.round.roundNumber}Â±ÄÈñãÂßã`);
    
    // ÈÖçÁâå
    const hands = this.tileManager.dealInitialHands();
    hands.forEach((hand, index) => {
      this.players[index].setInitialHand([...hand.tiles]);
    });

    // Ë¶™„Å´„ÉÑ„É¢Áâå
    const dealerTile = this.tileManager.drawTile();
    if (dealerTile) {
      this.players[this.gameState.round.dealerPosition].drawTile(dealerTile);
    }

    // „Ç≤„Éº„É†Áä∂ÊÖãÊõ¥Êñ∞
    this.gameState = {
      ...this.gameState,
      phase: 'playing',
      currentPlayer: this.gameState.round.dealerPosition,
      players: this.players.map(p => this.playerToInterface(p)),
      remainingTiles: this.tileManager.getRemainingTileCount(),
      updatedAt: Date.now(),
    };

    // „É≠„Ç∞ËøΩÂä†
    this.addGameAction({
      type: 'deal',
      description: `ÈÖçÁâåÂÆå‰∫Ü„ÄÇÊù±${this.gameState.round.roundNumber}Â±ÄÈñãÂßã`,
      timestamp: Date.now(),
    });

    console.log(`üéØ ${this.players[this.gameState.currentPlayer].name}„ÅÆ„Çø„Éº„É≥`);
  }

  // „Éó„É¨„Ç§„É§„Éº„Ç¢„ÇØ„Ç∑„Éß„É≥Âá¶ÁêÜ
  processAction(action: PlayerAction): GameAction[] {
    console.log(`üé≤ „Ç¢„ÇØ„Ç∑„Éß„É≥: ${action.type} by ${this.players[parseInt(action.playerId.split('_')[1])].name}`);

    const actions: GameAction[] = [];
    const playerIndex = parseInt(action.playerId.split('_')[1]);
    const player = this.players[playerIndex];

    if (!player) {
      throw new Error(`Player not found: ${action.playerId}`);
    }

    try {
      switch (action.type) {
        case 'discard':
          actions.push(...this.processDiscard(player, action));
          break;
        case 'riichi':
          actions.push(...this.processRiichi(player, action));
          break;
        case 'chi':
        case 'pon':
        case 'kan':
          actions.push(...this.processMeld(player, action));
          break;
        case 'tsumo':
          actions.push(...this.processTsumo(player));
          break;
        case 'ron':
          actions.push(...this.processRon(player, action));
          break;
        case 'pass':
          actions.push(...this.processPass(player));
          break;
        default:
          throw new Error(`Unknown action type: ${action.type}`);
      }

      // „Ç≤„Éº„É†Áä∂ÊÖãÊõ¥Êñ∞
      this.updateGameState();

    } catch (error) {
      console.error(`‚ùå „Ç¢„ÇØ„Ç∑„Éß„É≥Âá¶ÁêÜ„Ç®„É©„Éº:`, error);
      actions.push({
        id: `error_${Date.now()}`,
        type: 'deal',
        playerId: action.playerId,
        description: `„Ç®„É©„Éº: ${error instanceof Error ? error.message : 'Unknown error'}`,
        timestamp: Date.now(),
      });
    }

    return actions;
  }

  // Êç®ÁâåÂá¶ÁêÜ
  private processDiscard(player: Player, action: PlayerAction): GameAction[] {
    if (!action.tile) {
      throw new Error('Discard action requires a tile');
    }

    if (this.gameState.currentPlayer !== player.position) {
      throw new Error(`Not ${player.name}'s turn`);
    }

    player.discardTile(action.tile);

    // ‰ªñ„ÅÆ„Éó„É¨„Ç§„É§„Éº„ÅÆÈ≥¥„ÅçÂà§ÂÆö
    this.checkMeldOpportunities(action.tile, player.position);

    // ÊúÄÂæå„ÅÆÊç®ÁâåÊÉÖÂ†±„ÇíÊõ¥Êñ∞
    this.gameState = {
      ...this.gameState,
      lastDiscard: action.tile,
      lastDiscardPlayer: player.position,
    };

    // Ê¨°„ÅÆ„Éó„É¨„Ç§„É§„Éº„Å´„ÉÑ„É¢ÔºàÈ≥¥„Åç„Åå„Å™„ÅÑÂ†¥ÂêàÔºâ
    if (this.actionQueue.length === 0) {
      this.nextTurn();
    }

    return [{
      id: `discard_${Date.now()}`,
      type: 'discard',
      playerId: player.id,
      data: { tile: action.tile },
      description: `${player.name}„Åå${action.tile.displayName}„ÇíÊç®Áâå`,
      timestamp: Date.now(),
    }];
  }

  // „É™„Éº„ÉÅÂá¶ÁêÜ
  private processRiichi(player: Player, action: PlayerAction): GameAction[] {
    if (!action.tile) {
      throw new Error('Riichi action requires a tile');
    }

    if (!player.canDeclareRiichi()) {
      throw new Error(`${player.name} cannot declare riichi`);
    }

    player.declareRiichi(action.tile);
    (this.gameState.round as any).riichiSticks++;

    return [{
      id: `riichi_${Date.now()}`,
      type: 'riichi',
      playerId: player.id,
      data: { tile: action.tile },
      description: `${player.name}„Åå„É™„Éº„ÉÅÂÆ£Ë®Ä`,
      timestamp: Date.now(),
    }];
  }

  // È≥¥„ÅçÂá¶ÁêÜ
  private processMeld(player: Player, action: PlayerAction): GameAction[] {
    if (!action.meld || !action.tile) {
      throw new Error('Meld action requires meld and tile');
    }

    player.addMeld(action.meld, action.tile);
    
    // „Ç´„É≥„ÅÆÂ†¥Âêà„ÅØ„Éâ„É©ËøΩÂä†
    if (action.meld.type === 'kan') {
      this.tileManager.addDoraIndicator();
    }

    return [{
      id: `meld_${Date.now()}`,
      type: 'meld',
      playerId: player.id,
      data: { meld: action.meld },
      description: `${player.name}„Åå${action.meld.type}`,
      timestamp: Date.now(),
    }];
  }

  // „ÉÑ„É¢Âá¶ÁêÜ
  private processTsumo(player: Player): GameAction[] {
    // TODO: Âíå‰∫ÜÂà§ÂÆö„Å®ÁÇπÊï∞Ë®àÁÆó
    player.setStatus('finished');
    (this.gameState as any).phase = 'finished';

    return [{
      id: `tsumo_${Date.now()}`,
      type: 'win',
      playerId: player.id,
      description: `${player.name}„Åå„ÉÑ„É¢Âíå‰∫Ü`,
      timestamp: Date.now(),
    }];
  }

  // „É≠„É≥Âá¶ÁêÜ
  private processRon(player: Player, action: PlayerAction): GameAction[] {
    // TODO: Âíå‰∫ÜÂà§ÂÆö„Å®ÁÇπÊï∞Ë®àÁÆó
    player.setStatus('finished');
    (this.gameState as any).phase = 'finished';

    return [{
      id: `ron_${Date.now()}`,
      type: 'win',
      playerId: player.id,
      description: `${player.name}„Åå„É≠„É≥Âíå‰∫Ü`,
      timestamp: Date.now(),
    }];
  }

  // „Éë„ÇπÂá¶ÁêÜ
  private processPass(player: Player): GameAction[] {
    // „Ç¢„ÇØ„Ç∑„Éß„É≥„Ç≠„É•„Éº„Åã„ÇâÂâäÈô§
    this.actionQueue = this.actionQueue.filter(a => a.playerId !== player.id);

    return [{
      id: `pass_${Date.now()}`,
      type: 'deal',
      playerId: player.id,
      description: `${player.name}„Åå„Éë„Çπ`,
      timestamp: Date.now(),
    }];
  }

  // Ê¨°„ÅÆ„Çø„Éº„É≥
  private nextTurn(): void {
    const nextPlayer = (this.gameState.currentPlayer + 1) % 4;
    const tile = this.tileManager.drawTile();

    if (!tile) {
      // ÊµÅÂ±Ä
      (this.gameState as any).phase = 'finished';
      this.addGameAction({
        type: 'draw_game',
        description: 'ÊµÅÂ±Ä',
        timestamp: Date.now(),
      });
      return;
    }

    this.players[nextPlayer].drawTile(tile);
    (this.gameState as any).currentPlayer = nextPlayer;

    console.log(`üéØ ${this.players[nextPlayer].name}„ÅÆ„Çø„Éº„É≥`);
  }

  // È≥¥„ÅçÊ©ü‰ºö„ÉÅ„Çß„ÉÉ„ÇØ
  private checkMeldOpportunities(discardedTile: Tile, fromPlayer: number): void {
    this.actionQueue = [];

    for (let i = 0; i < 4; i++) {
      if (i === fromPlayer) continue;

      const player = this.players[i];
      const possibleMelds = player.canMeld(discardedTile, fromPlayer);

      if (possibleMelds.length > 0) {
        // È≥¥„ÅçÂèØËÉΩ„Å™„Ç¢„ÇØ„Ç∑„Éß„É≥„Çí„Ç≠„É•„Éº„Å´ËøΩÂä†
        possibleMelds.forEach(meld => {
          this.actionQueue.push({
            type: meld.type as PlayerAction['type'],
            playerId: player.id,
            tile: discardedTile,
            meld,
            priority: this.getMeldPriority(meld.type),
            timestamp: Date.now(),
          });
        });
      }
    }

    // ÂÑ™ÂÖàÈ†Ü‰Ωç„Åß„ÇΩ„Éº„ÉàÔºà„É≠„É≥ > „Ç´„É≥ > „Éù„É≥ > „ÉÅ„ÉºÔºâ
    this.actionQueue.sort((a, b) => b.priority - a.priority);
  }

  // È≥¥„Åç„ÅÆÂÑ™ÂÖàÈ†Ü‰Ωç
  private getMeldPriority(meldType: string): number {
    switch (meldType) {
      case 'ron': return 4;
      case 'kan': return 3;
      case 'pon': return 2;
      case 'chi': return 1;
      default: return 0;
    }
  }

  // „Ç≤„Éº„É†Áä∂ÊÖãÊõ¥Êñ∞
  private updateGameState(): void {
    this.gameState = {
      ...this.gameState,
      players: this.players.map(p => this.playerToInterface(p)),
      remainingTiles: this.tileManager.getRemainingTileCount(),
      doraIndicators: this.tileManager.getDebugInfo().doraIndicators,
      availableActions: this.actionQueue,
      updatedAt: Date.now(),
    };
  }

  // Player „ÇØ„É©„Çπ„Çí IPlayer „Ç§„É≥„Çø„Éº„Éï„Çß„Éº„Çπ„Å´Â§âÊèõ
  private playerToInterface(player: Player): IPlayer {
    return {
      id: player.id,
      name: player.name,
      hand: player.hand,
      score: player.score,
      position: player.position,
      isDealer: player.isDealer,
      isBot: player.isBot,
      status: player.status,
      wind: player.wind,
    };
  }

  // „Ç≤„Éº„É†„Ç¢„ÇØ„Ç∑„Éß„É≥ËøΩÂä†
  private addGameAction(action: Omit<GameAction, 'id'>): void {
    const gameAction: GameAction = {
      ...action,
      id: `action_${Date.now()}`,
    };
    
    (this.gameState.gameLog as any).push(gameAction);
    console.log(`üìù ${gameAction.description}`);
  }

  // ÁèæÂú®„ÅÆ„Ç≤„Éº„É†Áä∂ÊÖãÂèñÂæó
  getGameState(): GameState {
    return { ...this.gameState };
  }

  // „Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†±
  getDebugInfo(): {
    gameId: string;
    phase: string;
    currentPlayer: string;
    remainingTiles: number;
    actionQueueLength: number;
    players: ReturnType<Player['getDebugInfo']>[];
  } {
    return {
      gameId: this.gameState.id,
      phase: this.gameState.phase,
      currentPlayer: this.players[this.gameState.currentPlayer]?.name || 'Unknown',
      remainingTiles: this.gameState.remainingTiles,
      actionQueueLength: this.actionQueue.length,
      players: this.players.map(p => p.getDebugInfo()),
    };
  }
}