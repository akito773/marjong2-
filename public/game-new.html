<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🀄 本格麻雀 v1.2.0</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700;900&display=swap" rel="stylesheet">
    <script src="/socket.io/socket.io.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Sans JP', sans-serif;
            background: linear-gradient(135deg, #1a5f2f 0%, #0f4021 50%, #0a2d17 100%);
            color: #212529;
            height: 100vh;
            overflow: auto;
        }
        
        /* デフォルト: 1920×1080対応 */
        body {
            min-width: 1920px;
            min-height: 1080px;
        }
        
        /* 2560×1440対応 */
        @media (min-width: 2560px) and (min-height: 1440px) {
            body {
                min-width: 2560px;
                min-height: 1440px;
            }
        }

        /* ヘッダー */
        .game-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
            height: 60px;
        }

        .game-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: #ffc107;
        }

        .game-info {
            display: flex;
            align-items: center;
            gap: 20px;
            color: white;
            font-size: 0.9rem;
        }

        .game-controls {
            display: flex;
            gap: 10px;
        }

        /* レスポンシブメインゲームエリア */
        .mahjong-container {
            width: 1920px;
            height: 1080px;
            padding-top: 80px;
            display: flex;
            flex-direction: column;
            margin: 0 auto;
        }

        /* レスポンシブゲームボード（中央エリア） */
        .game-board {
            width: 1880px;
            height: 980px;
            background: linear-gradient(135deg, #2d5a3d 0%, #1a4c2c 100%);
            border-radius: 20px;
            margin: 20px;
            position: relative;
            border: 8px solid #8b4513;
            box-shadow: 0 0 0 4px #ffc107, 0 20px 40px rgba(0, 0, 0, 0.3);
        }
        
        /* 2K対応: 2560×1440 */
        @media (min-width: 2560px) and (min-height: 1440px) {
            .mahjong-container {
                width: 2560px;
                height: 1440px;
                transform: scale(1.333); /* 1920→2560の比率 */
                transform-origin: top center;
            }
            
            .game-board {
                width: 2520px;
                height: 1320px;
            }
        }

        /* 2K対応プレイヤー配置 */
        .player-area {
            position: absolute;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 15px;
            padding: 20px;
            border: 3px solid transparent;
            transition: all 0.3s ease;
            min-width: 280px;
        }

        .player-area.current {
            border-color: #ffc107;
            box-shadow: 0 0 30px rgba(255, 193, 7, 0.6);
        }

        /* レスポンシブ上側プレイヤー（対面） */
        .player-top {
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            width: 280px;
        }

        /* レスポンシブ右側プレイヤー */
        .player-right {
            right: 30px;
            top: 50%;
            transform: translateY(-50%);
            text-align: center;
            width: 240px;
        }

        /* レスポンシブ左側プレイヤー */
        .player-left {
            left: 30px;
            top: 50%;
            transform: translateY(-50%);
            text-align: center;
            width: 240px;
        }
        
        /* 2K対応: プレイヤーエリア */
        @media (min-width: 2560px) and (min-height: 1440px) {
            .player-top {
                top: 40px;
                width: 350px;
            }
            
            .player-left, .player-right {
                width: 300px;
            }
            
            .player-left {
                left: 40px;
            }
            
            .player-right {
                right: 40px;
            }
        }

        /* プレイヤー情報 */
        .player-info {
            color: white;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .player-name {
            font-weight: 600;
            margin-bottom: 2px;
        }

        .player-wind {
            background: linear-gradient(135deg, #ffc107, #fd7e14);
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 600;
            display: inline-block;
        }

        /* 手牌表示 */
        .hand-tiles {
            display: flex;
            gap: 2px;
            flex-wrap: nowrap;
        }

        /* 対戦相手の手牌（裏向き） */
        .opponent-tiles {
            display: flex;
            gap: 2px;
        }

        .opponent-tile {
            width: 20px;
            height: 28px;
            background: #4a5568;
            border: 1px solid #2d3748;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 10px;
        }

        /* 左右のプレイヤーは縦向き */
        .player-left .opponent-tiles, 
        .player-right .opponent-tiles {
            flex-direction: column;
        }

        .player-left .opponent-tile, 
        .player-right .opponent-tile {
            width: 28px;
            height: 20px;
        }

        /* 本格麻雀の河レイアウト */
        .mahjong-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 800px;
            height: 600px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .rivers-horizontal {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex: 1;
        }

        .river-area {
            display: grid;
            gap: 1px;
            padding: 4px;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 6px;
        }

        /* レスポンシブ上下の河（横向き6×3） */
        .river-top, .river-bottom {
            grid-template-columns: repeat(6, 1fr);
            grid-template-rows: repeat(3, 1fr);
            width: 240px;
            height: 120px;
            margin: 0 auto;
        }

        /* レスポンシブ左右の河（縦向き3×6） */
        .river-left, .river-right {
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(6, 1fr);
            width: 100px;
            height: 240px;
        }
        
        /* 2K対応: 河エリア */
        @media (min-width: 2560px) and (min-height: 1440px) {
            .river-top, .river-bottom {
                width: 300px;
                height: 150px;
            }
            
            .river-left, .river-right {
                width: 120px;
                height: 300px;
            }
        }

        /* 2K対応河の牌スタイル */
        .river-tile {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: 600;
            cursor: default;
            min-width: 40px;
            min-height: 50px;
            max-width: 40px;
            max-height: 50px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .river-tile.red {
            color: #dc3545;
        }
        
        /* 鳴いた牌（チー・ポン・カンで呼ばれた牌）の表示 */
        .river-tile.called {
            background: #ffe6cc;
            border-color: #ff9800;
            border-width: 2px;
            box-shadow: 0 0 4px rgba(255, 152, 0, 0.5);
        }

        .river-tile.reach {
            transform: rotate(90deg);
            background: #ffe6e6;
            border-color: #ff9999;
        }

        /* 2K対応各プレイヤーの河牌方向 */
        .river-left .river-tile, 
        .river-right .river-tile {
            /* 南・北は横向き */
            transform: rotate(0deg);
            width: 50px;
            height: 40px;
            font-size: 14px;
        }

        .river-left .river-tile.reach, 
        .river-right .river-tile.reach {
            transform: rotate(90deg); /* リーチ牌は縦倒し */
        }

        .river-top .river-tile {
            /* 西は逆向き */
            transform: rotate(180deg);
        }

        .river-top .river-tile.reach {
            transform: rotate(90deg); /* リーチ牌は横倒し */
        }

        /* 中央情報エリア */
        .center-info {
            color: white;
            text-align: center;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 12px;
            padding: 15px;
            min-width: 120px;
        }

        .round-info {
            font-size: 1.1rem;
            font-weight: 600;
            color: #ffc107;
            margin-bottom: 8px;
        }

        .dora-info {
            background: rgba(255, 255, 255, 0.1);
            padding: 5px 10px;
            border-radius: 6px;
            font-size: 0.8rem;
            margin-bottom: 8px;
        }

        .remaining-tiles {
            font-size: 0.7rem;
            color: #ccc;
        }

        /* リーチ棒スタイル */
        .riichi-stick {
            background: linear-gradient(135deg, #ff6b6b, #ff5252);
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: bold;
            margin-top: 10px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(255, 107, 107, 0.3);
            border: 2px solid #fff;
        }

        @keyframes riichiPlace {
            0% {
                transform: translateY(-20px) scale(0.8);
                opacity: 0;
            }
            50% {
                transform: translateY(-5px) scale(1.1);
                opacity: 0.8;
            }
            100% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        /* 吹き出しスタイル */
        .speech-bubbles {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }

        .speech-bubble {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #333;
            border-radius: 20px;
            padding: 10px 15px;
            font-size: 1.1rem;
            font-weight: bold;
            color: #333;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            white-space: nowrap;
            animation: speechAppear 0.3s ease-out;
        }

        .speech-bubble::after {
            content: '';
            position: absolute;
            border: 8px solid transparent;
            border-top-color: rgba(255, 255, 255, 0.95);
        }

        /* プレイヤー位置別の吹き出し配置 */
        #speechBubble0 { /* 下（自分） */
            bottom: 200px;
            left: 50%;
            transform: translateX(-50%);
        }
        #speechBubble0::after {
            bottom: -16px;
            left: 50%;
            transform: translateX(-50%);
        }

        #speechBubble1 { /* 左 */
            left: 100px;
            top: 50%;
            transform: translateY(-50%);
        }
        #speechBubble1::after {
            left: -16px;
            top: 50%;
            transform: translateY(-50%) rotate(90deg);
        }

        #speechBubble2 { /* 上（対面） */
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
        }
        #speechBubble2::after {
            top: -16px;
            left: 50%;
            transform: translateX(-50%) rotate(180deg);
        }

        #speechBubble3 { /* 右 */
            right: 100px;
            top: 50%;
            transform: translateY(-50%);
        }
        #speechBubble3::after {
            right: -16px;
            top: 50%;
            transform: translateY(-50%) rotate(-90deg);
        }

        @keyframes speechAppear {
            0% {
                transform: scale(0) translateX(-50%);
                opacity: 0;
            }
            50% {
                transform: scale(1.1) translateX(-50%);
                opacity: 0.8;
            }
            100% {
                transform: scale(1) translateX(-50%);
                opacity: 1;
            }
        }

        /* 2K対応メルド表示エリア */
        .meld-area {
            display: flex;
            gap: 12px;
            margin-top: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .player-meld-area {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 12px;
            min-height: 80px;
            width: 100%;
        }

        /* プレイヤー別メルド配置 */
        .player-top .meld-area {
            position: absolute;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
        }

        .player-left .meld-area {
            position: absolute;
            right: -450px;
            top: 50%;
            transform: translateY(-50%);
            width: 400px;
        }

        .player-right .meld-area {
            position: absolute;
            left: -450px;
            top: 50%;
            transform: translateY(-50%);
            width: 400px;
        }

        .meld-group {
            display: flex;
            gap: 2px;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #007bff;
            border-radius: 8px;
            padding: 4px;
            margin-right: 8px;
            position: relative;
        }

        .meld-group.chi {
            border-color: #28a745;
        }

        .meld-group.pon {
            border-color: #ffc107;
        }

        .meld-group.kan {
            border-color: #dc3545;
        }

        .meld-tile {
            width: 48px;
            height: 64px;
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border: 2px solid #666;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1rem;
            font-weight: bold;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .meld-tile.red {
            color: #dc3545;
        }

        .meld-tile.called {
            transform: rotate(90deg);
            background: linear-gradient(135deg, #fff3cd, #ffeaa7);
        }

        .meld-label {
            position: absolute;
            top: -8px;
            left: 4px;
            background: #007bff;
            color: white;
            font-size: 0.6rem;
            padding: 2px 4px;
            border-radius: 4px;
            font-weight: bold;
        }

        .meld-group.chi .meld-label {
            background: #28a745;
        }

        .meld-group.pon .meld-label {
            background: #ffc107;
            color: #000;
        }

        .meld-group.kan .meld-label {
            background: #dc3545;
        }

        /* 下部プレイヤーの河は逆順配置 */
        .river-bottom {
            direction: rtl;
        }

        .river-bottom .river-tile {
            direction: ltr;
        }
        
        /* 河の表示方向修正 */
        .river-bottom {
            direction: ltr; /* 左から右へ */
        }
        
        /* デバッグ用: 自分の河の配置確認 */
        .river-bottom .river-tile {
            position: relative;
        }
        
        .river-bottom .river-tile::before {
            content: attr(data-order);
            position: absolute;
            top: -10px;
            left: 0;
            font-size: 8px;
            color: red;
        }

        /* 2K対応プレイヤーエリア（下部） */
        .player-bottom-area {
            background: rgba(255, 255, 255, 0.95);
            margin: 0 40px 40px 40px;
            border-radius: 15px;
            padding: 25px;
            border: 4px solid #ffc107;
        }

        .player-hand-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .player-details {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .hand-count {
            font-size: 0.9rem;
            color: #6c757d;
        }

        /* プレイヤーの手牌 */
        .player-hand {
            display: flex;
            gap: 4px;
            justify-content: flex-start;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .tile {
            background: white;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            padding: 8px 6px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            width: 40px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            user-select: none;
        }

        .tile:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            background: #f8f9fa;
        }

        .tile.selected {
            background: #fff3cd;
            border-color: #ffc107;
            transform: translateY(-6px);
            box-shadow: 0 6px 12px rgba(255, 193, 7, 0.4);
        }

        .tile.red {
            color: #dc3545;
            font-weight: 800;
        }

        /* プレイヤーの捨て牌 */
        .player-discards {
            border-top: 1px solid #dee2e6;
            padding-top: 10px;
        }

        .player-discards-title {
            font-size: 0.8rem;
            color: #6c757d;
            margin-bottom: 8px;
        }

        .player-discard-tiles {
            display: flex;
            gap: 3px;
            flex-wrap: wrap;
        }

        .player-discard-tiles .tile {
            width: 28px;
            height: 36px;
            font-size: 14px;
            cursor: default;
            background: #e9ecef;
            border-color: #ced4da;
        }

        .player-discard-tiles .tile:hover {
            transform: none;
            background: #e9ecef;
        }

        /* 各プレイヤーの個別捨牌エリア */
        .player-discard-area {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 2px;
            margin-top: 8px;
            padding: 6px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            min-height: 50px;
            max-width: 150px;
        }

        .player-top .player-discard-area {
            margin-top: 8px;
        }

        .player-left .player-discard-area,
        .player-right .player-discard-area {
            margin-top: 8px;
            max-width: 120px;
        }

        .player-discard-area .discard-tile {
            font-size: 9px;
            padding: 1px;
            min-width: 20px;
            height: 24px;
            cursor: default;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .player-discard-area .discard-tile:hover {
            transform: none;
            background: #f8f9fa;
        }

        .player-discard-area .discard-tile.red {
            color: #dc3545;
            font-weight: 800;
        }

        /* アクションボタン */
        .action-panel {
            position: fixed;
            bottom: 40px;
            left: 40px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            max-width: 500px;
            z-index: 50;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.9rem;
        }

        .btn-primary { background: #007bff; color: white; }
        .btn-danger { background: #dc3545; color: white; }
        .btn-warning { background: #ffc107; color: #212529; }
        .btn-success { background: #198754; color: white; }
        .btn-info { background: #0dcaf0; color: #212529; }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        /* 情報パネル */
        .info-panel {
            position: fixed;
            bottom: 200px;
            left: 40px;
            width: 280px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            z-index: 50;
            font-size: 1rem;
        }

        .game-status {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 10px;
            color: #212529;
        }

        .game-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
        }

        .stat-item {
            text-align: center;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 6px;
        }

        .stat-label {
            font-size: 0.7rem;
            color: #6c757d;
            margin-bottom: 3px;
        }

        .stat-value {
            font-size: 0.9rem;
            font-weight: 600;
            color: #212529;
        }

        /* 通知 */
        .notification {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .notification.show {
            opacity: 1;
        }

        .notification.success {
            background: #d1edff;
            color: #0c63e4;
        }

        .notification.error {
            background: #f8d7da;
            color: #721c24;
        }

        .notification.warning {
            background: #fff3cd;
            color: #856404;
        }

        /* レスポンシブ */
        @media (max-width: 768px) {
            .game-board {
                margin: 10px;
            }
            
            .info-panel {
                position: relative;
                top: auto;
                right: auto;
                width: 100%;
                margin: 10px;
            }
            
            .action-panel {
                position: relative;
                bottom: auto;
                right: auto;
                max-width: none;
                margin: 10px;
                justify-content: center;
            }

            .player-bottom-area {
                margin: 0 10px 10px 10px;
            }
        }
    </style>
</head>
<body>
    <div class="mahjong-container">
        <!-- ヘッダー -->
        <header class="game-header">
            <a href="/title.html" class="game-title" style="text-decoration: none;">🀄 本格麻雀 v1.2.0</a>
            
            <div class="game-info">
                <div id="gameInfo">東場 1局</div>
                <div>残り牌: <span id="remainingTiles">69</span></div>
                <div>現在: <span id="currentPlayerName">あなた</span></div>
            </div>

            <div class="game-controls">
                <button class="btn btn-info" onclick="toggleDebug()">デバッグ</button>
                <button id="cpuAutoBtn" class="btn btn-success" onclick="toggleCpuAuto()">CPU自動開始</button>
                <button id="playerAutoBtn" class="btn btn-secondary" onclick="togglePlayerAuto()">オートツモ切り</button>
                <button class="btn btn-warning" onclick="newGame()">新しいゲーム</button>
                <a href="/title.html" class="btn btn-info">タイトル</a>
            </div>
        </header>

        <!-- ゲームボード -->
        <div class="game-board">
            <!-- 上側プレイヤー（対面） -->
            <div class="player-area player-top" id="player2">
                <div class="player-info">
                    <div class="player-name">CPU西</div>
                    <div class="player-wind">西</div>
                    <div class="player-score">
                        <span id="player2Score">25000</span>点
                    </div>
                </div>
                <div class="opponent-tiles" id="hand2"></div>
                <div class="meld-area" id="melds2"></div>
            </div>

            <!-- 右側プレイヤー -->
            <div class="player-area player-right" id="player3">
                <div class="player-info">
                    <div class="player-name">CPU北</div>
                    <div class="player-wind">北</div>
                    <div class="player-score">
                        <span id="player3Score">25000</span>点
                    </div>
                </div>
                <div class="opponent-tiles" id="hand3"></div>
                <div class="meld-area" id="melds3"></div>
            </div>

            <!-- 左側プレイヤー -->
            <div class="player-area player-left" id="player1">
                <div class="player-info">
                    <div class="player-name">CPU南</div>
                    <div class="player-wind">南</div>
                    <div class="player-score">
                        <span id="player1Score">25000</span>点
                    </div>
                </div>
                <div class="opponent-tiles" id="hand1"></div>
                <div class="meld-area" id="melds1"></div>
            </div>

            <!-- 中央の河エリア（本格麻雀レイアウト） -->
            <div class="mahjong-center">
                <!-- 上側プレイヤーの河 -->
                <div class="river-area river-top" id="river2"></div>
                
                <!-- 左右の河と中央情報 -->
                <div class="rivers-horizontal">
                    <!-- 左側プレイヤーの河 -->
                    <div class="river-area river-left" id="river1"></div>
                    
                    <!-- 中央情報エリア -->
                    <div class="center-info">
                        <div class="round-info" id="roundInfo">東1局</div>
                        <div class="dora-info">
                            ドラ: <span id="doraIndicator">🀫</span>
                        </div>
                        <div class="remaining-tiles">
                            残り: <span id="remainingTilesDisplay">69</span>枚
                        </div>
                        <!-- リーチ棒 -->
                        <div class="riichi-stick" id="riichiStick" style="display: none;">
                            1000点棒
                        </div>
                    </div>
                    
                    <!-- 右側プレイヤーの河 -->
                    <div class="river-area river-right" id="river3"></div>
                </div>
                
                <!-- 下側プレイヤーの河 -->
                <div class="river-area river-bottom" id="river0"></div>
            </div>
        </div>

        <!-- 吹き出し表示エリア -->
        <div class="speech-bubbles">
            <div class="speech-bubble" id="speechBubble0" style="display: none;"></div>
            <div class="speech-bubble" id="speechBubble1" style="display: none;"></div>
            <div class="speech-bubble" id="speechBubble2" style="display: none;"></div>
            <div class="speech-bubble" id="speechBubble3" style="display: none;"></div>
        </div>

        <!-- プレイヤーエリア（下部） -->
        <div class="player-bottom-area" id="player0">
            <div class="player-hand-header">
                <div class="player-details">
                    <div class="player-name" id="playerName">あなた</div>
                    <div class="player-wind" id="playerWind">東</div>
                    <div style="color: #6c757d; font-size: 0.9rem;">
                        <span id="playerScore">25000</span>点
                    </div>
                </div>
                <div class="hand-count">
                    手牌: <span id="handCount">13</span>枚
                </div>
            </div>
            
            <div class="player-hand" id="hand0"></div>
            
            <!-- プレイヤー0のメルド表示エリア -->
            <div class="meld-area player-meld-area" id="melds0"></div>
            
        </div>

        <!-- 情報パネル -->
        <div class="info-panel">
            <div class="game-status" id="gameStatus">ゲーム開始</div>
            <div class="game-stats">
                <div class="stat-item">
                    <div class="stat-label">現在プレイヤー</div>
                    <div class="stat-value" id="currentPlayer">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">局数</div>
                    <div class="stat-value" id="round">1</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">本場</div>
                    <div class="stat-value" id="honba">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">残り牌</div>
                    <div class="stat-value" id="remainingTilesInfo">69</div>
                </div>
            </div>
            <button class="btn btn-success" onclick="requestGameState()" style="width: 100%;">
                状態を更新
            </button>
        </div>

        <!-- アクションパネル -->
        <div class="action-panel">
            <button class="btn btn-primary" onclick="drawTile()" id="drawBtn">ツモ</button>
            <button class="btn btn-danger" onclick="discardSelected()" id="discardBtn">打牌</button>
            <button class="btn" style="background: #ff6b6b; color: white;" onclick="callRiichi()" id="riichiBtn">リーチ</button>
            <button class="btn btn-warning" onclick="callChi()" id="chiBtn" style="display: inline-block;">チー</button>
            <button class="btn btn-warning" onclick="callPon()" id="ponBtn" style="display: inline-block;">ポン</button>
            <button class="btn btn-warning" onclick="callKan()" id="kanBtn" style="display: inline-block;">カン</button>
            <button class="btn btn-success" onclick="callTsumo()" id="tsumoBtn">ツモ</button>
            <button class="btn btn-success" onclick="callRon()" id="ronBtn">ロン</button>
            <button class="btn btn-info" onclick="executeAI()" id="aiBtn">AI実行</button>
        </div>
        
        <!-- デバッグパネル -->
        <div class="debug-panel" style="position: fixed; bottom: 160px; right: 20px; background: rgba(0,0,0,0.9); color: white; padding: 10px; border-radius: 8px; font-size: 0.75rem; z-index: 100; max-width: 180px;">
            <div style="font-weight: bold; margin-bottom: 8px;">🔧 デバッグ操作</div>
            <div style="display: grid; grid-template-columns: 1fr; gap: 6px;">
                <button class="btn" style="background: #6c757d; color: white; padding: 4px 8px; font-size: 0.7rem;" onclick="forceCPUTurn()">CPU強制実行</button>
                <button class="btn" style="background: #6c757d; color: white; padding: 4px 8px; font-size: 0.7rem;" onclick="showGameLog()">ログ表示</button>
                <button class="btn" style="background: #6c757d; color: white; padding: 4px 8px; font-size: 0.7rem;" onclick="toggleDebugMode()">デバッグ切替</button>
                <button class="btn" style="background: #6c757d; color: white; padding: 4px 8px; font-size: 0.7rem;" onclick="skipToNextPlayer()">次プレイヤー</button>
                <button class="btn" style="background: #6c757d; color: white; padding: 4px 8px; font-size: 0.7rem;" onclick="showDiscards()">捨て牌確認</button>
                <button class="btn" style="background: #17a2b8; color: white; padding: 4px 8px; font-size: 0.7rem;" onclick="testDiscardCoordinates()">座標テスト</button>
                <button class="btn" style="background: #28a745; color: white; padding: 4px 8px; font-size: 0.7rem;" onclick="testYakuAnalysis()">役判定テスト</button>
                <button class="btn" style="background: #dc3545; color: white; padding: 4px 8px; font-size: 0.7rem;" onclick="showErrorLogs()">エラーログ</button>
                <button class="btn" style="background: #6c757d; color: white; padding: 4px 8px; font-size: 0.7rem;" onclick="clearConsole()">コンソール消去</button>
            </div>
        </div>
    </div>

    <!-- 通知 -->
    <div class="notification" id="notification"></div>

    <!-- 音効制御パネル（位置修正：ヘッダーと重複回避） -->
    <div style="position: fixed; top: 70px; right: 10px; z-index: 1000; background: rgba(0,0,0,0.8); padding: 8px; border-radius: 6px; color: white;">
        <div style="display: flex; align-items: center; gap: 8px;">
            <button onclick="toggleSound()" id="soundToggle" class="btn" style="background: #28a745; color: white; border: none; padding: 4px 8px; border-radius: 4px; font-size: 0.8rem;">🔊</button>
            <input type="range" id="volumeSlider" min="0" max="100" value="70" onchange="setVolume(this.value)" style="width: 60px;">
        </div>
    </div>

    <script src="/js/SoundManager.js"></script>
    <script>
        let gameId = null;
        let selectedTile = null;
        let gameState = null;
        let debugMode = false;
        let lastDiscardedTile = null;
        let lastDiscardedPlayer = null;
        
        // 変数初期化
        let isConnected = false;
        let currentTenpaiStatus = { isTenpai: false, waitingTiles: [] };
        
        // Socket.IO接続
        const socket = io();
        
        // Socket.IOイベントハンドリング
        socket.on('connect', () => {
            console.log('🔌 Socket.IO接続成功');
            isConnected = true;
        });
        
        socket.on('disconnect', () => {
            console.log('🔌 Socket.IO切断');
            isConnected = false;
        });
        
        socket.on('gameUpdate', (newGameState) => {
            console.log('🔄 リアルタイムゲーム状態更新受信');
            gameState = newGameState;
            updateGameDisplay();
        });
        
        socket.on('gameCreated', (data) => {
            console.log('🎮 ゲーム作成成功:', data);
            gameId = data.gameId;
            showNotification('ゲームが作成されました！', 'success');
        });
        
        let gameStartNotified = false;
        
        socket.on('gameState', (newGameState) => {
            // console.log('🎮 ゲーム状態受信:', newGameState);
            gameState = newGameState;
            updateGameDisplay();
            
            // 初回のみゲーム開始通知を表示
            if (!gameStartNotified && newGameState.phase === 'playing') {
                showNotification('ゲームが開始されました！', 'success');
                gameStartNotified = true;
            }
        });

        // メルド機会の通知を受信
        socket.on('meldOpportunities', (data) => {
            const timestamp = new Date().toLocaleTimeString('ja-JP', {
                hour: '2-digit',
                minute: '2-digit', 
                second: '2-digit',
                fractionalSecondDigits: 3
            });
            console.log(`[${timestamp}] 🀄 [CLIENT] ===== メルド機会受信開始 =====`);
            console.log(`[${timestamp}] 🀄 [CLIENT] データ全体:`, data);
            console.log(`[${timestamp}] 🀄 [CLIENT] 捨て牌: ${data.discardedTile?.displayName || data.discardedTile?.unicode}`);
            console.log(`[${timestamp}] 🀄 [CLIENT] 捨て牌プレイヤー: ${data.discardPlayerId}`);
            console.log(`[${timestamp}] 🀄 [CLIENT] オート停止: ${data.autoPaused}`);
            console.log(`[${timestamp}] 🀄 [CLIENT] 機会があるプレイヤー数: ${data.opportunities?.length || 0}`);
            data.opportunities?.forEach(opp => {
                const types = [];
                if (opp.chi) types.push('チー');
                if (opp.pon) types.push('ポン');
                if (opp.kan) types.push('カン');
                console.log(`[${timestamp}] 🀄 [CLIENT] プレイヤー${opp.playerId}(${opp.playerType}): ${types.join('・')}`);
            });
            
            // lastDiscardedTileを直接設定
            console.log(`🔧 DEBUG: data.discardedTile exists: ${!!data.discardedTile}`);
            console.log(`🔧 DEBUG: data.discardPlayerId: ${data.discardPlayerId}`);
            console.log(`🔧 DEBUG: data.discardPlayerId !== undefined: ${data.discardPlayerId !== undefined}`);
            
            if (data.discardedTile && data.discardPlayerId !== undefined) {
                lastDiscardedTile = data.discardedTile;
                lastDiscardedPlayer = data.discardPlayerId;
                console.log(`🔧 lastDiscardedTile set from meldOpportunities: ${lastDiscardedTile.displayName} by player ${lastDiscardedPlayer}`);
            } else {
                console.log(`🔧 Failed to set lastDiscardedTile - condition not met`);
            }
            
            console.log(`[${timestamp}] 🀄 [CLIENT] showMeldOpportunities関数を呼び出します`);
            showMeldOpportunities(data);
            console.log(`[${timestamp}] 🀄 [CLIENT] ===== メルド機会受信終了 =====`);
        });

        // 和了結果受信
        socket.on('winResult', (data) => {
            console.log('🎯 和了結果受信:', data);
            
            if (data.success) {
                showNotification(`${data.message}`, 'success');
                
                if (data.yaku && data.yaku.length > 0) {
                    const yakuNames = data.yaku.map(y => y.name).join('・');
                    showNotification(`役: ${yakuNames} (${data.han}翻)`, 'info');
                }
                
                if (data.score) {
                    const score = data.score;
                    let scoreText = '';
                    
                    if (score.isYakuman) {
                        scoreText = `役満${score.yakumanCount > 1 ? score.yakumanCount + '倍' : ''}: ${score.total}点`;
                    } else {
                        scoreText = `${score.han}翻${score.fu}符: ${score.total}点`;
                    }
                    
                    showNotification(scoreText, 'success');
                    
                    // 詳細な支払い情報
                    if (score.isTsumo) {
                        showNotification(`ツモ: 全員から${score.payments.winner}点`, 'info');
                    } else {
                        showNotification(`ロン: ${score.payments.winner}点`, 'info');
                    }
                }
                
                // ゲーム終了状態の表示
                setTimeout(() => {
                    showNotification('ゲーム終了', 'info');
                }, 3000);
            } else {
                showNotification(`和了失敗: ${data.error}`, 'error');
            }
        });

        // メルド機会表示関数
        function showMeldOpportunities(data) {
            const { discardedTile, discardPlayerId, opportunities, autoPaused } = data;
            
            // 自分（プレイヤー0）の機会をチェック
            const myOpportunity = opportunities.find(opp => opp.playerId === 0);
            
            console.log('🀄 [DEBUG] showMeldOpportunities呼び出し');
            console.log('🀄 [DEBUG] myOpportunity:', myOpportunity);
            
            // ボタンが存在するかチェック
            console.log('🀄 [DEBUG] アクションパネル全体:', document.querySelector('.action-panel'));
            console.log('🀄 [DEBUG] 全てのボタン:', document.querySelectorAll('.action-panel button'));
            console.log('🀄 [DEBUG] chiBtn by class:', document.querySelector('#chiBtn'));
            console.log('🀄 [DEBUG] ponBtn by class:', document.querySelector('#ponBtn'));
            console.log('🀄 [DEBUG] kanBtn by class:', document.querySelector('#kanBtn'));
            
            if (myOpportunity) {
                console.log('🀄 自分にメルド機会:', myOpportunity);
                console.log('🀄 [DEBUG] chi:', myOpportunity.chi, 'pon:', myOpportunity.pon, 'kan:', myOpportunity.kan);
                
                // ボタン要素の存在確認
                const chiBtn = document.getElementById('chiBtn');
                const ponBtn = document.getElementById('ponBtn');
                const kanBtn = document.getElementById('kanBtn');
                
                console.log('🀄 [DEBUG] chiBtn要素:', chiBtn);
                console.log('🀄 [DEBUG] ponBtn要素:', ponBtn);
                console.log('🀄 [DEBUG] kanBtn要素:', kanBtn);
                
                // メルドボタンを強制表示
                if (chiBtn) {
                    chiBtn.style.display = 'inline-block';
                    chiBtn.style.visibility = 'visible';
                    console.log('🀄 [DEBUG] チーボタン表示設定完了');
                }
                if (ponBtn) {
                    ponBtn.style.display = 'inline-block';
                    ponBtn.style.visibility = 'visible';
                    console.log('🀄 [DEBUG] ポンボタン表示設定完了');
                }
                if (kanBtn) {
                    kanBtn.style.display = 'inline-block';
                    kanBtn.style.visibility = 'visible';
                    console.log('🀄 [DEBUG] カンボタン表示設定完了');
                }
                
                console.log('🀄 [DEBUG] ボタン表示設定完了');
                
                // 通知表示
                const meldTypes = [];
                if (myOpportunity.chi) meldTypes.push('チー');
                if (myOpportunity.pon) meldTypes.push('ポン');
                if (myOpportunity.kan) meldTypes.push('カン');
                
                // オート停止の通知
                if (autoPaused) {
                    showNotification(`${meldTypes.join('・')}が可能です！（オート機能を停止しました）`, 'warning');
                } else {
                    showNotification(`${meldTypes.join('・')}が可能です！`, 'info');
                }
                
                // 10秒後にボタンを非表示（オート停止時は長めに）
                setTimeout(() => {
                    hideMeldButtons();
                }, autoPaused ? 10000 : 5000);
            } else {
                hideMeldButtons();
            }
        }

        // メルドボタンを非表示にする関数（デバッグ用：無効化）
        function hideMeldButtons() {
            const chiBtn = document.getElementById('chiBtn');
            const ponBtn = document.getElementById('ponBtn');
            const kanBtn = document.getElementById('kanBtn');
            
            // デバッグ用：非表示にしない
            // if (chiBtn) chiBtn.style.display = 'none';
            // if (ponBtn) ponBtn.style.display = 'none';
            // if (kanBtn) kanBtn.style.display = 'none';
        }
        
        socket.on('roomJoined', (data) => {
            console.log('🎮 ルーム参加成功:', data);
            gameId = data.roomId;
            gameState = data.gameState;
            updateGameDisplay();
        });
        
        socket.on('actionResult', (result) => {
            console.log('✅ アクション結果:', result);
            if (result.success) {
                showNotification(result.message, 'success');
            } else {
                showNotification(result.message, 'error');
            }
        });
        
        socket.on('error', (error) => {
            console.error('❌ Socket.IOエラー:', error);
            showNotification(error.message, 'error');
        });
        
        socket.on('roomError', (error) => {
            console.error('❌ ルームエラー:', error);
            showNotification(error.message, 'error');
        });

        // 音効制御関数
        function toggleSound() {
            const isMuted = soundManager.toggleMute();
            const button = document.getElementById('soundToggle');
            button.textContent = isMuted ? '🔇' : '🔊';
            button.style.background = isMuted ? '#dc3545' : '#28a745';
            showNotification(isMuted ? '音効をミュートしました' : '音効を有効にしました', 'info');
        }

        function setVolume(value) {
            soundManager.setVolume(value / 100);
            showNotification(`音量: ${value}%`, 'info');
        }

        // 初期化
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('🔍 DEBUG: DOM loaded, initializing...');
            hideMeldButtons(); // 初期状態でメルドボタンを非表示
            try {
                await soundManager.init();
                console.log('🔍 DEBUG: SoundManager initialized');
            } catch (error) {
                console.warn('🔍 DEBUG: SoundManager init failed:', error);
            }
            
            // 捨て牌テスト機能を初期化
            addDiscardClickTest();
            console.log('🔍 DEBUG: Discard click test initialized');
            
            newGame();
            
            try {
                soundManager.playGameStart();
            } catch (error) {
                console.warn('🔍 DEBUG: playGameStart failed:', error);
            }
        });

        // 新しいゲーム作成
        function newGame() {
            if (!isConnected) {
                showNotification('サーバーに接続されていません', 'error');
                return;
            }
            
            showNotification('新しいゲームを作成中...', 'info');
            
            // Socket.IOでルーム作成要求
            socket.emit('createRoom', {
                playerId: 'player_0',
                playerName: 'プレイヤー1'
            });
        }

        // ゲーム状態更新
        function updateGameDisplay() {
            if (!gameState) {
                console.log('🔍 DEBUG: gameState is null or undefined');
                return;
            }

            // console.log('🔍 DEBUG: updateGameDisplay called');
            // console.log('🔍 DEBUG: gameState:', gameState);
            // console.log('🔍 DEBUG: gameState.players:', gameState.players);
            // console.log('🔍 DEBUG: gameState.currentPlayer:', gameState.currentPlayer);

            // 基本情報更新
            try {
                document.getElementById('currentPlayer').textContent = gameState.currentPlayer || '0';
                
                const currentPlayerName = gameState.players && gameState.players[gameState.currentPlayer] 
                    ? gameState.players[gameState.currentPlayer].name 
                    : 'Unknown';
                document.getElementById('currentPlayerName').textContent = currentPlayerName;
                console.log('🔍 DEBUG: currentPlayerName:', currentPlayerName);
                document.getElementById('remainingTiles').textContent = gameState.remainingTiles || '0';
                document.getElementById('remainingTilesInfo').textContent = gameState.remainingTiles || '0';
                
                if (gameState.round) {
                    document.getElementById('round').textContent = gameState.round.roundNumber || '1';
                    document.getElementById('honba').textContent = gameState.round.honbaCount || '0';
                    document.getElementById('roundInfo').textContent = `東${gameState.round.roundNumber || '1'}局 ${gameState.round.honbaCount || '0'}本場`;
                    document.getElementById('gameInfo').textContent = `東場 ${gameState.round.roundNumber || '1'}局`;
                }
                
                document.getElementById('doraIndicator').textContent = gameState.doraIndicators?.[0]?.unicode || '🀫';
                
                console.log('🔍 DEBUG: Basic info updated successfully');
            } catch (error) {
                console.error('🔍 DEBUG: Error updating basic info:', error);
            }

            // プレイヤー情報更新
            try {
                console.log('🔍 DEBUG: Starting player info update');
                if (!gameState.players || !Array.isArray(gameState.players)) {
                    console.error('🔍 DEBUG: gameState.players is not an array:', gameState.players);
                    return;
                }
                
                gameState.players.forEach((player, index) => {
                    console.log(`🔍 DEBUG: Processing player ${index}:`, player);
                    const playerElement = document.getElementById(`player${index}`);
                    if (!playerElement) {
                        console.warn(`🔍 DEBUG: Player element not found: player${index}`);
                        return;
                    }

                // 現在のプレイヤーをハイライト
                if (index === gameState.currentPlayer) {
                    playerElement.classList.add('current');
                } else {
                    playerElement.classList.remove('current');
                }

                // プレイヤー情報更新
                const nameElement = playerElement.querySelector('.player-name');
                const windElement = playerElement.querySelector('.player-wind');
                
                if (nameElement) nameElement.textContent = player.name;
                if (windElement) windElement.textContent = player.wind;

                    // 手牌更新
                    const handElement = document.getElementById(`hand${index}`);
                    console.log(`🔍 DEBUG: handElement for player ${index}:`, handElement);
                    console.log(`🔍 DEBUG: player.hand for player ${index}:`, player.hand);
                    console.log(`🔍 DEBUG: player.hand.tiles for player ${index}:`, player.hand?.tiles);
                    
                    if (handElement && player.hand && player.hand.tiles) {
                        handElement.innerHTML = '';
                        
                        if (index === 0) {
                            // プレイヤーの手牌（表示）
                            console.log(`🔍 DEBUG: Updating player 0 hand with ${player.hand.tiles.length} tiles`);
                            player.hand.tiles.forEach((tile, tileIndex) => {
                                const tileElement = document.createElement('div');
                                tileElement.className = 'tile';
                                if (tile.isRed) tileElement.classList.add('red');
                                tileElement.textContent = tile.displayName || tile.unicode;
                                tileElement.onclick = () => selectTile(index, tileIndex, tile);
                                handElement.appendChild(tileElement);
                            });
                            
                            // プレイヤー詳細情報更新
                            document.getElementById('handCount').textContent = player.hand.tiles.length;
                            document.getElementById('playerName').textContent = player.name;
                            document.getElementById('playerScore').textContent = player.score;
                            document.getElementById('playerWind').textContent = player.wind;
                            console.log(`🔍 DEBUG: Player 0 hand updated successfully with ${player.hand.tiles.length} tiles`);
                        } else {
                            // 対戦相手の手牌（裏向き）
                            console.log(`🔍 DEBUG: Updating opponent ${index} hand with ${player.hand.tiles.length} hidden tiles`);
                            for (let i = 0; i < player.hand.tiles.length; i++) {
                                const tileElement = document.createElement('div');
                                tileElement.className = 'opponent-tile';
                                tileElement.textContent = '🀫';
                                handElement.appendChild(tileElement);
                            }
                            
                            // CPU点数更新
                            const scoreElement = document.getElementById(`player${index}Score`);
                            if (scoreElement) {
                                scoreElement.textContent = player.score;
                            }
                        }
                    } else {
                        console.warn(`🔍 DEBUG: Cannot update hand for player ${index} - missing handElement or tiles`);
                    }
                });
                
                console.log('🔍 DEBUG: Player info update completed');
            } catch (error) {
                console.error('🔍 DEBUG: Error updating player info:', error);
            }

            // 各プレイヤーの河更新（本格麻雀仕様）
            if (gameState.players) {
                gameState.players.forEach((player, playerIndex) => {
                    const riverElement = document.getElementById(`river${playerIndex}`);
                    if (riverElement && player.hand && player.hand.discards) {
                        riverElement.innerHTML = '';
                        
                        player.hand.discards.forEach((tile, discardIndex) => {
                            const tileElement = document.createElement('div');
                            tileElement.className = 'river-tile';
                            
                            // 赤牌処理
                            if (tile.isRed) tileElement.classList.add('red');
                            
                            // リーチ宣言牌は横向き
                            if (player.hand.riichi && player.hand.riichiTile && 
                                isSameTile(tile, player.hand.riichiTile)) {
                                tileElement.classList.add('reach');
                            }
                            
                            // 鳴いた牌（チー・ポン・カンで呼ばれた牌）の判定
                            if (isCalledTile(tile, playerIndex, discardIndex)) {
                                tileElement.classList.add('called');
                            }
                            
                            tileElement.textContent = tile.displayName || tile.unicode;
                            
                            // プレイヤー位置に応じた牌の回転
                            switch (playerIndex) {
                                case 1: // CPU南（下家）：左に90度回転
                                    tileElement.style.transform = 'rotate(-90deg)';
                                    break;
                                case 3: // CPU北（対面）：左に90度回転
                                    tileElement.style.transform = 'rotate(-90deg)';
                                    break;
                                // case 0（自分）とcase 2（CPU西）はそのまま
                            }
                            
                            // 6×3グリッドの配置順序
                            const gridOrder = calculateRiverOrder(playerIndex, discardIndex);
                            tileElement.style.order = gridOrder;
                            
                            // デバッグ用: order値を表示
                            if (playerIndex === 0) {
                                tileElement.setAttribute('data-order', gridOrder);
                            }
                            
                            riverElement.appendChild(tileElement);
                        });
                    }
                });
            }

            // 最後の捨牌情報を更新（鳴き判定用）
            updateLastDiscardedTile();
            
            // ゲームステータス更新
            updateGameStatus();
            
            // メルド表示更新
            updateMeldDisplay();
            
            // テンパイ状態チェック
            updateTenpaiStatus();
        }

        // メルド表示更新
        function updateMeldDisplay() {
            if (!gameState || !gameState.players) return;
            
            gameState.players.forEach((player, playerIndex) => {
                const meldElement = document.getElementById(`melds${playerIndex}`);
                if (!meldElement || !player.hand || !player.hand.melds) return;
                
                meldElement.innerHTML = '';
                
                player.hand.melds.forEach((meld, meldIndex) => {
                    const meldGroup = document.createElement('div');
                    meldGroup.className = 'meld-group';
                    meldGroup.style.display = 'flex';
                    meldGroup.style.gap = '2px';
                    meldGroup.style.margin = '5px';
                    meldGroup.style.padding = '5px';
                    meldGroup.style.background = 'rgba(255, 255, 255, 0.9)';
                    meldGroup.style.border = '2px solid #007bff';
                    meldGroup.style.borderRadius = '8px';
                    
                    // メルドタイプラベル
                    const typeLabel = document.createElement('div');
                    typeLabel.style.fontSize = '10px';
                    typeLabel.style.color = '#007bff';
                    typeLabel.style.fontWeight = 'bold';
                    typeLabel.style.marginRight = '5px';
                    
                    switch (meld.type) {
                        case 'chi':
                            typeLabel.textContent = 'チー';
                            break;
                        case 'pon':
                            typeLabel.textContent = 'ポン';
                            break;
                        case 'kan':
                        case 'ankan':
                        case 'minkan':
                            typeLabel.textContent = 'カン';
                            break;
                    }
                    
                    meldGroup.appendChild(typeLabel);
                    
                    // メルドの牌を表示
                    meld.tiles.forEach((tile, tileIndex) => {
                        const tileElement = document.createElement('div');
                        tileElement.className = 'meld-tile';
                        tileElement.style.width = '20px';
                        tileElement.style.height = '28px';
                        tileElement.style.border = '1px solid #333';
                        tileElement.style.display = 'flex';
                        tileElement.style.alignItems = 'center';
                        tileElement.style.justifyContent = 'center';
                        tileElement.style.fontSize = '10px';
                        tileElement.style.background = 'white';
                        
                        // 暗槓の場合、端の牌は裏向き
                        if (meld.type === 'ankan' && (tileIndex === 0 || tileIndex === 3)) {
                            tileElement.textContent = '🀫';
                            tileElement.style.background = '#e9ecef';
                        } else {
                            tileElement.textContent = tile.displayName || tile.unicode;
                            if (tile.isRed) {
                                tileElement.style.color = '#dc3545';
                                tileElement.style.fontWeight = '800';
                            }
                        }
                        
                        meldGroup.appendChild(tileElement);
                    });
                    
                    meldElement.appendChild(meldGroup);
                });
            });
        }

        // 河の配置順序計算（本格麻雀仕様）
        function calculateRiverOrder(playerIndex, discardIndex) {
            const row = Math.floor(discardIndex / 6);
            const col = discardIndex % 6;
            
            switch (playerIndex) {
                case 0: // 下部プレイヤー（自分）：左から右、上から下、6枚で改行
                    return row * 6 + col;
                case 1: // 左プレイヤー（南）：上から下、右から左、3列6行（横向き視点）
                    const rowSouth = Math.floor(discardIndex / 6);
                    const colSouth = discardIndex % 6;
                    return colSouth * 6 + rowSouth;
                case 2: // 上部プレイヤー（西）：右から左、下から上（対面視点）
                    return (2 - row) * 6 + (5 - col);
                case 3: // 右プレイヤー（北）：下から上、左から右、3列6行（横向き視点）
                    const rowNorth = Math.floor(discardIndex / 6);
                    const colNorth = discardIndex % 6;
                    return (5 - colNorth) * 6 + (2 - rowNorth);
                default:
                    return discardIndex;
            }
        }
        
        // 牌が同じかチェック
        function isSameTile(tile1, tile2) {
            if (!tile1 || !tile2) return false;
            if (tile1.suit !== tile2.suit) return false;
            if (tile1.suit === 'ji') {
                return tile1.honor === tile2.honor;
            }
            return tile1.rank === tile2.rank;
        }
        
        // 鳴いた牌かどうかを判定
        function isCalledTile(tile, playerIndex, discardIndex) {
            if (!gameState || !gameState.gameLog) return false;
            
            // ゲームログから鳴きアクションを検索
            for (let i = 0; i < gameState.gameLog.length; i++) {
                const log = gameState.gameLog[i];
                
                // チー・ポン・カンアクションを探す
                if (log.type === 'meld' && log.calledTile) {
                    // 鳴いた牌と捨牌のタイルが一致するかチェック
                    if (isSameTile(tile, log.calledTile)) {
                        // 鳴いた元のプレイヤーと現在の捨牌位置が一致するかチェック
                        if (log.fromPlayer === playerIndex) {
                            return true;
                        }
                    }
                }
            }
            
            return false;
        }
        
        // 最後の捨牌情報を更新
        function updateLastDiscardedTile() {
            if (!gameState) return;
            
            console.log('🔧 updateLastDiscardedTile called');
            console.log('🔧 gameState.lastDiscard:', gameState.lastDiscard);
            console.log('🔧 gameState.lastDiscardPlayer:', gameState.lastDiscardPlayer);
            
            // gameStateから直接取得を試す
            if (gameState.lastDiscard && gameState.lastDiscardPlayer !== undefined && gameState.lastDiscardPlayer !== null) {
                lastDiscardedTile = gameState.lastDiscard;
                lastDiscardedPlayer = gameState.lastDiscardPlayer;
                console.log(`🔧 Last discard from gameState: ${lastDiscardedTile.displayName} by player ${lastDiscardedPlayer}`);
                return;
            }
            
            // デバッグ情報を追加
            // console.log(`🔧 [DEBUG] gameState.lastDiscard:`, gameState.lastDiscard);
            // console.log(`🔧 [DEBUG] gameState.lastDiscardPlayer:`, gameState.lastDiscardPlayer);
            
            // フォールバック：ゲームログを逆順で検索して最後の捨牌を見つける
            if (gameState.gameLog) {
                for (let i = gameState.gameLog.length - 1; i >= 0; i--) {
                    const log = gameState.gameLog[i];
                    if (log.type === 'discard' && log.data && log.data.tile) {
                        lastDiscardedTile = log.data.tile;
                        lastDiscardedPlayer = parseInt(log.playerId.replace('player_', ''));
                        console.log(`🔧 Last discard from log: ${log.data.tile.displayName} by player ${lastDiscardedPlayer}`);
                        return;
                    }
                }
            }
            
            // 捨牌が見つからない場合はリセット
            lastDiscardedTile = null;
            lastDiscardedPlayer = null;
            // console.log(`🔧 No last discard found, reset to null`);
        }

        // ゲームステータス更新
        function updateGameStatus() {
            const statusElement = document.getElementById('gameStatus');
            if (!gameState || !statusElement) return;

            const currentPlayerName = gameState.players[gameState.currentPlayer]?.name;
            const playerHand = gameState.players[0].hand.tiles;
            const handCount = playerHand ? playerHand.length : 0;
            const isMyTurn = gameState.currentPlayer === 0;
            
            let statusText = `${currentPlayerName}のターン`;
            if (isMyTurn) {
                if (handCount === 13) {
                    statusText = 'ツモしてください';
                } else if (handCount === 14) {
                    statusText = '打牌してください';
                }
            }
            
            statusElement.textContent = statusText;
            statusElement.style.color = isMyTurn ? '#28a745' : '#6c757d';
            
            // アクションボタンの表示制御
            updateActionButtons();
        }
        
        // アクションボタンの表示制御
        function updateActionButtons() {
            if (!gameState) return;
            
            const isMyTurn = gameState.currentPlayer === 0;
            const player = gameState.players?.[0];
            const handCount = player?.hand?.tiles?.length || 0;
            
            // メルド機会があるかチェック（lastDiscardedTileが設定されている場合）
            const hasMeldOpportunity = lastDiscardedTile && lastDiscardedTile.playerId !== 0;
            
            // 基本ボタン制御
            const drawBtn = document.getElementById('drawBtn');
            const discardBtn = document.getElementById('discardBtn');
            const riichiBtn = document.getElementById('riichiBtn');
            const tsumoBtn = document.getElementById('tsumoBtn');
            
            if (drawBtn) drawBtn.style.display = (isMyTurn && handCount === 13) ? 'inline-block' : 'none';
            if (discardBtn) discardBtn.style.display = (isMyTurn && handCount === 14) ? 'inline-block' : 'none';
            if (riichiBtn) riichiBtn.style.display = (isMyTurn && handCount === 14 && canCallRiichi()) ? 'inline-block' : 'none';
            if (tsumoBtn) tsumoBtn.style.display = (isMyTurn && handCount === 14 && canCallTsumo()) ? 'inline-block' : 'none';
            
            // メルドボタンは相手のターンでも表示可能
            const chiBtn = document.getElementById('chiBtn');
            const ponBtn = document.getElementById('ponBtn');
            const kanBtn = document.getElementById('kanBtn');
            const ronBtn = document.getElementById('ronBtn');
            
            // メルドボタンの条件表示（メルド機会がある場合は既に表示されているので保持）
            // メルド機会がない場合のみ非表示にする
            if (chiBtn && !hasMeldOpportunity) chiBtn.style.display = 'none';  
            if (ponBtn && !hasMeldOpportunity) ponBtn.style.display = 'none';  
            if (kanBtn && !hasMeldOpportunity) kanBtn.style.display = 'none';
            if (ronBtn) ronBtn.style.display = (!isMyTurn && canCallRon()) ? 'inline-block' : 'none';
            
            // 捨て牌更新を追跡
            trackDiscardUpdates();
        }
        
        // アクション可能性チェック関数
        function canCallRiichi() {
            if (!gameState || !gameState.players[0]) return false;
            const player = gameState.players[0];
            return !player.hand.riichi && player.score >= 1000; // 既にリーチしてない、1000点以上ある
        }
        
        function canCallTsumo() {
            if (!gameState || !gameState.players[0]) return false;
            
            const player = gameState.players[0];
            const handCount = player.hand.tiles.length;
            
            // 14枚でないとツモできない
            if (handCount !== 14) return false;
            
            // 自分のターンでないとツモできない
            if (gameState.currentPlayer !== 0) return false;
            
            // 簡易チェック：実際の判定はサーバー側で行う
            return true;
        }

        // テンパイ判定（簡易版）
        function checkClientTenpai() {
            if (!gameState || !gameState.players[0]) {
                return { isTenpai: false, waitingTiles: [] };
            }
            
            const player = gameState.players[0];
            const handCount = player.hand.tiles.length + (player.hand.melds.length * 3);
            
            // 13枚の場合のみテンパイチェック
            if (handCount !== 13) {
                return { isTenpai: false, waitingTiles: [] };
            }
            
            // 簡易的なテンパイ判定
            // 実際の詳細判定はサーバー側で行う
            const tiles = player.hand.tiles;
            
            // 基本的な形の確認（非常に簡易版）
            // 実装を簡単にするため、とりあえず手牌が13枚で特定条件を満たす場合にテンパイとする
            
            // 牌の種類をカウント
            const tileCounts = {};
            for (const tile of tiles) {
                const key = tile.honor ? `ji_${tile.honor}` : `${tile.suit}_${tile.rank}`;
                tileCounts[key] = (tileCounts[key] || 0) + 1;
            }
            
            // 対子の数をカウント
            let pairCount = 0;
            let tripleCount = 0;
            for (const count of Object.values(tileCounts)) {
                if (count === 2) pairCount++;
                if (count === 3) tripleCount++;
            }
            
            // 非常に簡易的な判定：対子が複数あるか、刻子がある場合にテンパイの可能性
            const isPossiblyTenpai = pairCount >= 1 || tripleCount >= 1;
            
            if (isPossiblyTenpai) {
                // 簡易的な待ち牌生成（実際はもっと複雑）
                const waitingTiles = [
                    { suit: 'man', rank: 1, displayName: '1万' },
                    { suit: 'pin', rank: 1, displayName: '1筒' },
                    { suit: 'sou', rank: 1, displayName: '1索' }
                ];
                
                return { isTenpai: true, waitingTiles };
            }
            
            return { isTenpai: false, waitingTiles: [] };
        }

        // テンパイ状態を更新・表示
        function updateTenpaiStatus() {
            if (!gameState || !gameState.players[0]) return;
            
            const newTenpaiStatus = checkClientTenpai();
            
            // テンパイ状態が変わった場合のみ更新
            if (newTenpaiStatus.isTenpai !== currentTenpaiStatus.isTenpai) {
                currentTenpaiStatus = newTenpaiStatus;
                
                if (currentTenpaiStatus.isTenpai) {
                    const waitingText = currentTenpaiStatus.waitingTiles.map(t => t.displayName).join('・');
                    showNotification(`テンパイ！ 待ち: ${waitingText}`, 'info');
                    console.log('🎯 テンパイ状態:', currentTenpaiStatus);
                } else {
                    console.log('🎯 テンパイ解除');
                }
            }
            
            // テンパイ表示の更新
            displayTenpaiStatus();
        }

        // テンパイ表示
        function displayTenpaiStatus() {
            // テンパイ表示エリアを取得または作成
            let tenpaiDisplay = document.getElementById('tenpaiDisplay');
            if (!tenpaiDisplay) {
                tenpaiDisplay = document.createElement('div');
                tenpaiDisplay.id = 'tenpaiDisplay';
                tenpaiDisplay.style.cssText = `
                    position: fixed;
                    top: 120px;
                    right: 20px;
                    background: rgba(255, 193, 7, 0.9);
                    color: #212529;
                    padding: 10px 15px;
                    border-radius: 8px;
                    font-weight: bold;
                    font-size: 0.9rem;
                    z-index: 1000;
                    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
                    border: 2px solid #ffc107;
                `;
                document.body.appendChild(tenpaiDisplay);
            }
            
            if (currentTenpaiStatus.isTenpai) {
                const waitingText = currentTenpaiStatus.waitingTiles.map(t => t.displayName).join('・');
                tenpaiDisplay.innerHTML = `
                    🎯 テンパイ<br>
                    <small>待ち: ${waitingText}</small>
                `;
                tenpaiDisplay.style.display = 'block';
            } else {
                tenpaiDisplay.style.display = 'none';
            }
        }
        
        function canCallChi() {
            if (!gameState || !gameState.players[0] || !lastDiscardedTile) return false;
            
            // チーは前のプレイヤーからのみ可能
            const prevPlayer = (gameState.currentPlayer + 3) % 4;
            if (lastDiscardedPlayer !== prevPlayer) return false;
            
            // 既にリーチしている場合は鳴けない
            if (gameState.players[0].hand.riichi) return false;
            
            // 簡易判定: 同じスート（ji以外）で連続する牌があるかチェック
            const discardedTile = lastDiscardedTile;
            if (discardedTile.suit === 'ji') return false; // 字牌はチー不可
            
            const myTiles = gameState.players[0].hand.tiles;
            const targetRank = discardedTile.rank;
            
            // 連続する牌の組み合わせをチェック
            const hasSequence = myTiles.some((tile1, i) => 
                myTiles.some((tile2, j) => {
                    if (i >= j) return false;
                    if (tile1.suit !== discardedTile.suit || tile2.suit !== discardedTile.suit) return false;
                    
                    // 3つの数字の組み合わせをチェック
                    const ranks = [tile1.rank, tile2.rank, targetRank].sort((a, b) => a - b);
                    return ranks[0] + 1 === ranks[1] && ranks[1] + 1 === ranks[2];
                })
            );
            
            return hasSequence;
        }
        
        function canCallPon() {
            if (!gameState || !gameState.players[0] || !lastDiscardedTile) return false;
            
            // 既にリーチしている場合は鳴けない
            if (gameState.players[0].hand.riichi) return false;
            
            // 同じ牌が2枚以上手牌にあるかチェック
            const discardedTile = lastDiscardedTile;
            const myTiles = gameState.players[0].hand.tiles;
            
            let matchCount = 0;
            for (const tile of myTiles) {
                if (isSameTile(tile, discardedTile)) {
                    matchCount++;
                    if (matchCount >= 2) return true;
                }
            }
            
            return false;
        }
        
        function canCallKan() {
            if (!gameState || !gameState.players[0]) return false;
            
            // 既にリーチしている場合は鳴けない（暗槓は例外だが簡略化）
            if (gameState.players[0].hand.riichi) return false;
            
            const myTiles = gameState.players[0].hand.tiles;
            
            // 同じ牌が4枚あるかチェック（暗槓）
            const tileCounts = {};
            for (const tile of myTiles) {
                const key = `${tile.suit}_${tile.rank}_${tile.honor}`;
                tileCounts[key] = (tileCounts[key] || 0) + 1;
                if (tileCounts[key] >= 4) return true;
            }
            
            // 明槓の場合（相手の捨牌+手牌3枚）
            if (lastDiscardedTile) {
                let matchCount = 0;
                for (const tile of myTiles) {
                    if (isSameTile(tile, lastDiscardedTile)) {
                        matchCount++;
                        if (matchCount >= 3) return true;
                    }
                }
            }
            
            return false;
        }
        
        function canCallRon() {
            if (!gameState || !gameState.players[0] || !lastDiscardedTile) return false;
            
            const player = gameState.players[0];
            const handCount = player.hand.tiles.length;
            
            // 13枚でないとロンできない
            if (handCount !== 13) return false;
            
            // 自分のターンではロンできない
            if (gameState.currentPlayer === 0) return false;
            
            // 簡易チェック：実際の判定はサーバー側で行う
            return true;
        }

        // 牌選択
        function selectTile(playerIndex, tileIndex, tile) {
            if (playerIndex !== 0) {
                showNotification('自分の牌のみ選択できます', 'warning');
                return;
            }
            
            if (gameState && gameState.currentPlayer !== 0) {
                showNotification('あなたのターンではありません', 'warning');
                return;
            }

            // 選択解除
            document.querySelectorAll('.tile.selected').forEach(t => t.classList.remove('selected'));

            // 既に選択されている牌をクリックした場合は打牌
            if (selectedTile && selectedTile.tileIndex === tileIndex && selectedTile.tile.id === tile.id) {
                discardSelected();
                return;
            }

            // 新しい牌を選択
            selectedTile = { playerIndex, tileIndex, tile };
            document.getElementById('hand0').children[tileIndex].classList.add('selected');
            soundManager.playSound('tileSelect');
            showNotification(`${tile.displayName || tile.unicode} を選択（再クリックで打牌）`, 'info');
        }

        // 打牌処理
        function discardSelected() {
            if (!selectedTile || !gameId || !isConnected) {
                showNotification('牌を選択してください', 'warning');
                return;
            }

            console.log('🎯 打牌アクション送信:', selectedTile.tile);
            socket.emit('playerAction', {
                type: 'discard',
                playerId: 'player_0',
                tileId: selectedTile.tile.id,
                priority: 1,
                timestamp: Date.now()
            });
            
            selectedTile = null;
            soundManager.playSound('tilePlace');
        }

        // ツモ処理
        function drawTile() {
            if (!gameId || !isConnected) {
                showNotification('ゲームに接続されていません', 'error');
                return;
            }
            
            console.log('🎯 ツモアクション送信');
            socket.emit('playerAction', {
                type: 'draw',
                playerId: 'player_0',
                priority: 1,
                timestamp: Date.now()
            });
            
            soundManager.playSound('tilePlace');
        }

        // ゲーム状態取得
        function requestGameState() {
            if (!gameId || !isConnected) {
                showNotification('ゲームに接続されていません', 'error');
                return;
            }
            
            console.log('🔄 ゲーム状態をリクエスト');
            socket.emit('requestGameState');
        }

        // AI実行
        async function executeAI() {
            if (!gameId) return;
            
            try {
                const response = await fetch(`/api/game/${gameId}/ai`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });

                const result = await response.json();
                if (result.status === 'OK') {
                    gameState = result.data.gameState;
                    updateGameDisplay();
                    soundManager.playSound('tilePlace');
                    showNotification(result.message || 'AI が行動しました', 'success');
                } else {
                    showNotification(result.message || 'AI実行に失敗しました', 'error');
                }
            } catch (error) {
                console.error('AI error:', error);
                showNotification('エラーが発生しました', 'error');
            }
        }

        // 鳴き関数
        // チー
        async function callChi() {
            console.log('🎯 callChi() called');
            console.log('🎯 gameState:', !!gameState);
            console.log('🎯 lastDiscardedTile:', lastDiscardedTile);
            console.log('🎯 lastDiscardedPlayer:', lastDiscardedPlayer);
            
            if (!gameState || !lastDiscardedTile) {
                console.log('🎯 Chi early return - missing gameState or lastDiscardedTile');
                showNotification('チーできません', 'error');
                return;
            }
            
            try {
                // 手牌からチーに使用する牌を見つける
                const myTiles = gameState.players[0].hand.tiles;
                const targetRank = lastDiscardedTile.rank;
                
                // 連続する牌の組み合わせを探す
                let chiTiles = null;
                for (let i = 0; i < myTiles.length - 1; i++) {
                    for (let j = i + 1; j < myTiles.length; j++) {
                        const tile1 = myTiles[i];
                        const tile2 = myTiles[j];
                        
                        if (tile1.suit !== lastDiscardedTile.suit || tile2.suit !== lastDiscardedTile.suit) continue;
                        if (tile1.suit === 'ji') continue; // 字牌はチー不可
                        
                        const ranks = [tile1.rank, tile2.rank, targetRank].sort((a, b) => a - b);
                        if (ranks[0] + 1 === ranks[1] && ranks[1] + 1 === ranks[2]) {
                            chiTiles = [tile1, tile2];
                            break;
                        }
                    }
                    if (chiTiles) break;
                }
                
                if (!chiTiles) {
                    showNotification('チーできる牌がありません', 'error');
                    return;
                }
                
                // メルドオブジェクトを構築
                const meld = {
                    id: `chi_${Date.now()}_player0`,
                    type: 'chi',
                    tiles: [...chiTiles, lastDiscardedTile],
                    fromPlayer: lastDiscardedPlayer,
                    isConcealed: false,
                    calledTile: lastDiscardedTile
                };

                console.log('🎯 チーアクション送信');
                socket.emit('playerAction', {
                    type: 'chi',
                    playerId: 'player_0',
                    meld: meld,
                    tile: lastDiscardedTile,
                    priority: 2,
                    timestamp: Date.now()
                });
                
                soundManager.playSound('meld');
            } catch (error) {
                console.error('Chi error:', error);
                showNotification('エラーが発生しました', 'error');
            }
        }

        // ポン
        async function callPon() {
            console.log('🎯 callPon() called');
            console.log('🎯 gameState:', !!gameState);
            console.log('🎯 lastDiscardedTile:', lastDiscardedTile);
            console.log('🎯 lastDiscardedPlayer:', lastDiscardedPlayer);
            
            if (!gameState || !lastDiscardedTile) {
                console.log('🎯 Pon early return - missing gameState or lastDiscardedTile');
                showNotification('ポンできません', 'error');
                return;
            }
            
            try {
                // 手牌から同じ牌を2枚探す
                const myTiles = gameState.players[0].hand.tiles;
                const matchingTiles = [];
                
                for (const tile of myTiles) {
                    if (isSameTile(tile, lastDiscardedTile)) {
                        matchingTiles.push(tile);
                        if (matchingTiles.length >= 2) break;
                    }
                }
                
                if (matchingTiles.length < 2) {
                    showNotification('ポンできる牌がありません', 'error');
                    return;
                }
                
                // メルドオブジェクトを構築
                const meld = {
                    id: `pon_${Date.now()}_player0`,
                    type: 'pon',
                    tiles: [...matchingTiles, lastDiscardedTile],
                    fromPlayer: lastDiscardedPlayer,
                    isConcealed: false,
                    calledTile: lastDiscardedTile
                };

                console.log('🎯 ポンアクション送信');
                console.log('🀄 [PON DEBUG] lastDiscardedTile:', lastDiscardedTile);
                console.log('🀄 [PON DEBUG] matchingTiles:', matchingTiles);
                console.log('🀄 [PON DEBUG] meld:', meld);
                console.log('🀄 [PON DEBUG] currentPlayer:', gameState.currentPlayer);
                console.log('🀄 [PON DEBUG] lastDiscardedPlayer:', lastDiscardedPlayer);
                
                socket.emit('playerAction', {
                    type: 'pon',
                    playerId: 'player_0',
                    meld: meld,
                    tile: lastDiscardedTile,
                    priority: 2,
                    timestamp: Date.now()
                });
                
                soundManager.playSound('meld');
            } catch (error) {
                console.error('Pon error:', error);
                showNotification('エラーが発生しました', 'error');
            }
        }

        // カン
        async function callKan() {
            if (!gameState) {
                showNotification('カンできません', 'error');
                return;
            }
            
            try {
                const myTiles = gameState.players[0].hand.tiles;
                let kanTiles = [];
                let kanType = null;
                
                // 明槓の場合（相手の捨牌+手牌3枚）
                if (lastDiscardedTile) {
                    const matchingTiles = [];
                    for (const tile of myTiles) {
                        if (isSameTile(tile, lastDiscardedTile)) {
                            matchingTiles.push(tile);
                            if (matchingTiles.length >= 3) break;
                        }
                    }
                    
                    if (matchingTiles.length >= 3) {
                        kanTiles = [...matchingTiles, lastDiscardedTile];
                        kanType = 'kan';
                    }
                }
                
                // 暗槓の場合（手牌4枚）
                if (kanTiles.length === 0) {
                    const tileCounts = {};
                    for (const tile of myTiles) {
                        const key = `${tile.suit}_${tile.rank}_${tile.honor}`;
                        if (!tileCounts[key]) tileCounts[key] = [];
                        tileCounts[key].push(tile);
                    }
                    
                    for (const [key, tiles] of Object.entries(tileCounts)) {
                        if (tiles.length >= 4) {
                            kanTiles = tiles.slice(0, 4);
                            kanType = 'ankan';
                            break;
                        }
                    }
                }
                
                if (kanTiles.length === 0) {
                    showNotification('カンできる牌がありません', 'error');
                    return;
                }
                
                // メルドオブジェクトを構築
                const meld = {
                    id: `kan_${Date.now()}_player0`,
                    type: kanType,
                    tiles: kanTiles,
                    fromPlayer: kanType === 'ankan' ? 0 : lastDiscardedPlayer,
                    isConcealed: kanType === 'ankan',
                    calledTile: kanType === 'ankan' ? null : lastDiscardedTile
                };

                console.log('🎯 カンアクション送信');
                socket.emit('playerAction', {
                    type: kanType,
                    playerId: 'player_0',
                    meld: meld,
                    tile: kanType === 'ankan' ? kanTiles[0] : lastDiscardedTile,
                    priority: 3,
                    timestamp: Date.now()
                });
                
                soundManager.playSound('meld');
            } catch (error) {
                console.error('Kan error:', error);
                showNotification('エラーが発生しました', 'error');
            }
        }

        // ツモ和了
        function callTsumo() {
            if (!gameState || gameState.currentPlayer !== 0) {
                showNotification('ツモできません（あなたのターンではありません）', 'error');
                return;
            }
            
            console.log('🎯 ツモアクション送信');
            socket.emit('playerAction', {
                type: 'tsumo',
                playerId: 'player_0',
                priority: 5,
                timestamp: Date.now()
            });
            
            soundManager.playSound('tilePlace');
        }

        // ロン和了
        function callRon() {
            if (!gameState || gameState.currentPlayer === 0) {
                showNotification('ロンできません', 'error');
                return;
            }
            
            console.log('🎯 ロンアクション送信');
            socket.emit('playerAction', {
                type: 'ron',
                playerId: 'player_0',
                priority: 5,
                timestamp: Date.now()
            });
            
            soundManager.playSound('tilePlace');
        }

        // リーチ
        function callRiichi() {
            if (!gameState || gameState.currentPlayer !== 0) {
                showNotification('リーチできません（あなたのターンではありません）', 'error');
                return;
            }
            
            if (!canCallRiichi()) {
                showNotification('リーチできません（条件を満たしていません）', 'error');
                return;
            }
            
            // リーチ棒演出
            showRiichiStick();
            
            performAction('riichi', {}, (result) => {
                if (result.success) {
                    showNotification('リーチ！', 'success');
                    requestGameState();
                } else {
                    showNotification(`リーチできません: ${result.error}`, 'error');
                    hideRiichiStick(); // 失敗時は棒を隠す
                }
            });
        }
        
        // リーチ棒演出
        function showRiichiStick() {
            const riichiStick = document.getElementById('riichiStick');
            if (riichiStick) {
                riichiStick.style.display = 'block';
                riichiStick.style.animation = 'riichiPlace 0.5s ease-out';
                riichiStick.textContent = '1000点棒';
            }
        }
        
        function hideRiichiStick() {
            const riichiStick = document.getElementById('riichiStick');
            if (riichiStick) {
                riichiStick.style.display = 'none';
            }
        }
        
        // 吹き出し表示機能
        function showSpeechBubble(playerIndex, message, duration = 2000) {
            const bubble = document.getElementById(`speechBubble${playerIndex}`);
            if (bubble) {
                bubble.textContent = message;
                bubble.style.display = 'block';
                bubble.style.animation = 'speechAppear 0.3s ease-out';
                
                // 一定時間後に自動非表示
                setTimeout(() => {
                    bubble.style.display = 'none';
                }, duration);
            }
        }
        
        // メルド宣言用の吹き出し
        function showMeldAnnouncement(playerIndex, meldType, tiles) {
            let message = '';
            switch (meldType) {
                case 'chi':
                    message = 'チー！';
                    break;
                case 'pon':
                    message = 'ポン！';
                    break;
                case 'kan':
                    message = 'カン！';
                    break;
                case 'riichi':
                    message = 'リーチ！';
                    break;
                case 'tsumo':
                    message = 'ツモ！';
                    break;
                case 'ron':
                    message = 'ロン！';
                    break;
                default:
                    message = meldType;
            }
            showSpeechBubble(playerIndex, message, 3000);
        }
        
        // メルド表示機能
        function updateMeldDisplay() {
            if (!gameState || !gameState.players) return;
            
            gameState.players.forEach((player, playerIndex) => {
                const meldArea = document.getElementById(`melds${playerIndex}`);
                if (!meldArea) return;
                
                meldArea.innerHTML = '';
                
                if (player.hand && player.hand.melds) {
                    player.hand.melds.forEach((meld, meldIndex) => {
                        const meldGroup = createMeldDisplay(meld);
                        meldArea.appendChild(meldGroup);
                    });
                }
            });
        }
        
        function createMeldDisplay(meld) {
            const meldGroup = document.createElement('div');
            meldGroup.className = `meld-group ${meld.type}`;
            
            // メルドラベル
            const label = document.createElement('div');
            label.className = 'meld-label';
            label.textContent = meld.type.toUpperCase();
            meldGroup.appendChild(label);
            
            // メルドの牌表示
            meld.tiles.forEach((tile, tileIndex) => {
                const tileElement = document.createElement('div');
                tileElement.className = 'meld-tile';
                
                if (tile.isRed) tileElement.classList.add('red');
                
                // 鳴いた牌は横向き（チー・ポンの場合、最後の牌）
                if (meld.type !== 'kan' && tileIndex === meld.tiles.length - 1) {
                    tileElement.classList.add('called');
                }
                
                tileElement.textContent = tile.displayName || tile.unicode;
                meldGroup.appendChild(tileElement);
            });
            
            return meldGroup;
        }

        function toggleDebug() {
            debugMode = !debugMode;
            showNotification(debugMode ? 'デバッグモードON' : 'デバッグモードOFF', 'info');
        }

        // CPU自動対戦モード切り替え
        let cpuAutoMode = false;
        function toggleCpuAuto() {
            if (!gameId) {
                showNotification('ゲームが開始されていません', 'error');
                return;
            }

            cpuAutoMode = !cpuAutoMode;
            const btn = document.getElementById('cpuAutoBtn');
            
            if (cpuAutoMode) {
                btn.textContent = 'CPU自動停止';
                btn.className = 'btn btn-danger';
                showNotification('🤖 CPU自動対戦モード開始', 'success');
                
                // サーバーにCPU自動モード開始を通知
                fetch(`/api/game/${gameId}/cpu-auto`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        enabled: true,
                        speed: 400
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'OK') {
                        console.log('✅ CPU自動対戦開始:', data.message);
                        // 定期的にゲーム状態を更新
                        startCpuAutoMonitoring();
                    } else {
                        throw new Error(data.message);
                    }
                })
                .catch(error => {
                    console.error('❌ CPU自動対戦開始エラー:', error);
                    showNotification('CPU自動対戦開始失敗: ' + error.message, 'error');
                    // ボタンを元に戻す
                    cpuAutoMode = false;
                    btn.textContent = 'CPU自動開始';
                    btn.className = 'btn btn-success';
                });
            } else {
                btn.textContent = 'CPU自動開始';
                btn.className = 'btn btn-success';
                showNotification('🛑 CPU自動対戦モード停止', 'warning');
                
                // サーバーにCPU自動モード停止を通知
                fetch(`/api/game/${gameId}/cpu-auto`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        enabled: false
                    })
                })
                .then(response => response.json())
                .then(data => {
                    console.log('🛑 CPU自動対戦停止:', data.message);
                    stopCpuAutoMonitoring();
                })
                .catch(error => {
                    console.error('❌ CPU自動対戦停止エラー:', error);
                });
            }
        }

        // CPU自動対戦モード監視
        let cpuAutoInterval = null;
        function startCpuAutoMonitoring() {
            if (cpuAutoInterval) clearInterval(cpuAutoInterval);
            
            cpuAutoInterval = setInterval(() => {
                if (cpuAutoMode && gameId) {
                    requestGameState();
                }
            }, 2000); // 2秒ごとに状態確認
        }

        function stopCpuAutoMonitoring() {
            if (cpuAutoInterval) {
                clearInterval(cpuAutoInterval);
                cpuAutoInterval = null;
            }
        }

        // プレイヤーオートツモ切りモード切り替え
        let playerAutoMode = false;
        function togglePlayerAuto() {
            if (!gameId) {
                showNotification('ゲームが開始されていません', 'error');
                return;
            }

            playerAutoMode = !playerAutoMode;
            const btn = document.getElementById('playerAutoBtn');
            
            if (playerAutoMode) {
                btn.textContent = 'オート切OFF';
                btn.className = 'btn btn-primary';
                showNotification('🎯 オートツモ切りモード開始', 'success');
                
                // サーバーにプレイヤーオートモード開始を通知
                fetch(`/api/game/${gameId}/player-auto`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        enabled: true
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'OK') {
                        console.log('✅ プレイヤーオートツモ切り開始:', data.message);
                    } else {
                        throw new Error(data.message);
                    }
                })
                .catch(error => {
                    console.error('❌ プレイヤーオートツモ切り開始エラー:', error);
                    showNotification('オートツモ切り開始失敗: ' + error.message, 'error');
                    // ボタンを元に戻す
                    playerAutoMode = false;
                    btn.textContent = 'オートツモ切り';
                    btn.className = 'btn btn-secondary';
                });
            } else {
                btn.textContent = 'オートツモ切り';
                btn.className = 'btn btn-secondary';
                showNotification('🛑 オートツモ切りモード停止', 'warning');
                
                // サーバーにプレイヤーオートモード停止を通知
                fetch(`/api/game/${gameId}/player-auto`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        enabled: false
                    })
                })
                .then(response => response.json())
                .then(data => {
                    console.log('🛑 プレイヤーオートツモ切り停止:', data.message);
                })
                .catch(error => {
                    console.error('❌ プレイヤーオートツモ切り停止エラー:', error);
                });
            }
        }

        // デバッグ関数群
        function forceCPUTurn() {
            if (!gameState) {
                showNotification('ゲーム状態がありません', 'error');
                return;
            }
            const currentPlayer = gameState.players[gameState.currentPlayer];
            if (currentPlayer && currentPlayer.name.includes('CPU')) {
                executeAI();
                showNotification(`${currentPlayer.name}のターンを強制実行`, 'info');
            } else {
                showNotification('現在のプレイヤーはCPUではありません', 'warning');
            }
        }

        function showGameLog() {
            if (!gameState || !gameState.gameLog) {
                console.log('📋 ゲームログ: なし');
                showNotification('ゲームログがありません', 'warning');
                return;
            }
            console.log('📋 ゲームログ:', gameState.gameLog);
            console.log('📋 ゲームログ詳細:');
            gameState.gameLog.forEach((log, index) => {
                console.log(`  ${index + 1}. [${log.type}] ${log.description}`, log);
            });
            showNotification(`ゲームログをコンソールに表示 (${gameState.gameLog.length}件)`, 'info');
        }

        function toggleDebugMode() {
            debugMode = !debugMode;
            showNotification(debugMode ? '🔧 デバッグモードON' : '🔧 デバッグモードOFF', 'info');
        }

        function skipToNextPlayer() {
            if (!gameState) {
                showNotification('ゲーム状態がありません', 'error');
                return;
            }
            const nextPlayer = (gameState.currentPlayer + 1) % 4;
            console.log(`⏭️ 次のプレイヤーに強制移行: ${gameState.currentPlayer} → ${nextPlayer}`);
            showNotification(`プレイヤー${nextPlayer}のターンに移行`, 'info');
        }

        function showDiscards() {
            if (!gameState) {
                showNotification('ゲーム状態がありません', 'error');
                return;
            }
            console.log('🗂️ 捨て牌情報:');
            gameState.players.forEach((player, index) => {
                console.log(`  プレイヤー${index} (${player.name}): `, player.hand.discards);
            });
            if (gameState.gameLog) {
                const discardLogs = gameState.gameLog.filter(log => log.type === 'discard');
                console.log(`🗂️ ゲームログ内の捨て牌: ${discardLogs.length}件`, discardLogs);
            }
            showNotification('捨て牌情報をコンソールに表示', 'info');
        }
        
        // サーバーエラーログ表示
        async function showErrorLogs() {
            try {
                const response = await fetch('/api/logs/error');
                const result = await response.json();
                
                if (result.status === 'OK') {
                    console.log('📋 サーバーエラーログ (最新50行):');
                    console.log('=' .repeat(60));
                    console.log(result.logs || 'エラーログはありません');
                    console.log('=' .repeat(60));
                    showNotification('エラーログをコンソールに表示しました', 'info');
                } else {
                    console.error('エラーログ取得失敗:', result.message);
                    showNotification('エラーログの取得に失敗しました', 'error');
                }
            } catch (error) {
                console.error('エラーログ取得エラー:', error);
                showNotification('エラーログの取得でエラーが発生しました', 'error');
            }
        }

        function clearConsole() {
            console.clear();
            showNotification('コンソールをクリアしました', 'info');
        }

        // 捨て牌座標テスト機能
        function testDiscardCoordinates() {
            console.log('🎯 捨て牌座標テスト開始');
            
            if (!gameState || !gameState.players) {
                showNotification('ゲーム状態が無効です', 'error');
                return;
            }
            
            // 各プレイヤーの捨て牌エリアの座標を確認
            for (let i = 0; i < 4; i++) {
                const discardElement = document.getElementById(`discards${i}`);
                if (discardElement) {
                    const rect = discardElement.getBoundingClientRect();
                    const style = window.getComputedStyle(discardElement);
                    
                    console.log(`📍 プレイヤー${i} 捨て牌エリア座標:`);
                    console.log(`  - 位置: x=${rect.left.toFixed(1)}, y=${rect.top.toFixed(1)}`);
                    console.log(`  - サイズ: width=${rect.width.toFixed(1)}, height=${rect.height.toFixed(1)}`);
                    console.log(`  - CSS: position=${style.position}, transform=${style.transform}`);
                    console.log(`  - 捨て牌数: ${gameState.players[i].hand.discards.length}枚`);
                    
                    // 捨て牌の配置方向をテスト
                    const discards = discardElement.children;
                    if (discards.length > 0) {
                        console.log(`  - 最初の牌位置: x=${discards[0].getBoundingClientRect().left.toFixed(1)}`);
                        if (discards.length > 1) {
                            console.log(`  - 最後の牌位置: x=${discards[discards.length-1].getBoundingClientRect().left.toFixed(1)}`);
                            console.log(`  - 配置方向: ${discards[0].getBoundingClientRect().left < discards[discards.length-1].getBoundingClientRect().left ? '左→右' : '右→左'}`);
                        }
                    }
                    
                    // 視覚的テスト用の一時的ハイライト
                    discardElement.style.border = '3px solid red';
                    setTimeout(() => {
                        discardElement.style.border = '';
                    }, 2000);
                }
            }
            
            // 捨て牌の向きと配置パターンをテスト
            testDiscardRotations();
            showNotification('捨て牌座標をコンソールに出力しました', 'info');
        }
        
        // 捨て牌の回転と配置テスト
        function testDiscardRotations() {
            console.log('🔄 捨て牌回転テスト:');
            
            for (let i = 0; i < 4; i++) {
                const playerName = ['プレイヤー1', 'CPU南', 'CPU西', 'CPU北'][i];
                const expectedRotation = [0, 0, 180, 0][i]; // 期待される回転角度
                const expectedDirection = ['左→右', '上→下', '右→左', '下→上'][i]; // 期待される配置方向
                
                console.log(`  ${playerName} (位置${i}):`);
                console.log(`    - 期待回転: ${expectedRotation}度`);
                console.log(`    - 期待配置: ${expectedDirection}`);
                
                const discardElement = document.getElementById(`discards${i}`);
                if (discardElement && discardElement.children.length > 0) {
                    const firstTile = discardElement.children[0];
                    const style = window.getComputedStyle(firstTile);
                    console.log(`    - 実際CSS: transform=${style.transform}`);
                }
            }
        }
        
        // 捨て牌エリアのクリック可能テスト
        function addDiscardClickTest() {
            for (let i = 0; i < 4; i++) {
                const discardElement = document.getElementById(`discards${i}`);
                if (discardElement) {
                    discardElement.addEventListener('click', function() {
                        console.log(`🖱️ プレイヤー${i}の捨て牌エリアがクリックされました`);
                        showNotification(`プレイヤー${i}の捨て牌エリア`, 'info');
                        
                        // 詳細な捨て牌情報を表示
                        showDiscardDetails(i);
                    });
                }
            }
        }
        
        // 指定プレイヤーの捨て牌詳細表示
        function showDiscardDetails(playerIndex) {
            if (!gameState || !gameState.players[playerIndex]) return;
            
            const player = gameState.players[playerIndex];
            const discards = player.hand.discards;
            
            console.log(`📋 プレイヤー${playerIndex} 捨て牌詳細:`);
            console.log(`  - 総数: ${discards.length}枚`);
            
            discards.forEach((tile, index) => {
                console.log(`  ${index + 1}. ${tile.displayName || tile.unicode} (ID: ${tile.id})`);
            });
            
            if (gameState.lastDiscard && gameState.lastDiscardPlayer === playerIndex) {
                console.log(`  ⭐ 最新捨て牌: ${gameState.lastDiscard.displayName || gameState.lastDiscard.unicode}`);
            }
        }
        
        // 捨て牌更新の監視（updateGameDisplayから呼び出し）
        function trackDiscardUpdates() {
            if (!gameState) return;
            
            const currentDiscardCounts = gameState.players.map(p => p.hand.discards.length);
            
            // 前回と比較して変更があった場合
            if (window.lastDiscardCounts) {
                for (let i = 0; i < 4; i++) {
                    if (currentDiscardCounts[i] !== window.lastDiscardCounts[i]) {
                        const change = currentDiscardCounts[i] - window.lastDiscardCounts[i];
                        // console.log(`🔄 プレイヤー${i} 捨て牌変更: ${window.lastDiscardCounts[i]}枚 → ${currentDiscardCounts[i]}枚 (${change > 0 ? '+' : ''}${change})`);
                        
                        if (change > 0 && gameState.players[i].hand.discards.length > 0) {
                            const latestDiscard = gameState.players[i].hand.discards[gameState.players[i].hand.discards.length - 1];
                            // console.log(`  新しい捨て牌: ${latestDiscard.displayName || latestDiscard.unicode}`);
                        }
                    }
                }
            }
            
            window.lastDiscardCounts = [...currentDiscardCounts];
        }

        // 役判定テスト機能
        function testYakuAnalysis() {
            console.log('🎰 役判定テスト開始');
            
            if (!gameState || !gameState.players) {
                showNotification('ゲーム状態が無効です', 'error');
                return;
            }
            
            // 各プレイヤーの手牌を分析
            gameState.players.forEach((player, index) => {
                console.log(`🎰 プレイヤー${index} (${player.name}) 手牌分析:`);
                console.log(`  手牌: ${player.hand.tiles.length}枚`);
                console.log(`  メルド: ${player.hand.melds.length}個`);
                console.log(`  リーチ: ${player.hand.riichi ? 'Yes' : 'No'}`);
                console.log(`  捨て牌: ${player.hand.discards.length}枚`);
                
                // 手牌の内容を表示
                if (index === 0) { // プレイヤー1の手牌は見える
                    console.log(`  手牌詳細: ${player.hand.tiles.map(t => t.displayName || t.unicode).join(' ')}`);
                    
                    // 和了形かチェック
                    testWinningHand(player.hand.tiles, player.hand.melds, index);
                    
                    // シャンテン数をテスト（フロントエンドでは簡易計算）
                    const shanten = calculateSimpleShanten(player.hand.tiles, player.hand.melds);
                    console.log(`  推定シャンテン数: ${shanten}`);
                    
                    // 待ち牌の可能性をテスト
                    if (shanten <= 1) {
                        testWaitingTiles(player.hand.tiles);
                    }
                } else {
                    console.log(`  手牌詳細: [非表示] ${player.hand.tiles.length}枚`);
                }
                
                // メルドの詳細
                if (player.hand.melds.length > 0) {
                    console.log(`  メルド詳細:`);
                    player.hand.melds.forEach((meld, meldIndex) => {
                        console.log(`    ${meldIndex + 1}. ${meld.type}: ${meld.tiles.map(t => t.displayName || t.unicode).join(' ')}`);
                    });
                }
                
                console.log(''); // 空行
            });
            
            showNotification('役判定テストを実行しました', 'info');
        }
        
        // 和了形テスト（簡易版）
        function testWinningHand(tiles, melds, playerIndex) {
            if (tiles.length + melds.length * 3 !== 14 && tiles.length + melds.length * 3 !== 13) {
                console.log(`  ⚠️ 牌数異常: ${tiles.length + melds.length * 3}枚`);
                return;
            }
            
            // 七対子チェック
            const isChiitoi = checkChiitoi(tiles);
            if (isChiitoi && tiles.length === 14) {
                console.log(`  🎉 七対子形: 和了可能`);
                simulateYaku(tiles, melds, playerIndex, '七対子');
                return;
            }
            
            // 国士無双チェック
            const isKokushi = checkKokushi(tiles);
            if (isKokushi && tiles.length === 14) {
                console.log(`  🎉 国士無双形: 役満！`);
                simulateYaku(tiles, melds, playerIndex, '国士無双');
                return;
            }
            
            // 標準形チェック（簡易）
            const isStandard = checkStandardForm(tiles, melds);
            if (isStandard) {
                console.log(`  🎉 標準形: 和了可能`);
                simulateYaku(tiles, melds, playerIndex, '標準形');
                return;
            }
            
            console.log(`  ❌ 和了形ではありません`);
        }
        
        // 役のシミュレーション
        function simulateYaku(tiles, melds, playerIndex, formType) {
            console.log(`  📊 ${formType}の役分析:`);
            
            const allTiles = [...tiles, ...melds.flatMap(m => m.tiles)];
            const isMenzen = melds.every(m => m.type === 'ankan' || m.isConcealed);
            
            // 基本役チェック
            const yakuList = [];
            
            // タンヤオ
            if (allTiles.every(t => !t.honor && t.rank >= 2 && t.rank <= 8)) {
                yakuList.push('タンヤオ(1翻)');
            }
            
            // リーチ
            if (gameState.players[playerIndex].hand.riichi && isMenzen) {
                yakuList.push('リーチ(1翻)');
            }
            
            // 役牌（簡易チェック）
            const honors = ['white', 'green', 'red', 'east', 'south', 'west', 'north'];
            honors.forEach(honor => {
                const count = allTiles.filter(t => t.honor === honor).length;
                if (count >= 3) {
                    const names = {
                        white: '白', green: '發', red: '中',
                        east: '東', south: '南', west: '西', north: '北'
                    };
                    yakuList.push(`${names[honor]}(1翻)`);
                }
            });
            
            // 特殊形の役
            if (formType === '七対子') {
                yakuList.push('七対子(2翻)');
            } else if (formType === '国士無双') {
                yakuList.push('国士無双(役満)');
            }
            
            if (yakuList.length > 0) {
                console.log(`    役: ${yakuList.join(', ')}`);
                const totalHan = yakuList.reduce((sum, yaku) => {
                    if (yaku.includes('役満')) return sum + 13;
                    const match = yaku.match(/(\d+)翻/);
                    return sum + (match ? parseInt(match[1]) : 0);
                }, 0);
                console.log(`    合計: ${totalHan >= 13 ? '役満' : totalHan + '翻'}`);
            } else {
                console.log(`    役: なし（役なし）`);
            }
        }
        
        // 簡易シャンテン計算
        function calculateSimpleShanten(tiles, melds) {
            if (tiles.length + melds.length * 3 === 14) return -1; // 和了形
            if (tiles.length + melds.length * 3 !== 13) return 8; // 異常
            
            // 超簡易計算（実際の計算は複雑）
            const tileCounts = {};
            tiles.forEach(tile => {
                const key = tile.honor || `${tile.suit}_${tile.rank}`;
                tileCounts[key] = (tileCounts[key] || 0) + 1;
            });
            
            let pairs = 0;
            let sets = 0;
            
            Object.values(tileCounts).forEach(count => {
                if (count >= 3) sets++;
                else if (count === 2) pairs++;
            });
            
            // 非常に簡易的な推定
            const currentSets = sets + melds.length;
            const neededSets = 4;
            const neededPairs = 1;
            
            return Math.max(0, (neededSets - currentSets) * 2 + Math.max(0, neededPairs - pairs));
        }
        
        // 待ち牌テスト（簡易版）
        function testWaitingTiles(tiles) {
            console.log(`  🎯 可能性のある待ち牌:`);
            
            // 超簡易的な待ち牌推定
            const suits = ['man', 'pin', 'sou'];
            const possibleWaits = [];
            
            suits.forEach(suit => {
                for (let rank = 1; rank <= 9; rank++) {
                    // この牌を加えて和了になるかチェック（超簡易）
                    const testTile = { suit, rank, unicode: '', displayName: `${suit}${rank}`, id: 0, isRed: false };
                    possibleWaits.push(`${suit}${rank}`);
                }
            });
            
            // 字牌
            ['東', '南', '西', '北', '白', '發', '中'].forEach(honor => {
                possibleWaits.push(honor);
            });
            
            console.log(`    推定待ち: ${possibleWaits.slice(0, 5).join(', ')}... (簡易推定)`);
        }
        
        // ヘルパー関数
        function checkChiitoi(tiles) {
            if (tiles.length !== 14) return false;
            const counts = {};
            tiles.forEach(tile => {
                const key = tile.honor || `${tile.suit}_${tile.rank}`;
                counts[key] = (counts[key] || 0) + 1;
            });
            
            const values = Object.values(counts);
            return values.length === 7 && values.every(count => count === 2);
        }
        
        function checkKokushi(tiles) {
            if (tiles.length !== 14) return false;
            // 簡易国士判定（実際はより複雑）
            const yaochuCount = tiles.filter(t => 
                t.honor || t.rank === 1 || t.rank === 9
            ).length;
            return yaochuCount >= 12;
        }
        
        function checkStandardForm(tiles, melds) {
            // 超簡易標準形判定
            const totalTiles = tiles.length + melds.length * 3;
            return totalTiles === 14 || totalTiles === 13;
        }

        // 通知表示
        function showNotification(message, type = 'success') {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.className = `notification ${type}`;
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        // キーボードショートカット
        document.addEventListener('keydown', function(e) {
            if (e.key === 'd' || e.key === 'D') drawTile();
            if (e.key === 's' || e.key === 'S') discardSelected();
            if (e.key === 'a' || e.key === 'A') executeAI();
            if (e.key === 'r' || e.key === 'R') requestGameState();
            if (e.key === 'n' || e.key === 'N') newGame();
            if (e.key === 'q' || e.key === 'Q') toggleDebug();
        });

        // Socket.IOによるリアルタイム通信を使用するため、定期ポーリングは不要
        // ただし、接続確認のために60秒ごとにpingを送信
        setInterval(() => {
            if (isConnected) {
                socket.emit('ping');
            }
        }, 60000);
    </script>
</body>
</html>