<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🀄 本格麻雀 v1.2.0</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700;900&display=swap" rel="stylesheet">
    <script src="/socket.io/socket.io.js"></script>
    <style>
        @keyframes tenpai-pulse {
            0% { 
                opacity: 1; 
                transform: scale(1); 
                box-shadow: 0 4px 8px rgba(0,0,0,0.4), 0 0 0 0 rgba(255, 107, 107, 0.7);
            }
            50% { 
                opacity: 0.9; 
                transform: scale(1.05); 
                box-shadow: 0 6px 12px rgba(0,0,0,0.5), 0 0 0 4px rgba(255, 107, 107, 0.3);
            }
            100% { 
                opacity: 1; 
                transform: scale(1); 
                box-shadow: 0 4px 8px rgba(0,0,0,0.4), 0 0 0 0 rgba(255, 107, 107, 0.7);
            }
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Sans JP', sans-serif;
            background: linear-gradient(135deg, #1a5f2f 0%, #0f4021 50%, #0a2d17 100%);
            color: #212529;
            height: 100vh;
            overflow: auto;
            transition: all 0.3s ease;
        }
        
        /* デフォルト: 1920×1080対応 */
        body {
            min-width: 1920px;
            min-height: 1080px;
        }
        
        /* 2560×1440対応 */
        @media (min-width: 2560px) and (min-height: 1440px) {
            body {
                min-width: 2560px;
                min-height: 1440px;
            }
        }

        /* ヘッダー */
        .game-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
            height: 60px;
        }

        .game-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: #ffc107;
        }

        .game-info {
            display: flex;
            align-items: center;
            gap: 20px;
            color: white;
            font-size: 0.9rem;
        }

        .game-controls {
            display: flex;
            gap: 10px;
        }

        /* レスポンシブメインゲームエリア */
        .mahjong-container {
            width: 1920px;
            height: 1080px;
            padding-top: 80px;
            display: flex;
            flex-direction: column;
            margin: 0 auto;
        }

        /* レスポンシブゲームボード（中央エリア） */
        .game-board {
            width: 1880px;
            height: 980px;
            background: linear-gradient(135deg, #2d5a3d 0%, #1a4c2c 100%);
            border-radius: 20px;
            margin: 20px;
            position: relative;
            border: 8px solid #8b4513;
            box-shadow: 0 0 0 4px #ffc107, 0 20px 40px rgba(0, 0, 0, 0.3);
        }
        
        /* 2K対応: 2560×1440 */
        @media (min-width: 2560px) and (min-height: 1440px) {
            .mahjong-container {
                width: 2560px;
                height: 1440px;
                transform: scale(1.333); /* 1920→2560の比率 */
                transform-origin: top center;
            }
            
            .game-board {
                width: 2520px;
                height: 1320px;
            }
        }

        /* 2K対応プレイヤー配置 */
        .player-area {
            position: absolute;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 15px;
            padding: 20px;
            border: 3px solid transparent;
            transition: all 0.3s ease;
            min-width: 280px;
        }

        .player-area.current {
            border-color: #ffc107;
            box-shadow: 0 0 30px rgba(255, 193, 7, 0.6);
        }

        /* レスポンシブ上側プレイヤー（対面） */
        .player-top {
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            width: 280px;
        }

        /* レスポンシブ右側プレイヤー */
        .player-right {
            right: 30px;
            top: 50%;
            transform: translateY(-50%);
            text-align: center;
            width: 240px;
        }

        /* レスポンシブ左側プレイヤー */
        .player-left {
            left: 30px;
            top: 50%;
            transform: translateY(-50%);
            text-align: center;
            width: 240px;
        }
        
        /* 2K対応: プレイヤーエリア */
        @media (min-width: 2560px) and (min-height: 1440px) {
            .player-top {
                top: 40px;
                width: 350px;
            }
            
            .player-left, .player-right {
                width: 300px;
            }
            
            .player-left {
                left: 40px;
            }
            
            .player-right {
                right: 40px;
            }
        }

        /* プレイヤー情報 */
        .player-info {
            color: white;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .player-name {
            font-weight: 600;
            margin-bottom: 2px;
        }

        .player-wind {
            background: linear-gradient(135deg, #ffc107, #fd7e14);
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.7rem;
            font-weight: 600;
            display: inline-block;
        }

        /* 手牌表示 */
        .hand-tiles {
            display: flex;
            gap: 2px;
            flex-wrap: nowrap;
        }

        /* 対戦相手の手牌（裏向き） */
        .opponent-tiles {
            display: flex;
            gap: 2px;
        }

        .opponent-tile {
            width: 20px;
            height: 28px;
            background: #4a5568;
            border: 1px solid #2d3748;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 10px;
        }

        /* 左右のプレイヤーは縦向き */
        .player-left .opponent-tiles, 
        .player-right .opponent-tiles {
            flex-direction: column;
        }

        .player-left .opponent-tile, 
        .player-right .opponent-tile {
            width: 28px;
            height: 20px;
        }

        /* 本格麻雀の河レイアウト */
        .mahjong-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 800px;
            height: 600px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .rivers-horizontal {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex: 1;
        }

        .river-area {
            display: grid;
            gap: 1px;
            padding: 4px;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 6px;
        }

        /* レスポンシブ上下の河（横向き6×3） */
        .river-top, .river-bottom {
            grid-template-columns: repeat(6, 1fr);
            grid-template-rows: repeat(3, 1fr);
            width: 230px; /* 小さな河牌に合わせて調整 */
            height: 130px; /* 小さな河牌に合わせて調整 */
            margin: 0 auto;
        }

        /* レスポンシブ左右の河（横向き6×3） */
        .river-left, .river-right {
            grid-template-columns: repeat(6, 1fr);
            grid-template-rows: repeat(3, 1fr);
            width: 230px; /* 小さな河牌に合わせて調整 */
            height: 130px; /* 小さな河牌に合わせて調整 */
            transform: rotate(90deg);
        }
        
        /* 2K対応: 河エリア */
        @media (min-width: 2560px) and (min-height: 1440px) {
            .river-top, .river-bottom {
                width: 280px; /* 2K用に調整 */
                height: 160px; /* 2K用に調整 */
            }
            
            .river-left, .river-right {
                width: 280px; /* 2K用に調整 */
                height: 160px; /* 2K用に調整 */
            }
        }

        /* 2K対応河の牌スタイル */
        .river-tile {
            background: #f8f9fa;
            border: 1px solid #dee2e6; /* ボーダーを細く */
            border-radius: 2px; /* 角丸を小さく */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            font-weight: normal;
            cursor: default;
            min-width: 36px; /* 文字サイズに合わせて調整 */
            min-height: 42px; /* 文字サイズに合わせて調整 */
            max-width: 36px;
            max-height: 42px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            font-family: 'Apple Color Emoji', 'Segoe UI Emoji', 'Noto Color Emoji', 'Segoe UI Symbol', monospace;
            line-height: 1;
            overflow: visible;
            padding: 0;
            margin: 0; /* マージンも0に */
        }

        .river-tile.red {
            color: #dc3545;
        }
        
        /* 鳴いた牌（チー・ポン・カンで呼ばれた牌）の表示 */
        .river-tile.called {
            background: #ffe6cc;
            border-color: #ff9800;
            border-width: 2px;
            box-shadow: 0 0 4px rgba(255, 152, 0, 0.5);
        }

        .river-tile.reach {
            transform: rotate(90deg);
            background: #ffe6e6;
            border-color: #ff9999;
        }

        /* 2K対応各プレイヤーの河牌方向 */
        .river-left .river-tile {
            /* 河エリアが90度回転されているので、牌は-75度回転（15度傾斜） */
            transform: rotate(-75deg);
            width: 50px;
            height: 40px;
            font-size: 14px;
        }
        
        .river-right .river-tile {
            /* 河エリアが90度回転されているので、牌は-45度回転（45度時計回り傾斜） */
            transform: rotate(-45deg);
            width: 50px;
            height: 40px;
            font-size: 14px;
        }

        .river-left .river-tile.reach {
            transform: rotate(15deg); /* リーチ牌は15度傾斜 */
        }
        
        .river-right .river-tile.reach {
            transform: rotate(45deg); /* リーチ牌は45度時計回り傾斜 */
        }

        .river-top .river-tile {
            /* 西は逆向き */
            transform: rotate(180deg);
        }

        .river-top .river-tile.reach {
            transform: rotate(90deg); /* リーチ牌は横倒し */
        }

        /* 中央情報エリア */
        .center-info {
            color: white;
            text-align: center;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 12px;
            padding: 15px;
            min-width: 120px;
        }

        .round-info {
            font-size: 1.1rem;
            font-weight: 600;
            color: #ffc107;
            margin-bottom: 8px;
        }

        .dora-info {
            background: rgba(255, 255, 255, 0.1);
            padding: 5px 10px;
            border-radius: 6px;
            font-size: 0.8rem;
            margin-bottom: 8px;
        }

        .remaining-tiles {
            font-size: 0.7rem;
            color: #ccc;
        }

        /* リーチ棒スタイル */
        .riichi-stick {
            background: linear-gradient(135deg, #ff6b6b, #ff5252);
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: bold;
            margin-top: 10px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(255, 107, 107, 0.3);
            border: 2px solid #fff;
        }

        @keyframes riichiPlace {
            0% {
                transform: translateY(-20px) scale(0.8);
                opacity: 0;
            }
            50% {
                transform: translateY(-5px) scale(1.1);
                opacity: 0.8;
            }
            100% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        /* 吹き出しスタイル */
        .speech-bubbles {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }

        .speech-bubble {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #333;
            border-radius: 20px;
            padding: 10px 15px;
            font-size: 1.1rem;
            font-weight: bold;
            color: #333;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            white-space: nowrap;
            animation: speechAppear 0.3s ease-out;
        }

        .speech-bubble::after {
            content: '';
            position: absolute;
            border: 8px solid transparent;
            border-top-color: rgba(255, 255, 255, 0.95);
        }

        /* プレイヤー位置別の吹き出し配置 */
        #speechBubble0 { /* 下（自分） */
            bottom: 200px;
            left: 50%;
            transform: translateX(-50%);
        }
        #speechBubble0::after {
            bottom: -16px;
            left: 50%;
            transform: translateX(-50%);
        }

        #speechBubble1 { /* 左 */
            left: 100px;
            top: 50%;
            transform: translateY(-50%);
        }
        #speechBubble1::after {
            left: -16px;
            top: 50%;
            transform: translateY(-50%) rotate(90deg);
        }

        #speechBubble2 { /* 上（対面） */
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
        }
        #speechBubble2::after {
            top: -16px;
            left: 50%;
            transform: translateX(-50%) rotate(180deg);
        }

        #speechBubble3 { /* 右 */
            right: 100px;
            top: 50%;
            transform: translateY(-50%);
        }
        #speechBubble3::after {
            right: -16px;
            top: 50%;
            transform: translateY(-50%) rotate(-90deg);
        }

        @keyframes speechAppear {
            0% {
                transform: scale(0) translateX(-50%);
                opacity: 0;
            }
            50% {
                transform: scale(1.1) translateX(-50%);
                opacity: 0.8;
            }
            100% {
                transform: scale(1) translateX(-50%);
                opacity: 1;
            }
        }

        /* 2K対応メルド表示エリア */
        .meld-area {
            display: flex;
            gap: 12px;
            margin-top: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .player-meld-area {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 12px;
            min-height: 80px;
            width: 100%;
        }

        /* プレイヤー別メルド配置 */
        .player-top .meld-area {
            position: absolute;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
        }

        .player-left .meld-area {
            position: absolute;
            right: -450px;
            top: 50%;
            transform: translateY(-50%);
            width: 400px;
        }

        .player-right .meld-area {
            position: absolute;
            left: -450px;
            top: 50%;
            transform: translateY(-50%);
            width: 400px;
        }

        .meld-group {
            display: flex;
            gap: 2px;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #007bff;
            border-radius: 8px;
            padding: 4px;
            margin-right: 8px;
            position: relative;
        }

        .meld-group.chi {
            border-color: #28a745;
        }

        .meld-group.pon {
            border-color: #ffc107;
        }

        .meld-group.kan {
            border-color: #dc3545;
        }

        .meld-tile {
            width: 50px;
            height: 65px;
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border: 2px solid #666;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 1.1rem;
            font-weight: bold;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            font-family: 'Noto Sans JP', serif;
            line-height: 0.9;
            white-space: pre-line;
            text-align: center;
        }

        .meld-tile.red {
            color: #dc3545;
        }

        .meld-tile.called {
            transform: rotate(90deg);
            background: linear-gradient(135deg, #fff3cd, #ffeaa7);
        }

        .meld-label {
            position: absolute;
            top: -8px;
            left: 4px;
            background: #007bff;
            color: white;
            font-size: 0.6rem;
            padding: 2px 4px;
            border-radius: 4px;
            font-weight: bold;
        }

        .meld-group.chi .meld-label {
            background: #28a745;
        }

        .meld-group.pon .meld-label {
            background: #ffc107;
            color: #000;
        }

        .meld-group.kan .meld-label {
            background: #dc3545;
        }

        /* 下部プレイヤーの河は逆順配置 */
        .river-bottom {
            direction: rtl;
        }

        .river-bottom .river-tile {
            direction: ltr;
        }
        
        /* 河の表示方向修正 */
        .river-bottom {
            direction: ltr; /* 左から右へ */
        }
        
        /* デバッグ用: 自分の河の配置確認 */
        .river-bottom .river-tile {
            position: relative;
        }
        
        .river-bottom .river-tile::before {
            content: attr(data-order);
            position: absolute;
            top: -10px;
            left: 0;
            font-size: 8px;
            color: red;
        }

        /* 2K対応プレイヤーエリア（下部） */
        .player-bottom-area {
            background: rgba(255, 255, 255, 0.95);
            margin: 0 40px 40px 40px;
            border-radius: 15px;
            padding: 25px;
            border: 4px solid #ffc107;
        }

        .player-hand-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .player-details {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .hand-count {
            font-size: 0.9rem;
            color: #6c757d;
        }

        /* プレイヤーの手牌 */
        .player-hand {
            display: flex;
            gap: 4px;
            justify-content: flex-start;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .tile {
            background: linear-gradient(145deg, #ffffff 0%, #f8f9fa 100%);
            border: 1px solid #dee2e6; /* ボーダーを細く */
            border-radius: 4px; /* 角丸を小さく */
            padding: 0;
            margin: 0; /* マージンも0に */
            font-size: 52px;
            font-weight: normal;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            width: 52px; /* 文字サイズに合わせて調整 */
            height: 60px; /* 文字サイズに合わせて調整 */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
            font-family: 'Apple Color Emoji', 'Segoe UI Emoji', 'Noto Color Emoji', 'Segoe UI Symbol', monospace;
            user-select: none;
            position: relative;
            overflow: visible;
            line-height: 1; /* ライン高さを1に */
            text-align: center;
        }

        .tile::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.6), transparent);
            transition: left 0.5s;
        }

        .tile:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.9);
            background: linear-gradient(145deg, #ffffff 0%, #e3f2fd 100%);
            border-color: #2196f3;
            z-index: 10;
        }

        .tile:hover::before {
            left: 100%;
        }

        .tile.selected {
            background: linear-gradient(145deg, #fff8e1 0%, #ffecb3 100%);
            border-color: #ff9800;
            transform: scale(1.1);
            box-shadow: 0 12px 20px rgba(255, 152, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.9);
            animation: selectedPulse 1.5s ease-in-out infinite;
            z-index: 15;
        }

        @keyframes selectedPulse {
            0%, 100% { box-shadow: 0 12px 20px rgba(255, 152, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.9); }
            50% { box-shadow: 0 12px 20px rgba(255, 152, 0, 0.6), inset 0 1px 0 rgba(255, 255, 255, 0.9); }
        }

        .tile.red {
            color: #d32f2f;
            font-weight: 800;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        
        /* 牌の色分け */
        .tile.man {
            color: #d32f2f; /* 萬子は赤 */
            font-weight: 700;
        }
        
        .tile.pin {
            color: #333333; /* 筒子は黒 */
            font-weight: 700;
        }
        
        .tile.sou {
            color: #2e7d32; /* 索子は緑 */
            font-weight: 700;
        }
        
        /* ツモ牌のスタイル */
        .tile.tsumo {
            margin-left: 8px; /* 他の牌との間隔 */
            box-shadow: 0 4px 12px rgba(33, 150, 243, 0.3);
            border-color: #2196f3;
        }

        /* プレイヤーの捨て牌 */
        .player-discards {
            border-top: 1px solid #dee2e6;
            padding-top: 10px;
        }

        .player-discards-title {
            font-size: 0.8rem;
            color: #6c757d;
            margin-bottom: 8px;
        }

        .player-discard-tiles {
            display: flex;
            gap: 3px;
            flex-wrap: wrap;
        }

        .player-discard-tiles .tile {
            width: 35px;
            height: 45px;
            font-size: 14px;
            font-weight: 600;
            cursor: default;
            background: #e9ecef;
            border-color: #ced4da;
            flex-direction: column;
            line-height: 0.8;
            white-space: pre-line;
            text-align: center;
        }

        .player-discard-tiles .tile:hover {
            transform: none;
            background: #e9ecef;
        }

        /* 各プレイヤーの個別捨牌エリア */
        .player-discard-area {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 2px;
            margin-top: 8px;
            padding: 6px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            min-height: 50px;
            max-width: 150px;
        }

        .player-top .player-discard-area {
            margin-top: 8px;
        }

        .player-left .player-discard-area,
        .player-right .player-discard-area {
            margin-top: 8px;
            max-width: 120px;
        }

        .player-discard-area .discard-tile {
            font-size: 9px;
            padding: 1px;
            min-width: 20px;
            height: 24px;
            cursor: default;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .player-discard-area .discard-tile:hover {
            transform: none;
            background: #f8f9fa;
        }

        .player-discard-area .discard-tile.red {
            color: #dc3545;
            font-weight: 800;
        }

        /* アクションボタン */
        .action-panel {
            position: fixed;
            bottom: 40px;
            left: 40px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            max-width: 500px;
            z-index: 50;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 0.9rem;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.3s, height 0.3s;
        }

        .btn:active::before {
            width: 300px;
            height: 300px;
        }

        .btn-primary { 
            background: linear-gradient(135deg, #007bff 0%, #0056b3 100%); 
            color: white; 
            box-shadow: 0 4px 12px rgba(0, 123, 255, 0.3);
        }
        .btn-danger { 
            background: linear-gradient(135deg, #dc3545 0%, #a71e2a 100%); 
            color: white; 
            box-shadow: 0 4px 12px rgba(220, 53, 69, 0.3);
        }
        .btn-warning { 
            background: linear-gradient(135deg, #ffc107 0%, #d39e00 100%); 
            color: #212529; 
            box-shadow: 0 4px 12px rgba(255, 193, 7, 0.3);
        }
        .btn-success { 
            background: linear-gradient(135deg, #198754 0%, #0f5132 100%); 
            color: white; 
            box-shadow: 0 4px 12px rgba(25, 135, 84, 0.3);
        }
        .btn-info { 
            background: linear-gradient(135deg, #0dcaf0 0%, #087990 100%); 
            color: #212529; 
            box-shadow: 0 4px 12px rgba(13, 202, 240, 0.3);
        }

        .btn:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }

        .btn:active {
            transform: translateY(0) scale(0.98);
            transition: all 0.1s;
        }

        /* 情報パネル */
        .info-panel {
            position: fixed;
            bottom: 200px;
            left: 40px;
            width: 280px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            z-index: 50;
            font-size: 1rem;
        }

        .game-status {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 10px;
            color: #212529;
        }

        .game-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
        }

        .stat-item {
            text-align: center;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 6px;
        }

        .stat-label {
            font-size: 0.7rem;
            color: #6c757d;
            margin-bottom: 3px;
        }

        .stat-value {
            font-size: 0.9rem;
            font-weight: 600;
            color: #212529;
        }

        /* 通知 */
        .notification {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%) translateY(-100px);
            padding: 16px 28px;
            border-radius: 12px;
            font-weight: 600;
            z-index: 1000;
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            min-width: 200px;
            text-align: center;
        }

        .notification.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
            animation: notificationSlideIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .notification.success {
            background: linear-gradient(135deg, rgba(209, 237, 255, 0.95) 0%, rgba(184, 230, 255, 0.95) 100%);
            color: #0c63e4;
            border-color: rgba(12, 99, 228, 0.3);
        }

        .notification.error {
            background: linear-gradient(135deg, rgba(248, 215, 218, 0.95) 0%, rgba(245, 183, 191, 0.95) 100%);
            color: #721c24;
            border-color: rgba(114, 28, 36, 0.3);
        }

        .notification.warning {
            background: linear-gradient(135deg, rgba(255, 243, 205, 0.95) 0%, rgba(255, 235, 156, 0.95) 100%);
            color: #856404;
            border-color: rgba(133, 100, 4, 0.3);
        }

        .notification.info {
            background: linear-gradient(135deg, rgba(209, 236, 241, 0.95) 0%, rgba(178, 222, 235, 0.95) 100%);
            color: #0c5460;
            border-color: rgba(12, 84, 96, 0.3);
        }

        @keyframes notificationSlideIn {
            from {
                transform: translateX(-50%) translateY(-100px) scale(0.8);
                opacity: 0;
            }
            to {
                transform: translateX(-50%) translateY(0) scale(1);
                opacity: 1;
            }
        }

        /* 特別なエフェクト */
        @keyframes winCelebration {
            0% { transform: scale(1) rotate(0deg); }
            25% { transform: scale(1.1) rotate(5deg); }
            50% { transform: scale(1.2) rotate(-5deg); }
            75% { transform: scale(1.1) rotate(3deg); }
            100% { transform: scale(1) rotate(0deg); }
        }

        @keyframes riichiGlow {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 0, 0, 0.5); }
            50% { box-shadow: 0 0 30px rgba(255, 0, 0, 0.8); }
        }

        @keyframes confetti {
            0% { transform: translateY(-100vh) rotate(0deg); }
            100% { transform: translateY(100vh) rotate(360deg); }
        }

        .win-celebration {
            animation: winCelebration 0.8s ease-in-out;
        }

        .riichi-glow {
            animation: riichiGlow 2s ease-in-out infinite;
        }

        .confetti-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #ff6b6b;
            animation: confetti 3s linear infinite;
        }

        .confetti:nth-child(2n) { background: #4ecdc4; }
        .confetti:nth-child(3n) { background: #45b7d1; }
        .confetti:nth-child(4n) { background: #96ceb4; }
        .confetti:nth-child(5n) { background: #feca57; }

        /* レスポンシブ */
        @media (max-width: 768px) {
            .game-board {
                margin: 10px;
            }
            
            .info-panel {
                position: relative;
                top: auto;
                right: auto;
                width: 100%;
                margin: 10px;
            }
            
            .action-panel {
                position: relative;
                bottom: auto;
                right: auto;
                max-width: none;
                margin: 10px;
                justify-content: center;
            }

            .player-bottom-area {
                margin: 0 10px 10px 10px;
            }
        }
    </style>
</head>
<body>
    <div class="mahjong-container">
        <!-- ヘッダー -->
        <header class="game-header">
            <a href="/title.html" class="game-title" style="text-decoration: none;">🀄 本格麻雀 v1.2.0</a>
            
            <div class="game-info">
                <div id="gameInfo">東場 1局</div>
                <div>残り牌: <span id="remainingTiles">69</span></div>
                <div>現在: <span id="currentPlayerName">あなた</span></div>
                <div id="doraInfo">ドラ: <span id="doraDisplay">?</span></div>
            </div>

            <div class="game-controls">
                <button class="btn btn-info" onclick="toggleDebug()">デバッグ</button>
                <button class="btn btn-secondary" onclick="checkUISync()" style="font-size: 0.8rem;">UI同期</button>
                <button class="btn btn-warning" onclick="forceClearMelds()" style="font-size: 0.8rem;">晒しクリア</button>
                <button id="cpuAutoBtn" class="btn btn-success" onclick="toggleCpuAuto()">CPU自動開始</button>
                <button id="playerAutoBtn" class="btn btn-secondary" onclick="togglePlayerAuto()">オートツモ切り</button>
                <button class="btn btn-warning" onclick="newGame()">新しいゲーム</button>
                <a href="/title.html" class="btn btn-info">タイトル</a>
            </div>
        </header>

        <!-- ゲームボード -->
        <div class="game-board">
            <!-- 上側プレイヤー（対面） -->
            <div class="player-area player-top" id="player2">
                <div class="player-info">
                    <div class="player-name">CPU西</div>
                    <div class="player-wind">西</div>
                    <div class="player-score">
                        <span id="player2Score">25000</span>点
                    </div>
                </div>
                <div class="opponent-tiles" id="hand2"></div>
                <div class="meld-area" id="melds2"></div>
            </div>

            <!-- 右側プレイヤー -->
            <div class="player-area player-right" id="player3">
                <div class="player-info">
                    <div class="player-name">CPU北</div>
                    <div class="player-wind">北</div>
                    <div class="player-score">
                        <span id="player3Score">25000</span>点
                    </div>
                </div>
                <div class="opponent-tiles" id="hand3"></div>
                <div class="meld-area" id="melds3"></div>
            </div>

            <!-- 左側プレイヤー -->
            <div class="player-area player-left" id="player1">
                <div class="player-info">
                    <div class="player-name">CPU南</div>
                    <div class="player-wind">南</div>
                    <div class="player-score">
                        <span id="player1Score">25000</span>点
                    </div>
                </div>
                <div class="opponent-tiles" id="hand1"></div>
                <div class="meld-area" id="melds1"></div>
            </div>

            <!-- 中央の河エリア（本格麻雀レイアウト） -->
            <div class="mahjong-center">
                <!-- 上側プレイヤーの河 -->
                <div class="river-area river-top" id="river2"></div>
                
                <!-- 左右の河と中央情報 -->
                <div class="rivers-horizontal">
                    <!-- 左側プレイヤーの河 -->
                    <div class="river-area river-left" id="river1"></div>
                    
                    <!-- 中央情報エリア -->
                    <div class="center-info">
                        <div class="round-info" id="roundInfo">東1局</div>
                        <div class="dora-info">
                            ドラ: <span id="doraIndicator">🀫</span>
                        </div>
                        <div class="remaining-tiles">
                            残り: <span id="remainingTilesDisplay">69</span>枚
                        </div>
                        <!-- リーチ棒 -->
                        <div class="riichi-stick" id="riichiStick" style="display: none;">
                            1000点棒
                        </div>
                    </div>
                    
                    <!-- 右側プレイヤーの河 -->
                    <div class="river-area river-right" id="river3"></div>
                </div>
                
                <!-- 下側プレイヤーの河 -->
                <div class="river-area river-bottom" id="river0"></div>
            </div>
        </div>

        <!-- 吹き出し表示エリア -->
        <div class="speech-bubbles">
            <div class="speech-bubble" id="speechBubble0" style="display: none;"></div>
            <div class="speech-bubble" id="speechBubble1" style="display: none;"></div>
            <div class="speech-bubble" id="speechBubble2" style="display: none;"></div>
            <div class="speech-bubble" id="speechBubble3" style="display: none;"></div>
        </div>

        <!-- プレイヤーエリア（下部） -->
        <div class="player-bottom-area" id="player0">
            <div class="player-hand-header">
                <div class="player-details">
                    <div class="player-name" id="playerName">あなた</div>
                    <div class="player-wind" id="playerWind">東</div>
                    <div style="color: #6c757d; font-size: 0.9rem;">
                        <span id="playerScore">25000</span>点
                    </div>
                </div>
                <div class="hand-count">
                    手牌: <span id="handCount">13</span>枚
                </div>
            </div>
            
            <div class="player-hand" id="hand0"></div>
            
            <!-- プレイヤー0のメルド表示エリア -->
            <div class="meld-area player-meld-area" id="melds0"></div>
            
        </div>

        <!-- 情報パネル -->
        <div class="info-panel">
            <div class="game-status" id="gameStatus">ゲーム開始</div>
            <div class="game-stats">
                <div class="stat-item">
                    <div class="stat-label">現在プレイヤー</div>
                    <div class="stat-value" id="currentPlayer">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">局数</div>
                    <div class="stat-value" id="round">1</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">本場</div>
                    <div class="stat-value" id="honba">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">残り牌</div>
                    <div class="stat-value" id="remainingTilesInfo">69</div>
                </div>
            </div>
            <button class="btn btn-success" onclick="requestGameState()" style="width: 100%;">
                状態を更新
            </button>
        </div>

        <!-- アクションパネル -->
        <div class="action-panel">
            <button class="btn btn-primary" onclick="drawTile()" id="drawBtn">ツモ</button>
            <button class="btn btn-danger" onclick="discardSelected()" id="discardBtn">打牌</button>
            <button class="btn" style="background: #ff6b6b; color: white;" onclick="callRiichi()" id="riichiBtn">リーチ</button>
            <button class="btn btn-warning" onclick="callChi()" id="chiBtn" style="display: inline-block;">チー</button>
            <button class="btn btn-warning" onclick="callPon()" id="ponBtn" style="display: inline-block;">ポン</button>
            <button class="btn btn-warning" onclick="callKan()" id="kanBtn" style="display: inline-block;">カン</button>
            <button class="btn btn-secondary" onclick="passMeld()" id="passBtn" style="display: none;">パス</button>
            <button class="btn" style="background: linear-gradient(45deg, #ff6b6b, #ee5a24); color: white;" onclick="callMeld()" id="meldBtn" style="display: none;">スマートメルド</button>
            <button class="btn btn-success" onclick="callTsumo()" id="tsumoBtn">ツモ</button>
            <button class="btn btn-success" onclick="callRon()" id="ronBtn">ロン</button>
            <button class="btn btn-info" onclick="executeAI()" id="aiBtn">AI実行</button>
        </div>
        
        <!-- デバッグパネル -->
        <div class="debug-panel" style="position: fixed; bottom: 160px; right: 20px; background: rgba(0,0,0,0.9); color: white; padding: 10px; border-radius: 8px; font-size: 0.75rem; z-index: 100; max-width: 180px;">
            <div style="font-weight: bold; margin-bottom: 8px;">🔧 デバッグ操作</div>
            <div style="display: grid; grid-template-columns: 1fr; gap: 6px;">
                <button class="btn" style="background: #6c757d; color: white; padding: 4px 8px; font-size: 0.7rem;" onclick="forceCPUTurn()">CPU強制実行</button>
                <button class="btn" style="background: #6c757d; color: white; padding: 4px 8px; font-size: 0.7rem;" onclick="showGameLog()">ログ表示</button>
                <button class="btn" style="background: #6c757d; color: white; padding: 4px 8px; font-size: 0.7rem;" onclick="toggleDebugMode()">デバッグ切替</button>
                <button class="btn" style="background: #6c757d; color: white; padding: 4px 8px; font-size: 0.7rem;" onclick="skipToNextPlayer()">次プレイヤー</button>
                <button class="btn" style="background: #6c757d; color: white; padding: 4px 8px; font-size: 0.7rem;" onclick="showDiscards()">捨て牌確認</button>
                <button class="btn" style="background: #17a2b8; color: white; padding: 4px 8px; font-size: 0.7rem;" onclick="testDiscardCoordinates()">座標テスト</button>
                <button class="btn" style="background: #28a745; color: white; padding: 4px 8px; font-size: 0.7rem;" onclick="testYakuAnalysis()">役判定テスト</button>
                <button class="btn" style="background: #17a2b8; color: white; padding: 4px 8px; font-size: 0.7rem;" onclick="testScoreCalculation()">点数計算テスト</button>
                <button class="btn" style="background: #dc3545; color: white; padding: 4px 8px; font-size: 0.7rem;" onclick="showErrorLogs()">エラーログ</button>
                <button class="btn" style="background: #6c757d; color: white; padding: 4px 8px; font-size: 0.7rem;" onclick="clearConsole()">コンソール消去</button>
            </div>
        </div>
    </div>

    <!-- 通知 -->
    <div class="notification" id="notification"></div>

    <!-- 音効制御パネル（位置修正：ヘッダーと重複回避） -->
    <div style="position: fixed; top: 70px; right: 10px; z-index: 1000; background: rgba(0,0,0,0.8); padding: 8px; border-radius: 6px; color: white;">
        <div style="display: flex; align-items: center; gap: 8px;">
            <button onclick="toggleSound()" id="soundToggle" class="btn" style="background: #28a745; color: white; border: none; padding: 4px 8px; border-radius: 4px; font-size: 0.8rem;">🔊</button>
            <input type="range" id="volumeSlider" min="0" max="100" value="70" onchange="setVolume(this.value)" style="width: 60px;">
        </div>
    </div>

    <script src="/js/SoundManager.js"></script>
    <script>
        let gameId = null;
        let selectedTile = null;
        let gameState = null;
        let debugMode = false;
        let lastDiscardedTile = null;
        let lastDiscardedPlayer = null;
        
        // 風設定（強化版麻雀ロジック用）
        let gameSettings = {
            gameWind: 'east',   // 場風
            playerWind: 'east', // 自風
            round: 1            // 局数
        };
        
        // 副露データ（強化版ロジック用）
        let melds = [];
        
        // 変数初期化
        let isConnected = false;
        let currentTenpaiStatus = { isTenpai: false, waitingTiles: [] };
        let myPlayerId = 0; // 自分のプレイヤーID（デフォルト0、サーバーから受信して更新）
        
        // デバッグ用: gameId状態を定期チェック
        setInterval(() => {
            console.log('🔍 [STATUS CHECK] gameId:', gameId, 'isConnected:', isConnected, 'roomId from URL:', roomId);
        }, 5000);
        
        // プレイヤーIDを視覚位置にマッピングする関数
        function getVisualPosition(actualPlayerId, myPlayerId) {
            // 自分のプレイヤーIDを基準に相対位置を計算
            // myPlayerIdは常に視覚位置0（下）になる
            const offset = myPlayerId;
            return (actualPlayerId - offset + 4) % 4;
        }
        
        // 視覚位置から実際のプレイヤーIDを取得する関数
        function getActualPlayerId(visualPosition, myPlayerId) {
            return (visualPosition + myPlayerId) % 4;
        }
        
        // URLパラメータから部屋情報を取得
        const urlParams = new URLSearchParams(window.location.search);
        const roomId = urlParams.get('roomId');
        const playerName = urlParams.get('playerName');
        const isOnlineGame = roomId && playerName;
        
        console.log('🔍 URL Parameters:', { roomId, playerName, isOnlineGame });
        
        // Socket.IO接続
        const socket = io();
        
        // Socket.IOイベントハンドリング
        socket.on('connect', () => {
            console.log('🔌 Socket.IO接続成功');
            isConnected = true;
            
            // オンライン麻雀の場合、既存の部屋に接続
            if (isOnlineGame) {
                console.log('🎮 オンライン麻雀: 既存部屋に接続中...', roomId);
                socket.gameId = roomId;
                gameId = roomId; // クライアント側のgameId変数も設定
                console.log('🔍 gameId set to:', gameId);
                socket.emit('joinRoom', {
                    roomId: roomId,
                    playerName: playerName
                });
            }
        });
        
        socket.on('disconnect', () => {
            console.log('🔌 Socket.IO切断');
            isConnected = false;
            
            if (isOnlineGame) {
                showNotification('サーバーとの接続が切断されました', 'error');
            }
        });
        
        // オンライン麻雀専用イベントハンドラー
        socket.on('roomJoined', (data) => {
            console.log('🏠 部屋接続成功:', data);
            showNotification('ゲームに参加しました', 'success');
            
            // サーバーからは { room: roomObject } の形式で送信される
            if (data.room && data.room.id) {
                gameId = data.room.id;
                console.log('🔍 gameId set from data.room.id:', gameId);
                
                // ゲーム状態も取得
                if (data.room.gameState) {
                    console.log('🎮 進行中のゲームに参加');
                    gameState = data.room.gameState;
                    updateGameDisplay();
                }
            } else if (data.roomId) {
                // 旧形式への対応
                gameId = data.roomId;
                console.log('🔍 gameId set from data.roomId:', gameId);
                
                if (data.gameState) {
                    gameState = data.gameState;
                    updateGameDisplay();
                }
            }
        });
        
        socket.on('joinError', (data) => {
            console.log('❌ 部屋接続エラー:', data);
            showNotification(`接続エラー: ${data.message}`, 'error');
            
            // 3秒後にロビーに戻る
            setTimeout(() => {
                window.location.href = '/lobby.html';
            }, 3000);
        });
        
        socket.on('gameUpdate', (newGameState) => {
            console.log('🔄 リアルタイムゲーム状態更新受信');
            
            // ツモタイミング追跡
            if (gameState && newGameState && gameState.players && newGameState.players) {
                const oldHandSize = gameState.players[myPlayerId]?.hand?.tiles?.length || 0;
                const newHandSize = newGameState.players[myPlayerId]?.hand?.tiles?.length || 0;
                const oldCurrentPlayer = gameState.currentPlayer;
                const newCurrentPlayer = newGameState.currentPlayer;
                
                console.log('🔍 Hand size change:', oldHandSize, '→', newHandSize);
                console.log('🔍 Current player change:', oldCurrentPlayer, '→', newCurrentPlayer);
                
                if (newHandSize > oldHandSize && newCurrentPlayer === myPlayerId) {
                    console.log('🎯 TSUMO DETECTED: I drew a tile');
                    console.log('🔍 My new tiles:', newGameState.players[myPlayerId].hand.tiles.map((t, i) => `${i}: ${t.suit}${t.rank} (id:${t.id})`));
                }
            }
            
            gameState = newGameState;
            updateGameDisplay();
        });
        
        socket.on('roomCreated', (data) => {
            console.log('🎮 ルーム作成成功:', data);
            gameId = data.room.id;
            console.log('🔍 gameId set from roomCreated:', gameId);
            showNotification('ゲームが作成されました！', 'success');
            
            // シングルプレイヤーゲームの場合、自動で準備完了にする
            setTimeout(() => {
                socket.emit('playerReady', {
                    roomId: gameId,
                    ready: true
                });
                console.log('🔄 自動準備完了を送信');
            }, 500);
        });
        
        let gameStartNotified = false;
        
        socket.on('gameState', (newGameState) => {
            console.log('🎮 ゲーム状態受信:', newGameState);
            
            // プレイヤーIDを設定（サーバーから送信された場合）
            if (newGameState.myPlayerId !== undefined) {
                myPlayerId = newGameState.myPlayerId;
                console.log(`👤 [MY PLAYER ID] 自分のプレイヤーID: ${myPlayerId} (${newGameState.playerName})`);
            }
            
            // ツモタイミング追跡（gameStateイベント）
            if (gameState && newGameState && gameState.players && newGameState.players) {
                const myCurrentHandSize = gameState.players[myPlayerId]?.hand?.tiles?.length || 0;
                const myNewHandSize = newGameState.players[myPlayerId]?.hand?.tiles?.length || 0;
                
                if (myNewHandSize > myCurrentHandSize) {
                    console.log('🎯 TSUMO DETECTED (gameState): I drew a tile');
                    console.log('🔍 My new tiles:', newGameState.players[myPlayerId].hand.tiles.map((t, i) => `${i}: ${t.suit}${t.rank} (id:${t.id})`));
                }
            }
            
            gameState = newGameState;
            updateGameDisplay();
            
            // テンパイ表示を更新
            updateTenpaiDisplay(newGameState);
            
            // 初回のみゲーム開始通知を表示
            if (!gameStartNotified && newGameState.phase === 'playing') {
                showNotification('ゲームが開始されました！', 'success');
                gameStartNotified = true;
            }
        });

        // メルド機会の通知を受信
        socket.on('meldOpportunities', (data) => {
            const timestamp = new Date().toLocaleTimeString('ja-JP', {
                hour: '2-digit',
                minute: '2-digit', 
                second: '2-digit',
                fractionalSecondDigits: 3
            });
            console.log(`[${timestamp}] 🀄 [CLIENT] ===== メルド機会受信開始 =====`);
            console.log(`[${timestamp}] 🀄 [CLIENT] データ全体:`, data);
            console.log(`[${timestamp}] 🀄 [CLIENT] 捨て牌: ${data.discardedTile?.displayName || data.discardedTile?.unicode}`);
            console.log(`[${timestamp}] 🀄 [CLIENT] 捨て牌プレイヤー: ${data.discardPlayerId}`);
            console.log(`[${timestamp}] 🀄 [CLIENT] オート停止: ${data.autoPaused}`);
            console.log(`[${timestamp}] 🀄 [CLIENT] 機会があるプレイヤー数: ${data.opportunities?.length || 0}`);
            data.opportunities?.forEach(opp => {
                const types = [];
                if (opp.chi) types.push('チー');
                if (opp.pon) types.push('ポン');
                if (opp.kan) types.push('カン');
                console.log(`[${timestamp}] 🀄 [CLIENT] プレイヤー${opp.playerId}(${opp.playerType}): ${types.join('・')}`);
            });
            
            // lastDiscardedTileを直接設定
            console.log(`🔧 DEBUG: data.discardedTile exists: ${!!data.discardedTile}`);
            console.log(`🔧 DEBUG: data.discardPlayerId: ${data.discardPlayerId}`);
            console.log(`🔧 DEBUG: data.discardPlayerId !== undefined: ${data.discardPlayerId !== undefined}`);
            
            if (data.discardedTile && data.discardPlayerId !== undefined) {
                lastDiscardedTile = data.discardedTile;
                lastDiscardedPlayer = data.discardPlayerId;
                console.log(`🔧 lastDiscardedTile set from meldOpportunities: ${lastDiscardedTile.displayName} by player ${lastDiscardedPlayer}`);
            } else {
                console.log(`🔧 Failed to set lastDiscardedTile - condition not met`);
            }
            
            console.log(`[${timestamp}] 🀄 [CLIENT] showMeldOpportunities関数を呼び出します`);
            showMeldOpportunities(data);
            console.log(`[${timestamp}] 🀄 [CLIENT] ===== メルド機会受信終了 =====`);
        });

        // 和了結果受信
        socket.on('winResult', (data) => {
            console.log('🎯 和了結果受信:', data);
            
            if (data.success) {
                // 詳細な和了表示を作成
                displayWinResult(data);
                
                // 勝利エフェクトを実行
                triggerWinCelebration(data);
                
                // 基本メッセージ
                showNotification(`${data.message}`, 'success');
                
                // ゲーム終了状態の表示
                setTimeout(() => {
                    showNotification('次局準備中...', 'info');
                }, 5000);
            } else {
                showNotification(`和了失敗: ${data.error}`, 'error');
            }
        });
        
        // 詳細な和了結果表示
        function displayWinResult(data) {
            // 既存の和了表示があれば削除
            const existingDisplay = document.querySelector('.win-result-modal');
            if (existingDisplay) {
                existingDisplay.remove();
            }
            
            const modal = document.createElement('div');
            modal.className = 'win-result-modal';
            modal.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(20, 20, 20, 0.95) 100%);
                border: 3px solid #ffc107;
                border-radius: 15px;
                padding: 30px;
                z-index: 10001;
                color: white;
                font-family: 'Noto Sans JP', sans-serif;
                max-width: 600px;
                width: 90%;
                box-shadow: 0 10px 30px rgba(0,0,0,0.7);
                backdrop-filter: blur(10px);
            `;
            
            let content = `
                <div style="text-align: center; margin-bottom: 20px;">
                    <h2 style="color: #ffc107; margin: 0 0 10px 0; font-size: 2rem;">
                        ${data.winType === 'tsumo' ? '🎊 ツモ！' : '🎯 ロン！'}
                    </h2>
                    <div style="font-size: 1.2rem; color: #fff;">
                        ${data.winnerName || 'プレイヤー'} の勝利！
                    </div>
                </div>
            `;
            
            // 役表示
            if (data.yaku && data.yaku.length > 0) {
                content += `
                    <div style="margin-bottom: 20px; padding: 15px; background: rgba(255,255,255,0.1); border-radius: 8px;">
                        <h3 style="color: #4CAF50; margin: 0 0 10px 0;">🎴 役</h3>
                        <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                `;
                
                data.yaku.forEach(yaku => {
                    const hanText = yaku.han >= 13 ? '役満' : `${yaku.han}翻`;
                    content += `
                        <span style="
                            background: linear-gradient(45deg, #2196F3, #1976D2);
                            padding: 6px 12px;
                            border-radius: 20px;
                            font-size: 0.9rem;
                            white-space: nowrap;
                        ">
                            ${yaku.name} (${hanText})
                        </span>
                    `;
                });
                
                content += `
                        </div>
                    </div>
                `;
            }
            
            // 点数表示
            if (data.score) {
                const score = data.score;
                content += `
                    <div style="margin-bottom: 20px; padding: 15px; background: rgba(255,193,7,0.2); border-radius: 8px;">
                        <h3 style="color: #ffc107; margin: 0 0 10px 0;">💰 得点</h3>
                `;
                
                if (score.isYakuman) {
                    content += `
                        <div style="font-size: 1.5rem; font-weight: bold; color: #ff4444;">
                            役満${score.yakumanCount > 1 ? score.yakumanCount + '倍' : ''}
                        </div>
                        <div style="font-size: 1.3rem; margin-top: 5px;">
                            ${score.total.toLocaleString()}点
                        </div>
                    `;
                } else {
                    content += `
                        <div style="font-size: 1.2rem;">
                            ${score.han}翻 ${score.fu}符
                        </div>
                        <div style="font-size: 1.4rem; font-weight: bold; margin-top: 5px;">
                            ${score.total.toLocaleString()}点
                        </div>
                    `;
                }
                
                // 支払い詳細
                if (score.payments) {
                    content += `
                        <div style="margin-top: 15px; font-size: 0.95rem; opacity: 0.9;">
                    `;
                    
                    if (score.isTsumo) {
                        content += `
                            <div>ツモ: 各プレイヤーから ${score.payments.each?.toLocaleString() || '---'}点</div>
                        `;
                    } else {
                        content += `
                            <div>ロン: ${score.payments.winner?.toLocaleString() || '---'}点</div>
                        `;
                    }
                    
                    content += `</div>`;
                }
                
                content += `</div>`;
            }
            
            // 和了者の手牌表示
            if (data.winnerHand) {
                content += `
                    <div style="margin-bottom: 20px; padding: 15px; background: rgba(76,175,80,0.2); border-radius: 8px;">
                        <h3 style="color: #4CAF50; margin: 0 0 10px 0;">🀄 ${data.winnerName}の手牌</h3>
                `;
                
                // メルド（鳴き）表示
                if (data.winnerHand.melds && data.winnerHand.melds.length > 0) {
                    content += `<div style="margin-bottom: 10px;">`;
                    content += `<strong>鳴き:</strong> `;
                    data.winnerHand.melds.forEach(meld => {
                        const meldTiles = meld.tiles.map(tile => tile.unicode || getTileDisplayName(tile) || '🀫').join('');
                        content += `[${meldTiles}] `;
                    });
                    content += `</div>`;
                }
                
                // 手牌表示
                content += `
                    <div>
                        <strong>手牌:</strong>
                        <div style="font-family: monospace; font-size: 1.1rem; margin-top: 5px;">
                            ${data.winnerHand.tiles.map(tile => tile.unicode || getTileDisplayName(tile) || '🀫').join(' ')}
                `;
                
                // ロンの場合は和了牌を表示
                if (data.winType === 'ron' && data.winnerHand.winningTile) {
                    content += ` + ${data.winnerHand.winningTile.unicode || getTileDisplayName(data.winnerHand.winningTile) || '🀫'}`;
                }
                
                content += `
                        </div>
                    </div>
                    </div>
                `;
            }
            
            // 閉じるボタン
            content += `
                <div style="text-align: center; margin-top: 20px;">
                    <button onclick="this.parentElement.parentElement.remove()" style="
                        background: linear-gradient(45deg, #4CAF50, #45a049);
                        color: white;
                        border: none;
                        padding: 12px 30px;
                        border-radius: 25px;
                        font-size: 1rem;
                        cursor: pointer;
                        transition: all 0.3s ease;
                    " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        OK
                    </button>
                </div>
            `;
            
            modal.innerHTML = content;
            document.body.appendChild(modal);
            
            // 10秒後に自動削除
            setTimeout(() => {
                if (document.body.contains(modal)) {
                    modal.remove();
                }
            }, 10000);
        }

        // リーチ宣言受信
        socket.on('riichiDeclared', (data) => {
            console.log('🔥 リーチ宣言受信:', data);
            
            if (data.success) {
                // リーチエフェクトを実行
                triggerRiichiEffect(data.playerId);
                
                showNotification(`${data.playerName}がリーチ！`, 'warning');
                
                // 供託情報表示
                if (data.kyotaku > 0) {
                    showNotification(`供託: ${data.kyotaku}本`, 'info');
                }
            }
        });

        // 新ラウンド開始受信
        socket.on('newRound', (data) => {
            console.log('🆕 新ラウンド開始:', data);
            
            showNotification(`${data.wind}${data.roundNumber}局 ${data.honba}本場開始`, 'info');
            
            // 配牌アニメーション（少し遅延させて実行）
            setTimeout(() => {
                animateTileDistribution();
            }, 500);
        });

        // ゲーム終了受信
        socket.on('gameEnd', (data) => {
            console.log('🎊 ゲーム終了:', data);
            
            // 三家和の場合の特別処理
            if (data.type === 'triple_ron') {
                let tripleRonText = '🔥 三家和（さんちゃほー）\n\n';
                tripleRonText += 'ロン和了者:\n';
                data.ronPlayers.forEach(player => {
                    tripleRonText += `・${player.name} (${player.score}点)\n`;
                });
                tripleRonText += `\n振り込み: ${data.discardPlayer.name} (${data.discardPlayer.score}点)`;
                
                if (data.kyotaku > 0) {
                    tripleRonText += `\n供託${data.kyotaku}本は次局に持ち越し`;
                }
                
                showNotification(tripleRonText, 'warning');
                
                // 三家和エフェクト
                setTimeout(() => {
                    flashBackground('#FF5722', 2000);
                    createFireworks();
                }, 1000);
                return;
            }
            
            // 通常の最終順位表示
            let rankingText = '🏆 最終結果 🏆\n';
            data.finalRanking.forEach(player => {
                rankingText += `${player.rank}位: ${player.name} (${player.score}点)\n`;
            });
            
            showNotification('ゲーム終了！', 'success');
            
            // 特別な終了エフェクト
            setTimeout(() => {
                flashBackground('#4CAF50', 2000);
                createConfetti();
            }, 1000);
        });

        // 流し満貫結果受信
        socket.on('nagashiMangan', (data) => {
            console.log('🌊 流し満貫:', data);
            
            let nagashiText = '🌊 流し満貫\n\n';
            nagashiText += '成立者:\n';
            data.nagashiPlayers.forEach(player => {
                nagashiText += `・${player.name} (${player.score}点)\n`;
                nagashiText += `  捨て牌: ${player.discards.join(' ')}\n`;
            });
            
            showNotification(nagashiText, 'success');
            
            // 流し満貫エフェクト
            setTimeout(() => {
                flashBackground('#4CAF50', 2000);
                createWaveEffect();
            }, 1000);
        });

        // 流局結果受信
        socket.on('drawResult', (data) => {
            console.log('🔄 流局結果:', data);
            
            // 詳細な流局結果表示
            displayDrawResult(data);
            
            // 流局エフェクト
            setTimeout(() => {
                flashBackground('#FF9800', 1500);
            }, 1000);
        });
        
        // 流局結果表示関数
        function displayDrawResult(data) {
            // 既存の表示があれば削除
            const existingDisplay = document.querySelector('.draw-result-modal');
            if (existingDisplay) {
                existingDisplay.remove();
            }
            
            const modal = document.createElement('div');
            modal.className = 'draw-result-modal';
            modal.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, rgba(40, 40, 40, 0.95) 0%, rgba(60, 60, 60, 0.95) 100%);
                border: 3px solid #FF9800;
                border-radius: 15px;
                padding: 30px;
                z-index: 10001;
                color: white;
                font-family: 'Noto Sans JP', sans-serif;
                max-width: 700px;
                width: 90%;
                max-height: 80vh;
                overflow-y: auto;
                box-shadow: 0 10px 30px rgba(0,0,0,0.7);
                backdrop-filter: blur(10px);
            `;
            
            let content = `
                <div style="text-align: center; margin-bottom: 20px;">
                    <h2 style="color: #FF9800; margin: 0 0 10px 0; font-size: 2rem;">
                        🔄 流局
                    </h2>
                </div>
            `;
            
            // テンパイ者の手牌公開
            const tenpaiPlayers = data.tenpaiResults.filter(result => result.isTenpai);
            if (tenpaiPlayers.length > 0) {
                content += `
                    <div style="margin-bottom: 20px; padding: 15px; background: rgba(76,175,80,0.2); border-radius: 8px;">
                        <h3 style="color: #4CAF50; margin: 0 0 15px 0;">🀄 テンパイ者の手牌</h3>
                `;
                
                tenpaiPlayers.forEach(player => {
                    if (player.revealedHand) {
                        content += `
                            <div style="margin-bottom: 15px; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 5px;">
                                <strong>${player.name}:</strong>
                        `;
                        
                        // メルド表示
                        if (player.revealedHand.melds && player.revealedHand.melds.length > 0) {
                            content += `<div style="margin: 5px 0;">鳴き: `;
                            player.revealedHand.melds.forEach(meld => {
                                const meldTiles = meld.tiles.map(tile => tile.unicode || getTileDisplayName(tile) || '🀫').join('');
                                content += `[${meldTiles}] `;
                            });
                            content += `</div>`;
                        }
                        
                        // 手牌表示
                        content += `
                            <div style="font-family: monospace; font-size: 1rem; margin: 5px 0;">
                                手牌: ${player.revealedHand.tiles.map(tile => tile.unicode || getTileDisplayName(tile) || '🀫').join(' ')}
                            </div>
                        `;
                        
                        // 待ち牌表示
                        if (player.revealedHand.waitingTiles && player.revealedHand.waitingTiles.length > 0) {
                            content += `
                                <div style="color: #ffc107; font-size: 0.9rem;">
                                    待ち: ${player.revealedHand.waitingTiles.map(tile => tile.unicode || getTileDisplayName(tile) || '🀫').join(' ')}
                                </div>
                            `;
                        }
                        
                        content += `</div>`;
                    }
                });
                
                content += `</div>`;
            }
            
            // テンパイ・ノーテン結果
            content += `
                <div style="margin-bottom: 20px; padding: 15px; background: rgba(255,255,255,0.1); border-radius: 8px;">
                    <h3 style="color: #ffc107; margin: 0 0 10px 0;">📊 結果</h3>
            `;
            
            data.tenpaiResults.forEach(result => {
                const status = result.isTenpai ? 'テンパイ' : 'ノーテン';
                const statusColor = result.isTenpai ? '#4CAF50' : '#f44336';
                content += `
                    <div style="margin: 5px 0;">
                        ${result.name}: <span style="color: ${statusColor}; font-weight: bold;">${status}</span>
                    </div>
                `;
            });
            
            // 点数移動
            if (data.pointMovement.some(m => m.points !== 0)) {
                content += `<div style="margin-top: 15px; font-size: 0.95rem;">`;
                content += `<strong>点数移動:</strong><br>`;
                data.pointMovement.forEach(movement => {
                    if (movement.points !== 0) {
                        const sign = movement.points > 0 ? '+' : '';
                        const color = movement.points > 0 ? '#4CAF50' : '#f44336';
                        content += `
                            <div style="margin: 3px 0;">
                                ${data.tenpaiResults[movement.playerId].name}: 
                                <span style="color: ${color}; font-weight: bold;">${sign}${movement.points}点</span>
                            </div>
                        `;
                    }
                });
                content += `</div>`;
            } else {
                content += `<div style="margin-top: 10px; opacity: 0.8;">点数移動なし</div>`;
            }
            
            content += `</div>`;
            
            // 閉じるボタン
            content += `
                <div style="text-align: center; margin-top: 20px;">
                    <button onclick="this.parentElement.parentElement.remove()" style="
                        background: linear-gradient(45deg, #FF9800, #f57c00);
                        color: white;
                        border: none;
                        padding: 12px 30px;
                        border-radius: 25px;
                        font-size: 1rem;
                        cursor: pointer;
                        transition: all 0.3s ease;
                    " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        OK
                    </button>
                </div>
            `;
            
            modal.innerHTML = content;
            document.body.appendChild(modal);
        }

        // 特殊流局結果受信
        socket.on('specialDrawResult', (data) => {
            console.log('🔄 特殊流局結果:', data);
            
            let drawText = `🔄 ${data.drawName}\n\n`;
            
            switch (data.drawType) {
                case 'four_winds':
                    drawText += '同じ風牌が4人連続で捨てられました。\n';
                    break;
                case 'nine_terminals':
                    drawText += '親の第一ツモで字牌・ターミナル牌が9種類以上です。\n';
                    break;
                case 'four_kans':
                    drawText += '4回のカンが発生しました。\n';
                    break;
            }
            
            drawText += '連荘となります。';
            
            showNotification(drawText, 'warning');
            
            // 特殊流局エフェクト
            setTimeout(() => {
                flashBackground('#9C27B0', 2000); // 紫色のフラッシュ
            }, 1000);
        });

        // メルド機会表示関数
        function showMeldOpportunities(data) {
            const { discardedTile, discardPlayerId, opportunities, autoPaused } = data;
            
            // 自分（プレイヤー0）の機会をチェック
            const myOpportunity = opportunities.find(opp => opp.playerId === 0);
            
            console.log('🀄 [DEBUG] showMeldOpportunities呼び出し');
            console.log('🀄 [DEBUG] myOpportunity:', myOpportunity);
            
            if (myOpportunity) {
                console.log('🀄 自分にメルド機会:', myOpportunity);
                console.log('🀄 [DEBUG] chi:', myOpportunity.chi, 'pon:', myOpportunity.pon, 'kan:', myOpportunity.kan);
                
                // 改善されたメルド選択UIを自動表示
                if (gameState && gameState.players && gameState.players[myPlayerId]) {
                    const myTiles = gameState.players[myPlayerId].hand.tiles;
                    const discarded = lastDiscardedTile || discardedTile;
                    
                    if (discarded && myTiles) {
                        // 全ての可能なメルドを自動検索して選択UIを表示
                        const chiCombinations = findChiCombinations(myTiles, discarded);
                        const ponTiles = findPonTiles(myTiles, discarded);
                        const kanTiles = findKanTiles(myTiles, discarded);
                        
                        const allOptions = [];
                        
                        // 実際に可能なメルドのみを追加
                        if (myOpportunity.chi && chiCombinations.length > 0) {
                            chiCombinations.forEach((combo, index) => {
                                allOptions.push({
                                    type: 'chi',
                                    displayName: `チー: ${combo.map(t => getTileDisplayName(t)).join('')}`,
                                    tiles: combo,
                                    discardedTile: discarded
                                });
                            });
                        }
                        
                        if (myOpportunity.pon && ponTiles.length >= 2) {
                            allOptions.push({
                                type: 'pon',
                                displayName: `ポン: ${getTileDisplayName(discarded)}${getTileDisplayName(discarded)}${getTileDisplayName(discarded)}`,
                                tiles: ponTiles,
                                discardedTile: discarded
                            });
                        }
                        
                        if (myOpportunity.kan && kanTiles.length >= 3) {
                            allOptions.push({
                                type: 'kan',
                                displayName: `カン: ${getTileDisplayName(discarded)}${getTileDisplayName(discarded)}${getTileDisplayName(discarded)}${getTileDisplayName(discarded)}`,
                                tiles: kanTiles,
                                discardedTile: discarded
                            });
                        }
                        
                        if (allOptions.length > 0) {
                            // 改善された選択UIを表示
                            showMeldSelectionUI(allOptions);
                        }
                    }
                }
                
                // パスボタンを表示
                const passBtn = document.getElementById('passBtn');
                if (passBtn) {
                    passBtn.style.display = 'inline-block';
                }
                
                // 従来のボタン表示も維持（バックアップ）
                const chiBtn = document.getElementById('chiBtn');
                const ponBtn = document.getElementById('ponBtn');
                const kanBtn = document.getElementById('kanBtn');
                
                if (chiBtn && myOpportunity.chi) {
                    chiBtn.style.display = 'inline-block';
                    chiBtn.style.visibility = 'visible';
                }
                if (ponBtn && myOpportunity.pon) {
                    ponBtn.style.display = 'inline-block';
                    ponBtn.style.visibility = 'visible';
                }
                if (kanBtn && myOpportunity.kan) {
                    kanBtn.style.display = 'inline-block';
                    kanBtn.style.visibility = 'visible';
                }
                
                // ロンボタンの表示制御（メルド機会時も和了優先）
                const ronBtn = document.getElementById('ronBtn');
                if (ronBtn && canCallRon()) {
                    ronBtn.style.display = 'inline-block';
                    ronBtn.style.visibility = 'visible';
                    console.log('🎯 ロンボタンを表示（メルド機会と同時）');
                }
                
                // アクションボタン全体を更新（ロンボタンも含めて）
                updateActionButtons();
                
                // 通知表示
                const meldTypes = [];
                if (myOpportunity.chi) meldTypes.push('チー');
                if (myOpportunity.pon) meldTypes.push('ポン');
                if (myOpportunity.kan) meldTypes.push('カン');
                
                // オート停止の通知
                if (autoPaused) {
                    showNotification(`${meldTypes.join('・')}が可能です！（オート機能を停止しました）`, 'warning');
                } else {
                    showNotification(`${meldTypes.join('・')}が可能です！`, 'info');
                }
                
                // 10秒後にボタンを非表示（オート停止時は長めに）
                setTimeout(() => {
                    hideMeldButtons();
                }, autoPaused ? 15000 : 8000);
            } else {
                hideMeldButtons();
            }
        }

        // メルドボタンを非表示にする関数（デバッグ用：無効化）
        function hideMeldButtons() {
            const chiBtn = document.getElementById('chiBtn');
            const ponBtn = document.getElementById('ponBtn');
            const kanBtn = document.getElementById('kanBtn');
            
            // デバッグ用：非表示にしない
            // if (chiBtn) chiBtn.style.display = 'none';
            // if (ponBtn) ponBtn.style.display = 'none';
            // if (kanBtn) kanBtn.style.display = 'none';
        }
        
        // 重複したroomJoinedハンドラーを削除
        
        socket.on('actionResult', (result) => {
            console.log('✅ アクション結果:', result);
            if (result.success) {
                showNotification(result.message, 'success');
            } else {
                showNotification(result.message, 'error');
            }
        });
        
        socket.on('error', (error) => {
            console.error('❌ Socket.IOエラー:', error);
            showNotification(error.message, 'error');
        });
        
        socket.on('roomError', (error) => {
            console.error('❌ ルームエラー:', error);
            showNotification(error.message, 'error');
        });

        // 音効制御関数
        function toggleSound() {
            const isMuted = soundManager.toggleMute();
            const button = document.getElementById('soundToggle');
            button.textContent = isMuted ? '🔇' : '🔊';
            button.style.background = isMuted ? '#dc3545' : '#28a745';
            showNotification(isMuted ? '音効をミュートしました' : '音効を有効にしました', 'info');
        }

        function setVolume(value) {
            soundManager.setVolume(value / 100);
            showNotification(`音量: ${value}%`, 'info');
        }

        // 初期化
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('🔍 DEBUG: DOM loaded, initializing...');
            console.log('🔍 DEBUG: Initial gameId:', gameId);
            console.log('🔍 DEBUG: URL roomId:', roomId);
            console.log('🔍 DEBUG: isOnlineGame:', isOnlineGame);
            
            // オンラインゲームの場合はgameIdを即座に設定
            if (isOnlineGame && roomId) {
                gameId = roomId;
                console.log('🔍 DEBUG: gameId set from URL roomId:', gameId);
            }
            
            hideMeldButtons(); // 初期状態でメルドボタンを非表示
            try {
                await soundManager.init();
                console.log('🔍 DEBUG: SoundManager initialized');
            } catch (error) {
                console.warn('🔍 DEBUG: SoundManager init failed:', error);
            }
            
            // 捨て牌テスト機能を初期化
            addDiscardClickTest();
            console.log('🔍 DEBUG: Discard click test initialized');
            
            // オンラインゲームでない場合のみnewGame()を呼ぶ
            if (!isOnlineGame) {
                newGame();
            }
            
            try {
                soundManager.playGameStart();
            } catch (error) {
                console.warn('🔍 DEBUG: playGameStart failed:', error);
            }
        });

        // 新しいゲーム作成
        function newGame() {
            if (!isConnected) {
                showNotification('サーバーに接続されていません', 'error');
                return;
            }
            
            // オンライン麻雀の場合は新ゲーム作成を無効化
            if (isOnlineGame) {
                showNotification('オンライン麻雀では新ゲーム作成できません', 'warning');
                return;
            }
            
            showNotification('新しいゲームを作成中...', 'info');
            
            // ゲーム状態をリセット
            resetGameState();
            
            // Socket.IOでルーム作成要求
            socket.emit('createRoom', {
                roomName: 'シングルプレイヤー戦',
                playerName: 'プレイヤー1'
            });
        }
        
        // ゲーム状態リセット関数
        function resetGameState() {
            // 強化版ロジック用の変数をリセット
            melds = [];
            gameSettings = {
                gameWind: 'east',
                playerWind: 'east',
                round: 1
            };
            
            // 選択状態をリセット
            selectedTile = null;
            lastDiscardedTile = null;
            lastDiscardedPlayer = null;
            gameStartNotified = false;
            currentTenpaiStatus = { isTenpai: false, waitingTiles: [] };
            
            // UI要素をクリア
            clearMeldDisplays();
            clearTenpaiDisplays();
            clearActionButtons();
            
            console.log('🔄 ゲーム状態がリセットされました');
        }
        
        // メルド表示をクリア
        function clearMeldDisplays() {
            for (let i = 0; i < 4; i++) {
                const meldArea = document.getElementById(`melds${i}`);
                if (meldArea) {
                    meldArea.innerHTML = '';
                }
            }
        }
        
        // テンパイ表示をクリア
        function clearTenpaiDisplays() {
            document.querySelectorAll('.tenpai-indicator').forEach(indicator => {
                indicator.remove();
            });
        }
        
        // アクションボタンをクリア
        function clearActionButtons() {
            const actionButtons = document.querySelector('.action-buttons');
            if (actionButtons) {
                actionButtons.style.display = 'none';
            }
            
            // メルド選択UIも非表示
            const meldSelection = document.querySelector('.meld-selection');
            if (meldSelection) {
                meldSelection.style.display = 'none';
            }
        }
        
        // 局変更時のリセット処理
        function resetRoundState() {
            console.log('🔄 局変更時のリセット処理を実行');
            
            // 強化版ロジック用の変数をリセット（一部のみ）
            melds = [];
            lastDiscardedTile = null;
            lastDiscardedPlayer = null;
            selectedTile = null;
            
            // UI要素をクリア
            clearMeldDisplays();
            clearTenpaiDisplays();
            clearActionButtons();
            clearRoundSpecificUI();
            
            // 風設定を更新（局に応じて）
            if (gameState && gameState.round) {
                gameSettings.round = gameState.round.roundNumber || 1;
                // 自風は通常東→南→西→北の順で変わる
                const windOrder = ['east', 'south', 'west', 'north'];
                gameSettings.playerWind = windOrder[(gameState.round.roundNumber - 1) % 4] || 'east';
            }
            
            console.log('🔄 局リセット完了 - 新しい風設定:', gameSettings);
        }
        
        // 局固有のUI要素をクリア
        function clearRoundSpecificUI() {
            // メルド選択モーダルを削除
            const existingModals = document.querySelectorAll('.meld-selection-modal');
            existingModals.forEach(modal => modal.remove());
            
            // 勝利表示を削除
            const winDisplays = document.querySelectorAll('.win-celebration, .win-display, .win-result-modal');
            winDisplays.forEach(display => display.remove());
            
            // リーチ棒表示をリセット
            const riichiStick = document.getElementById('riichiStick');
            if (riichiStick) {
                riichiStick.style.display = 'none';
            }
            
            // 紙吹雪やエフェクトをクリア
            const confettiContainers = document.querySelectorAll('.confetti-container');
            confettiContainers.forEach(container => container.remove());
            
            // 河（捨て牌エリア）をクリア
            clearDiscardAreas();
        }
        
        // 河エリアをクリア
        function clearDiscardAreas() {
            for (let i = 0; i < 4; i++) {
                const riverArea = document.getElementById(`river${i}`);
                if (riverArea) {
                    riverArea.innerHTML = '';
                }
            }
        }
        
        // UI同期チェック（デバッグ用）
        function checkUISync() {
            console.log('🔍 UI同期チェック実行');
            
            const report = {
                gameState: !!gameState,
                currentRound: currentRoundNumber,
                currentHonba: currentHonbaCount,
                melds: melds.length,
                selectedTile: !!selectedTile,
                lastDiscarded: !!lastDiscardedTile,
                tenpaiStatus: currentTenpaiStatus.isTenpai,
                visibleModals: document.querySelectorAll('.meld-selection-modal, .win-result-modal').length,
                visibleTenpaiIndicators: document.querySelectorAll('.tenpai-indicator').length,
                displayedMelds: Array.from({length: 4}, (_, i) => {
                    const meldElement = document.getElementById(`melds${i}`);
                    return meldElement ? meldElement.children.length : 0;
                })
            };
            
            console.log('📊 UI状態レポート:', report);
            
            // 異常がある場合の自動修正
            if (report.visibleModals > 1) {
                console.warn('⚠️ 複数のモーダルが表示されています。クリーンアップします。');
                clearRoundSpecificUI();
            }
            
            // メルド表示の強制チェック
            if (gameState && gameState.players) {
                let hasStaleDisplays = false;
                gameState.players.forEach((player, i) => {
                    const actualMelds = player.hand?.melds?.length || 0;
                    const displayedMelds = report.displayedMelds[i];
                    if (actualMelds === 0 && displayedMelds > 0) {
                        console.warn(`⚠️ プレイヤー${i}のメルド表示が古い状態です。クリア中...`);
                        const meldElement = document.getElementById(`melds${i}`);
                        if (meldElement) {
                            meldElement.innerHTML = '';
                        }
                        hasStaleDisplays = true;
                    }
                });
                
                if (hasStaleDisplays) {
                    console.log('🔄 古いメルド表示をクリアしました');
                }
            }
            
            return report;
        }
        
        // 強制メルドクリア（デバッグ用）
        function forceClearMelds() {
            console.log('🧹 強制メルドクリア実行');
            clearMeldDisplays();
            melds = [];
            console.log('✅ メルド表示とクライアント変数をクリアしました');
        }

        // 現在の局番号を追跡（新局検出用）
        let currentRoundNumber = 1;
        let currentHonbaCount = 0;

        // ゲーム状態更新
        function updateGameDisplay() {
            if (!gameState) {
                console.log('🔍 DEBUG: gameState is null or undefined');
                return;
            }

            // 新しい局の開始を検出
            const newRoundNumber = gameState.round?.roundNumber || 1;
            const newHonbaCount = gameState.round?.honbaCount || 0;
            
            // より確実な新局検出（残り牌数と手牌枚数もチェック）
            const isNewRound = (newRoundNumber !== currentRoundNumber || newHonbaCount !== currentHonbaCount) ||
                              (gameState.remainingTiles >= 65 && gameState.players?.some(p => p.hand?.tiles?.length === 13));
            
            if (newRoundNumber !== currentRoundNumber || newHonbaCount !== currentHonbaCount) {
                console.log(`🔄 新しい局を検出: ${currentRoundNumber}局→${newRoundNumber}局, ${currentHonbaCount}本場→${newHonbaCount}本場`);
                
                // 局変更時のリセット処理
                resetRoundState();
                
                currentRoundNumber = newRoundNumber;
                currentHonbaCount = newHonbaCount;
            }
            
            // ゲーム開始直後の初期化チェック（全プレイヤーのメルドが空の場合）
            if (gameState.remainingTiles >= 65 && gameState.players?.every(p => p.hand?.melds?.length === 0)) {
                console.log('🔄 ゲーム開始/新局を検出 - メルド表示をクリア');
                clearMeldDisplays();
            }

            // console.log('🔍 DEBUG: updateGameDisplay called');
            // console.log('🔍 DEBUG: gameState:', gameState);
            // console.log('🔍 DEBUG: gameState.players:', gameState.players);
            // console.log('🔍 DEBUG: gameState.currentPlayer:', gameState.currentPlayer);

            // 基本情報更新
            try {
                document.getElementById('currentPlayer').textContent = gameState.currentPlayer || '0';
                
                const currentPlayerName = gameState.players && gameState.players[gameState.currentPlayer] 
                    ? gameState.players[gameState.currentPlayer].name 
                    : 'Unknown';
                document.getElementById('currentPlayerName').textContent = currentPlayerName;
                console.log('🔍 DEBUG: currentPlayerName:', currentPlayerName);
                document.getElementById('remainingTiles').textContent = gameState.remainingTiles || '0';
                document.getElementById('remainingTilesInfo').textContent = gameState.remainingTiles || '0';
                
                if (gameState.round) {
                    document.getElementById('round').textContent = gameState.round.roundNumber || '1';
                    document.getElementById('honba').textContent = gameState.round.honbaCount || '0';
                    document.getElementById('roundInfo').textContent = `東${gameState.round.roundNumber || '1'}局 ${gameState.round.honbaCount || '0'}本場`;
                    document.getElementById('gameInfo').textContent = `東場 ${gameState.round.roundNumber || '1'}局`;
                }
                
                document.getElementById('doraIndicator').textContent = gameState.doraIndicators?.[0]?.unicode || '🀫';
                
                console.log('🔍 DEBUG: Basic info updated successfully');
            } catch (error) {
                console.error('🔍 DEBUG: Error updating basic info:', error);
            }

            // プレイヤー情報更新
            try {
                console.log('🔍 DEBUG: Starting player info update');
                if (!gameState.players || !Array.isArray(gameState.players)) {
                    console.error('🔍 DEBUG: gameState.players is not an array:', gameState.players);
                    return;
                }
                
                gameState.players.forEach((player, index) => {
                    console.log(`🔍 DEBUG: Processing player ${index}:`, player);
                    
                    // 視覚位置を計算
                    const visualPos = getVisualPosition(index, myPlayerId);
                    const playerElement = document.getElementById(`player${visualPos}`);
                    
                    console.log(`🔍 DEBUG: Player ${index} -> Visual position ${visualPos}`);
                    
                    if (!playerElement) {
                        console.warn(`🔍 DEBUG: Player element not found: player${visualPos}`);
                        return;
                    }

                // 現在のプレイヤーをハイライト
                if (index === gameState.currentPlayer) {
                    playerElement.classList.add('current');
                } else {
                    playerElement.classList.remove('current');
                }

                // プレイヤー情報更新
                const nameElement = playerElement.querySelector('.player-name');
                const windElement = playerElement.querySelector('.player-wind');
                
                if (nameElement) nameElement.textContent = player.name;
                if (windElement) windElement.textContent = player.wind;
                
                // リーチ表示の更新
                updateRiichiDisplay(playerElement, player, index);

                    // 手牌更新
                    const handElement = document.getElementById(`hand${visualPos}`);
                    console.log(`🔍 DEBUG: handElement for player ${index} (visual ${visualPos}):`, handElement);
                    console.log(`🔍 DEBUG: player.hand for player ${index}:`, player.hand);
                    console.log(`🔍 DEBUG: player.hand.tiles for player ${index}:`, player.hand?.tiles);
                    
                    if (handElement && player.hand && player.hand.tiles) {
                        handElement.innerHTML = '';
                        
                        if (index === myPlayerId) {
                            // 自分の手牌（詳細表示）
                            // 総牌数を計算
                            const totalTiles = player.hand.tiles.length + (player.hand.melds?.length || 0) * 3;
                            
                            console.log(`🔍 DEBUG: Updating my hand (player ${myPlayerId}) with ${player.hand.tiles.length} tiles`);
                            console.log(`🔍 DEBUG: Tile order:`, player.hand.tiles.map((t, i) => `${i}: ${t.suit}${t.rank || ''} (id:${t.id})`));
                            console.log(`🔍 DEBUG: Current player:`, gameState.currentPlayer, 'Total tiles:', totalTiles);
                            
                            // サーバー側で牌順を維持するため、そのまま表示
                            let displayTiles = [...player.hand.tiles];
                            
                            try {
                                displayTiles.forEach((tile, tileIndex) => {
                                    if (!tile) {
                                        console.warn('🔍 Skipping null/undefined tile at index', tileIndex);
                                        return;
                                    }
                                    
                                    const tileElement = document.createElement('div');
                                    tileElement.className = 'tile';
                                    if (tile.isRed) tileElement.classList.add('red');
                                    if (tile.suit) tileElement.classList.add(tile.suit); // 色分け用クラス追加
                                    
                                    // 最後の牌（14枚目）をツモ牌として扱う
                                    if (totalTiles === 14 && tileIndex === displayTiles.length - 1) {
                                        tileElement.classList.add('tsumo');
                                        console.log(`🔍 DEBUG: Tsumo tile detected at index ${tileIndex}`);
                                    }
                                    
                                    tileElement.textContent = getTileDisplayName(tile);
                                    
                                    // 元の配列でのインデックスを取得してselectTileに渡す
                                    const originalIndex = player.hand.tiles.findIndex(t => t && t.id === tile.id);
                                    tileElement.onclick = () => selectTile(visualPos, originalIndex >= 0 ? originalIndex : tileIndex, tile);
                                    handElement.appendChild(tileElement);
                                });
                                
                                console.log(`🔍 DEBUG: Successfully rendered ${displayTiles.length} tiles`);
                            } catch (error) {
                                console.error('🔍 Error rendering tiles:', error);
                                // フォールバック: 元の配列をそのまま表示
                                player.hand.tiles.forEach((tile, tileIndex) => {
                                    if (!tile) return;
                                    
                                    const tileElement = document.createElement('div');
                                    tileElement.className = 'tile';
                                    if (tile.isRed) tileElement.classList.add('red');
                                    if (tile.suit) tileElement.classList.add(tile.suit);
                                    
                                    tileElement.textContent = getTileDisplayName(tile);
                                    tileElement.onclick = () => selectTile(visualPos, tileIndex, tile);
                                    handElement.appendChild(tileElement);
                                });
                            }
                            
                            // プレイヤー詳細情報更新
                            document.getElementById('handCount').textContent = player.hand.tiles.length;
                            document.getElementById('playerName').textContent = player.name;
                            document.getElementById('playerScore').textContent = player.score;
                            document.getElementById('playerWind').textContent = player.wind;
                            console.log(`🔍 DEBUG: Player 0 hand updated successfully with ${player.hand.tiles.length} tiles`);
                        } else {
                            // 対戦相手の手牌（裏向き）
                            console.log(`🔍 DEBUG: Updating opponent ${index} hand with ${player.hand.tiles.length} hidden tiles`);
                            for (let i = 0; i < player.hand.tiles.length; i++) {
                                const tileElement = document.createElement('div');
                                tileElement.className = 'opponent-tile';
                                tileElement.textContent = '🀫';
                                handElement.appendChild(tileElement);
                            }
                            
                            // CPU点数更新
                            const scoreElement = document.getElementById(`player${visualPos}Score`);
                            if (scoreElement) {
                                scoreElement.textContent = player.score;
                            }
                        }
                    } else {
                        console.warn(`🔍 DEBUG: Cannot update hand for player ${index} - missing handElement or tiles`);
                    }
                });
                
                console.log('🔍 DEBUG: Player info update completed');
            } catch (error) {
                console.error('🔍 DEBUG: Error updating player info:', error);
            }

            // 各プレイヤーの河更新（本格麻雀仕様）
            if (gameState.players) {
                gameState.players.forEach((player, playerIndex) => {
                    const visualPos = getVisualPosition(playerIndex, myPlayerId);
                    const riverElement = document.getElementById(`river${visualPos}`);
                    if (riverElement && player.hand && player.hand.discards) {
                        riverElement.innerHTML = '';
                        
                        player.hand.discards.forEach((tile, discardIndex) => {
                            const tileElement = document.createElement('div');
                            tileElement.className = 'river-tile';
                            
                            // 赤牌処理
                            if (tile.isRed) tileElement.classList.add('red');
                            if (tile.suit) tileElement.classList.add(tile.suit); // 色分け用クラス追加
                            
                            // リーチ宣言牌は横向き
                            if (player.hand.riichi && player.hand.riichiTile && 
                                isSameTile(tile, player.hand.riichiTile)) {
                                tileElement.classList.add('reach');
                            }
                            
                            // 鳴いた牌（チー・ポン・カンで呼ばれた牌）の判定
                            if (isCalledTile(tile, playerIndex, discardIndex)) {
                                tileElement.classList.add('called');
                            }
                            
                            tileElement.textContent = getTileDisplayName(tile);
                            
                            // プレイヤー位置に応じた牌の回転
                            switch (visualPos) {
                                case 1: // CPU南（下家）：左に90度回転
                                    tileElement.style.transform = 'rotate(-90deg)';
                                    break;
                                case 3: // CPU北（対面）：左に90度回転
                                    tileElement.style.transform = 'rotate(-90deg)';
                                    break;
                                // case 0（自分）とcase 2（CPU西）はそのまま
                            }
                            
                            // 6×3グリッドの配置順序
                            const gridOrder = calculateRiverOrder(visualPos, discardIndex);
                            tileElement.style.order = gridOrder;
                            
                            // デバッグ用: order値を表示
                            if (visualPos === 0) {
                                tileElement.setAttribute('data-order', gridOrder);
                            }
                            
                            riverElement.appendChild(tileElement);
                        });
                    }
                });
            }

            // 最後の捨牌情報を更新（鳴き判定用）
            updateLastDiscardedTile();
            
            // ゲームステータス更新
            updateGameStatus();
            
            // メルド表示更新
            updateMeldDisplay();
            
            // テンパイ状態チェック
            updateTenpaiStatus();
        }

        // メルド表示更新
        function updateMeldDisplay() {
            if (!gameState || !gameState.players) return;
            
            gameState.players.forEach((player, playerIndex) => {
                const visualPos = getVisualPosition(playerIndex, myPlayerId);
                const meldElement = document.getElementById(`melds${visualPos}`);
                if (!meldElement) return;
                
                // プレイヤーにメルドデータがない場合は表示をクリア
                if (!player.hand || !player.hand.melds || player.hand.melds.length === 0) {
                    meldElement.innerHTML = '';
                    return;
                }
                
                meldElement.innerHTML = '';
                
                player.hand.melds.forEach((meld, meldIndex) => {
                    const meldGroup = document.createElement('div');
                    meldGroup.className = 'meld-group';
                    meldGroup.style.display = 'flex';
                    meldGroup.style.gap = '2px';
                    meldGroup.style.margin = '5px';
                    meldGroup.style.padding = '5px';
                    meldGroup.style.background = 'rgba(255, 255, 255, 0.9)';
                    meldGroup.style.border = '2px solid #007bff';
                    meldGroup.style.borderRadius = '8px';
                    
                    // メルドタイプラベル
                    const typeLabel = document.createElement('div');
                    typeLabel.style.fontSize = '10px';
                    typeLabel.style.color = '#007bff';
                    typeLabel.style.fontWeight = 'bold';
                    typeLabel.style.marginRight = '5px';
                    
                    switch (meld.type) {
                        case 'chi':
                            typeLabel.textContent = 'チー';
                            break;
                        case 'pon':
                            typeLabel.textContent = 'ポン';
                            break;
                        case 'kan':
                        case 'ankan':
                        case 'minkan':
                            typeLabel.textContent = 'カン';
                            break;
                    }
                    
                    meldGroup.appendChild(typeLabel);
                    
                    // メルドの牌を表示
                    meld.tiles.forEach((tile, tileIndex) => {
                        const tileElement = document.createElement('div');
                        tileElement.className = 'meld-tile';
                        tileElement.style.width = '20px';
                        tileElement.style.height = '28px';
                        tileElement.style.border = '1px solid #333';
                        tileElement.style.display = 'flex';
                        tileElement.style.alignItems = 'center';
                        tileElement.style.justifyContent = 'center';
                        tileElement.style.fontSize = '10px';
                        tileElement.style.background = 'white';
                        
                        // 暗槓の場合、端の牌は裏向き
                        if (meld.type === 'ankan' && (tileIndex === 0 || tileIndex === 3)) {
                            tileElement.textContent = '🀫';
                            tileElement.style.background = '#e9ecef';
                        } else {
                            tileElement.textContent = getTileDisplayName(tile);
                            if (tile.suit) tileElement.classList.add(tile.suit); // 色分け用クラス追加
                            if (tile.isRed) {
                                tileElement.style.color = '#dc3545';
                                tileElement.style.fontWeight = '800';
                            }
                        }
                        
                        meldGroup.appendChild(tileElement);
                    });
                    
                    meldElement.appendChild(meldGroup);
                });
            });
        }

        // 河の配置順序計算（本格麻雀仕様）
        function calculateRiverOrder(playerIndex, discardIndex) {
            // デバッグ用：固定位置でテスト
            if (discardIndex === 0) {
                // 1枚目の固定位置
                switch (playerIndex) {
                    case 0: return 0;  // 左上
                    case 1: return 8;  // 下の中央
                    case 2: return 15; // 右上  
                    case 3: return 3;  // 上の右
                }
            }
            
            // 2枚目以降は順番に
            const row = Math.floor(discardIndex / 6);
            const col = discardIndex % 6;
            return row * 6 + col;
        }
        
        // 牌が同じかチェック
        function isSameTile(tile1, tile2) {
            if (!tile1 || !tile2) return false;
            if (tile1.suit !== tile2.suit) return false;
            if (tile1.suit === 'ji') {
                return tile1.honor === tile2.honor;
            }
            return tile1.rank === tile2.rank;
        }
        
        // 鳴いた牌かどうかを判定
        function isCalledTile(tile, playerIndex, discardIndex) {
            if (!gameState || !gameState.gameLog) return false;
            
            // ゲームログから鳴きアクションを検索
            for (let i = 0; i < gameState.gameLog.length; i++) {
                const log = gameState.gameLog[i];
                
                // チー・ポン・カンアクションを探す
                if (log.type === 'meld' && log.calledTile) {
                    // 鳴いた牌と捨牌のタイルが一致するかチェック
                    if (isSameTile(tile, log.calledTile)) {
                        // 鳴いた元のプレイヤーと現在の捨牌位置が一致するかチェック
                        if (log.fromPlayer === playerIndex) {
                            return true;
                        }
                    }
                }
            }
            
            return false;
        }
        
        // 最後の捨牌情報を更新
        function updateLastDiscardedTile() {
            if (!gameState) return;
            
            console.log('🔧 updateLastDiscardedTile called');
            console.log('🔧 gameState.lastDiscard:', gameState.lastDiscard);
            console.log('🔧 gameState.lastDiscardPlayer:', gameState.lastDiscardPlayer);
            
            // gameStateから直接取得を試す
            if (gameState.lastDiscard && gameState.lastDiscardPlayer !== undefined && gameState.lastDiscardPlayer !== null) {
                lastDiscardedTile = gameState.lastDiscard;
                lastDiscardedPlayer = gameState.lastDiscardPlayer;
                console.log(`🔧 Last discard from gameState: ${lastDiscardedTile.displayName || lastDiscardedTile.suit + lastDiscardedTile.rank} by player ${lastDiscardedPlayer}`);
                console.log('🔧 lastDiscardedTile object:', lastDiscardedTile);
                return;
            }
            
            // デバッグ情報を追加
            // console.log(`🔧 [DEBUG] gameState.lastDiscard:`, gameState.lastDiscard);
            // console.log(`🔧 [DEBUG] gameState.lastDiscardPlayer:`, gameState.lastDiscardPlayer);
            
            // フォールバック：ゲームログを逆順で検索して最後の捨牌を見つける
            if (gameState.gameLog) {
                for (let i = gameState.gameLog.length - 1; i >= 0; i--) {
                    const log = gameState.gameLog[i];
                    if (log.type === 'discard' && log.data && log.data.tile) {
                        lastDiscardedTile = log.data.tile;
                        lastDiscardedPlayer = parseInt(log.playerId.replace('player_', ''));
                        console.log(`🔧 Last discard from log: ${log.data.tile.displayName} by player ${lastDiscardedPlayer}`);
                        return;
                    }
                }
            }
            
            // 捨牌が見つからない場合はリセット
            lastDiscardedTile = null;
            lastDiscardedPlayer = null;
            // console.log(`🔧 No last discard found, reset to null`);
        }

        // ゲームステータス更新
        function updateGameStatus() {
            const statusElement = document.getElementById('gameStatus');
            if (!gameState || !statusElement) return;

            const currentPlayerName = gameState.players[gameState.currentPlayer]?.name;
            const playerHand = gameState.players[myPlayerId].hand.tiles;
            const handCount = playerHand ? playerHand.length : 0;
            const isMyTurn = gameState.currentPlayer === myPlayerId;
            
            let statusText = `${currentPlayerName}のターン`;
            if (isMyTurn) {
                if (handCount === 13) {
                    statusText = 'ツモしてください';
                } else if (handCount === 14) {
                    statusText = '打牌してください';
                }
            }
            
            statusElement.textContent = statusText;
            statusElement.style.color = isMyTurn ? '#28a745' : '#6c757d';
            
            // ドラ表示の更新
            updateDoraDisplay();
            
            // アクションボタンの表示制御
            updateActionButtons();
        }
        
        function updateDoraDisplay() {
            const doraElement = document.getElementById('doraDisplay');
            if (!gameState || !doraElement) return;
            
            let doraText = '?';
            if (gameState.doraIndicators && gameState.doraIndicators.length > 0) {
                // 表示されているドラ表示牌を表示
                const doraIndicators = gameState.doraIndicators.map(tile => 
                    tile.displayName || tile.unicode || '?'
                ).join(' ');
                doraText = doraIndicators;
            } else if (gameState.dora) {
                // 旧形式のドラ表示
                doraText = gameState.dora.displayName || gameState.dora.unicode || '?';
            }
            
            doraElement.textContent = doraText;
        }
        
        // アクションボタンの表示制御
        function updateActionButtons() {
            if (!gameState) return;
            
            const isMyTurn = gameState.currentPlayer === myPlayerId;
            const player = gameState.players?.[myPlayerId];
            const handTiles = player?.hand?.tiles?.length || 0;
            const meldCount = player?.hand?.melds?.length || 0;
            const totalTiles = handTiles + (meldCount * 3);
            
            console.log('🔍 updateActionButtons DEBUG:', {
                handTiles,
                meldCount,
                totalTiles,
                isMyTurn
            });
            
            // メルド機会があるかチェック（lastDiscardedTileが設定されている場合）
            const hasMeldOpportunity = lastDiscardedTile && lastDiscardedTile.playerId !== 0;
            
            // 基本ボタン制御
            const drawBtn = document.getElementById('drawBtn');
            const discardBtn = document.getElementById('discardBtn');
            const riichiBtn = document.getElementById('riichiBtn');
            const tsumoBtn = document.getElementById('tsumoBtn');
            
            if (drawBtn) drawBtn.style.display = (isMyTurn && totalTiles === 13) ? 'inline-block' : 'none';
            if (discardBtn) discardBtn.style.display = (isMyTurn && totalTiles === 14) ? 'inline-block' : 'none';
            if (riichiBtn) riichiBtn.style.display = (isMyTurn && totalTiles === 14 && canCallRiichi()) ? 'inline-block' : 'none';
            if (tsumoBtn) tsumoBtn.style.display = (isMyTurn && totalTiles === 14 && canCallTsumo()) ? 'inline-block' : 'none';
            
            // メルドボタンは相手のターンでも表示可能
            const chiBtn = document.getElementById('chiBtn');
            const ponBtn = document.getElementById('ponBtn');
            const kanBtn = document.getElementById('kanBtn');
            const ronBtn = document.getElementById('ronBtn');
            
            // メルドボタンの条件表示（メルド機会がある場合は既に表示されているので保持）
            // メルド機会がない場合のみ非表示にする
            if (chiBtn && !hasMeldOpportunity) chiBtn.style.display = 'none';  
            if (ponBtn && !hasMeldOpportunity) ponBtn.style.display = 'none';  
            
            // カンボタンは加槓・暗槓可能な場合も表示
            const canKakan = isMyTurn && canCallKakan();
            const canAnkan = isMyTurn && canCallAnkan();
            const canAnyKan = canKakan || canAnkan;
            
            if (kanBtn && !hasMeldOpportunity && !canAnyKan) kanBtn.style.display = 'none';
            if (kanBtn && canAnyKan) kanBtn.style.display = 'inline-block';
            const canRon = canCallRon();
            console.log('🔍 ロンボタン制御:', {
                isMyTurn: isMyTurn,
                canRon: canRon,
                lastDiscardedTile: lastDiscardedTile,
                shouldShowRon: !isMyTurn && canRon
            });
            if (ronBtn) ronBtn.style.display = (!isMyTurn && canRon) ? 'inline-block' : 'none';
            
            // 捨て牌更新を追跡
            trackDiscardUpdates();
        }
        
        // アクション可能性チェック関数
        function canCallRiichi() {
            if (!gameState || !gameState.players[myPlayerId]) return false;
            const player = gameState.players[myPlayerId];
            return !player.hand.riichi && player.score >= 1000; // 既にリーチしてない、1000点以上ある
        }
        
        // 加槓可能かチェック
        function canCallKakan() {
            if (!gameState || !gameState.players[0]) return false;
            
            const player = gameState.players[0];
            const myTiles = player.hand.tiles || [];
            const myMelds = player.hand.melds || [];
            
            // ポンがあるかチェック
            for (const meld of myMelds) {
                if (meld.type === 'pon') {
                    const meldTile = meld.tiles[0];
                    // 手牌に同じ牌があるかチェック
                    for (const handTile of myTiles) {
                        if (isSameTile(handTile, meldTile)) {
                            return true;
                        }
                    }
                }
            }
            
            return false;
        }
        
        // 暗槓可能かチェック
        function canCallAnkan() {
            if (!gameState || !gameState.players[0]) return false;
            
            const player = gameState.players[0];
            const myTiles = player.hand.tiles || [];
            
            // 手牌で4枚同じ牌があるかチェック
            const tileCounts = {};
            for (const tile of myTiles) {
                const key = `${tile.suit}_${tile.rank}_${tile.honor}`;
                if (!tileCounts[key]) tileCounts[key] = [];
                tileCounts[key].push(tile);
            }
            
            // 4枚揃っている牌があるかチェック
            for (const [key, tiles] of Object.entries(tileCounts)) {
                if (tiles.length >= 4) {
                    console.log('🔍 暗槓可能:', key, tiles);
                    return true;
                }
            }
            
            return false;
        }
        
        function canCallTsumo() {
            if (!gameState || !gameState.players[0]) return false;
            
            const player = gameState.players[0];
            const handTiles = player.hand.tiles.length;
            const meldCount = player.hand.melds ? player.hand.melds.length : 0;
            const totalTiles = handTiles + (meldCount * 3);
            
            console.log('🔍 canCallTsumo DEBUG:', {
                handTiles,
                meldCount,
                totalTiles,
                currentPlayer: gameState.currentPlayer
            });
            
            // 総牌数が14枚でないとツモできない
            if (totalTiles !== 14) return false;
            
            // 自分のターンでないとツモできない
            if (gameState.currentPlayer !== 0) return false;
            
            // 実際の和了形チェック
            const canWin = checkClientWinning(player.hand.tiles, player.hand.melds);
            console.log('🔍 canCallTsumo 和了チェック:', {
                tiles: player.hand.tiles,
                melds: player.hand.melds,
                canWin: canWin
            });
            return canWin;
        }

        // テンパイ判定（改善版：サーバー情報優先）
        function checkClientTenpai() {
            if (!gameState || !gameState.players[0]) {
                return { isTenpai: false, waitingTiles: [] };
            }
            
            const player = gameState.players[0];
            
            // サーバーからのテンパイ情報がある場合はそれを優先
            if (player.tenpaiInfo) {
                return {
                    isTenpai: player.tenpaiInfo.isTenpai,
                    waitingTiles: player.tenpaiInfo.waitingTiles || [],
                    waitType: player.tenpaiInfo.waitType,
                    isFuriten: player.tenpaiInfo.isFuriten
                };
            }
            
            // サーバー情報がない場合の簡易判定
            const handTiles = player.hand.tiles.length;
            const meldCount = player.hand.melds ? player.hand.melds.length : 0;
            const totalTiles = handTiles + (meldCount * 3);
            
            console.log('🔍 checkClientTenpai DEBUG:', {
                handTiles,
                meldCount,
                totalTiles,
                actualTiles: player.hand.tiles,
                actualMelds: player.hand.melds
            });
            
            // 13枚の場合のみテンパイチェック
            if (totalTiles !== 13) {
                return { isTenpai: false, waitingTiles: [] };
            }
            
            // より正確なテンパイ判定（強化版ロジックを使用）
            try {
                const handForAnalysis = convertTilesToAdvancedFormat(player.hand.tiles);
                const meldsForAnalysis = convertMeldsToAdvancedFormat(player.hand.melds || []);
                
                // 各牌を追加してみて和了形になるかチェック
                const allTileTypes = generateAllTileTypes();
                const waitingTiles = [];
                
                for (const testTile of allTileTypes) {
                    const testHand = [...handForAnalysis, testTile];
                    if (isCompleteHand(testHand, meldsForAnalysis)) {
                        // 役があるかチェック
                        const yaku = calculateAdvancedYaku(testHand, meldsForAnalysis);
                        
                        console.log('🔍 テンパイ役判定:', {
                            testTile: testTile,
                            hand: testHand,
                            melds: meldsForAnalysis,
                            yaku: yaku
                        });
                        
                        const waitingTileInfo = {
                            suit: testTile.suit,
                            rank: testTile.rank,
                            honor: testTile.type || null,
                            displayName: getTileDisplayName(testTile),
                            hasYaku: yaku.length > 0,
                            yaku: yaku
                        };
                        
                        // 役がある場合、または役なしでも和了形の場合は追加
                        if (yaku.length > 0 || isCompleteHand(testHand, meldsForAnalysis)) {
                            waitingTiles.push(waitingTileInfo);
                        }
                    }
                }
                
                return {
                    isTenpai: waitingTiles.length > 0,
                    waitingTiles: waitingTiles
                };
                
            } catch (error) {
                console.warn('テンパイ判定エラー:', error);
                return { isTenpai: false, waitingTiles: [] };
            }
        }
        
        // 全牌種類生成
        function generateAllTileTypes() {
            const tiles = [];
            
            // 数牌
            ['man', 'pin', 'sou'].forEach(suit => {
                for (let rank = 1; rank <= 9; rank++) {
                    tiles.push({ suit, rank });
                }
            });
            
            // 字牌
            ['east', 'south', 'west', 'north', 'haku', 'hatsu', 'chun'].forEach(type => {
                tiles.push({ suit: 'honors', type });
            });
            
            return tiles;
        }
        
        // より詳細な基本形和了チェック
        function checkBasicWinForm(hand, melds = []) {
            if (!hand || hand.length === 0) return false;
            
            // 手牌を数牌と字牌に分ける
            const numberTiles = {};
            const honorTiles = {};
            
            for (const tile of hand) {
                if (tile.suit && (tile.suit === 'man' || tile.suit === 'pin' || tile.suit === 'sou')) {
                    if (!numberTiles[tile.suit]) numberTiles[tile.suit] = {};
                    const rank = tile.rank || tile.number;
                    numberTiles[tile.suit][rank] = (numberTiles[tile.suit][rank] || 0) + 1;
                } else {
                    const key = tile.honor || tile.type || `${tile.suit}_${tile.rank}`;
                    honorTiles[key] = (honorTiles[key] || 0) + 1;
                }
            }
            
            // 面子と雀頭の組み合わせを再帰的にチェック
            const requiredMentsus = 4 - melds.length;
            return checkMentsuCombination(numberTiles, honorTiles, requiredMentsus, 0, false);
        }
        
        // 面子組み合わせの再帰チェック
        function checkMentsuCombination(numberTiles, honorTiles, requiredMentsus, foundMentsus, hasJantou) {
            // 必要な面子数に達した場合
            if (foundMentsus >= requiredMentsus) {
                // 雀頭があるかチェック
                if (hasJantou) {
                    // 残り牌がないかチェック
                    const remainingTiles = countRemainingTiles(numberTiles, honorTiles);
                    return remainingTiles === 0;
                } else {
                    // 雀頭を作れるかチェック
                    const remainingTiles = countRemainingTiles(numberTiles, honorTiles);
                    return remainingTiles === 2 && canMakeJantou(numberTiles, honorTiles);
                }
            }
            
            // 字牌の刻子をチェック
            for (const [type, count] of Object.entries(honorTiles)) {
                if (count >= 3) {
                    honorTiles[type] -= 3;
                    if (checkMentsuCombination(numberTiles, honorTiles, requiredMentsus, foundMentsus + 1, hasJantou)) {
                        honorTiles[type] += 3;
                        return true;
                    }
                    honorTiles[type] += 3;
                }
            }
            
            // 数牌の面子をチェック
            for (const suit of ['man', 'pin', 'sou']) {
                if (numberTiles[suit]) {
                    // 刻子チェック
                    for (let rank = 1; rank <= 9; rank++) {
                        if ((numberTiles[suit][rank] || 0) >= 3) {
                            numberTiles[suit][rank] -= 3;
                            if (checkMentsuCombination(numberTiles, honorTiles, requiredMentsus, foundMentsus + 1, hasJantou)) {
                                numberTiles[suit][rank] += 3;
                                return true;
                            }
                            numberTiles[suit][rank] += 3;
                        }
                    }
                    
                    // 順子チェック
                    for (let rank = 1; rank <= 7; rank++) {
                        if ((numberTiles[suit][rank] || 0) >= 1 && 
                            (numberTiles[suit][rank + 1] || 0) >= 1 && 
                            (numberTiles[suit][rank + 2] || 0) >= 1) {
                            numberTiles[suit][rank]--;
                            numberTiles[suit][rank + 1]--;
                            numberTiles[suit][rank + 2]--;
                            if (checkMentsuCombination(numberTiles, honorTiles, requiredMentsus, foundMentsus + 1, hasJantou)) {
                                numberTiles[suit][rank]++;
                                numberTiles[suit][rank + 1]++;
                                numberTiles[suit][rank + 2]++;
                                return true;
                            }
                            numberTiles[suit][rank]++;
                            numberTiles[suit][rank + 1]++;
                            numberTiles[suit][rank + 2]++;
                        }
                    }
                }
            }
            
            return false;
        }
        
        // 残り牌数をカウント
        function countRemainingTiles(numberTiles, honorTiles) {
            let count = 0;
            
            for (const suit of Object.values(numberTiles)) {
                for (const tileCount of Object.values(suit)) {
                    count += tileCount;
                }
            }
            
            for (const tileCount of Object.values(honorTiles)) {
                count += tileCount;
            }
            
            return count;
        }
        
        // 雀頭を作れるかチェック
        function canMakeJantou(numberTiles, honorTiles) {
            // 字牌で雀頭
            for (const count of Object.values(honorTiles)) {
                if (count === 2) return true;
            }
            
            // 数牌で雀頭
            for (const suit of Object.values(numberTiles)) {
                for (const count of Object.values(suit)) {
                    if (count === 2) return true;
                }
            }
            
            return false;
        }

        // 和了形チェック（簡易版）
        function isCompleteHand(hand, melds = []) {
            if (!hand) return false;
            
            // メルドを考慮した総牌数チェック
            const totalTiles = hand.length + (melds.length * 3);
            if (totalTiles !== 14) return false;
            
            // 七対子チェック（メルドがない場合のみ）
            if (melds.length === 0 && checkChiitoiAdvanced(hand)) return true;
            
            // 国士無双チェック（メルドがない場合のみ）
            if (melds.length === 0 && checkKokushiAdvanced(hand)) return true;
            
            // 基本形チェック（4面子1雀頭）- より詳細な判定
            return checkBasicWinForm(hand, melds);
        }

        // テンパイ状態を更新・表示
        function updateTenpaiStatus() {
            if (!gameState || !gameState.players[0]) return;
            
            const newTenpaiStatus = checkClientTenpai();
            
            // テンパイ状態や待ち牌が変わった場合のみ更新
            const waitingTilesChanged = JSON.stringify(newTenpaiStatus.waitingTiles) !== JSON.stringify(currentTenpaiStatus.waitingTiles);
            
            if (newTenpaiStatus.isTenpai !== currentTenpaiStatus.isTenpai || waitingTilesChanged) {
                currentTenpaiStatus = newTenpaiStatus;
                
                if (currentTenpaiStatus.isTenpai) {
                    // 役あり・役なし待ちを分類
                    const yakuTiles = currentTenpaiStatus.waitingTiles.filter(t => t.hasYaku);
                    const noyakuTiles = currentTenpaiStatus.waitingTiles.filter(t => !t.hasYaku);
                    
                    let notificationText = 'テンパイ！';
                    
                    if (yakuTiles.length > 0) {
                        const yakuWaitingText = yakuTiles.map(t => t.displayName).join('・');
                        notificationText += ` 役あり待ち: ${yakuWaitingText}`;
                    }
                    
                    if (noyakuTiles.length > 0) {
                        const noyakuWaitingText = noyakuTiles.map(t => t.displayName).join('・');
                        if (yakuTiles.length > 0) {
                            notificationText += ` / 役なし: ${noyakuWaitingText}`;
                        } else {
                            notificationText += ` 役なし待ち: ${noyakuWaitingText}`;
                        }
                    }
                    
                    showNotification(notificationText, yakuTiles.length > 0 ? 'success' : 'warning');
                    console.log('🎯 テンパイ状態:', currentTenpaiStatus);
                } else {
                    console.log('🎯 テンパイ解除');
                }
            }
            
            // テンパイ表示の更新
            displayTenpaiStatus();
        }

        // テンパイ表示
        function displayTenpaiStatus() {
            // テンパイ表示エリアを取得または作成
            let tenpaiDisplay = document.getElementById('tenpaiDisplay');
            if (!tenpaiDisplay) {
                tenpaiDisplay = document.createElement('div');
                tenpaiDisplay.id = 'tenpaiDisplay';
                tenpaiDisplay.style.cssText = `
                    position: fixed;
                    top: 120px;
                    right: 20px;
                    background: rgba(255, 193, 7, 0.9);
                    color: #212529;
                    padding: 10px 15px;
                    border-radius: 8px;
                    font-weight: bold;
                    font-size: 0.9rem;
                    z-index: 1000;
                    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
                    border: 2px solid #ffc107;
                `;
                document.body.appendChild(tenpaiDisplay);
            }
            
            if (currentTenpaiStatus.isTenpai) {
                // 役あり・役なし待ちを分類
                const yakuTiles = currentTenpaiStatus.waitingTiles.filter(t => t.hasYaku);
                const noyakuTiles = currentTenpaiStatus.waitingTiles.filter(t => !t.hasYaku);
                
                let content = '🎯 テンパイ<br>';
                
                if (yakuTiles.length > 0) {
                    const yakuText = yakuTiles.map(t => t.displayName).join('・');
                    content += `<small style="color: #28a745;">役あり: ${yakuText}</small>`;
                }
                
                if (noyakuTiles.length > 0) {
                    const noyakuText = noyakuTiles.map(t => t.displayName).join('・');
                    if (yakuTiles.length > 0) {
                        content += '<br>';
                    }
                    content += `<small style="color: #dc3545;">役なし: ${noyakuText}</small>`;
                }
                
                // 背景色を役の有無に応じて変更
                if (yakuTiles.length > 0) {
                    tenpaiDisplay.style.background = 'rgba(40, 167, 69, 0.9)'; // 緑（役あり）
                    tenpaiDisplay.style.color = 'white';
                } else {
                    tenpaiDisplay.style.background = 'rgba(255, 193, 7, 0.9)'; // 黄（役なしのみ）
                    tenpaiDisplay.style.color = '#212529';
                }
                
                tenpaiDisplay.innerHTML = content;
                tenpaiDisplay.style.display = 'block';
            } else {
                tenpaiDisplay.style.display = 'none';
            }
        }
        
        function canCallChi() {
            if (!gameState || !gameState.players[0] || !lastDiscardedTile) return false;
            
            // チーは前のプレイヤーからのみ可能
            const prevPlayer = (gameState.currentPlayer + 3) % 4;
            if (lastDiscardedPlayer !== prevPlayer) return false;
            
            // 既にリーチしている場合は鳴けない
            if (gameState.players[0].hand.riichi) return false;
            
            // 簡易判定: 同じスート（ji以外）で連続する牌があるかチェック
            const discardedTile = lastDiscardedTile;
            if (discardedTile.suit === 'ji') return false; // 字牌はチー不可
            
            const myTiles = gameState.players[0].hand.tiles;
            const targetRank = discardedTile.rank;
            
            // 連続する牌の組み合わせをチェック
            const hasSequence = myTiles.some((tile1, i) => 
                myTiles.some((tile2, j) => {
                    if (i >= j) return false;
                    if (tile1.suit !== discardedTile.suit || tile2.suit !== discardedTile.suit) return false;
                    
                    // 3つの数字の組み合わせをチェック
                    const ranks = [tile1.rank, tile2.rank, targetRank].sort((a, b) => a - b);
                    return ranks[0] + 1 === ranks[1] && ranks[1] + 1 === ranks[2];
                })
            );
            
            return hasSequence;
        }
        
        function canCallPon() {
            if (!gameState || !gameState.players[0] || !lastDiscardedTile) return false;
            
            // 既にリーチしている場合は鳴けない
            if (gameState.players[0].hand.riichi) return false;
            
            // 同じ牌が2枚以上手牌にあるかチェック
            const discardedTile = lastDiscardedTile;
            const myTiles = gameState.players[0].hand.tiles;
            
            let matchCount = 0;
            for (const tile of myTiles) {
                if (isSameTile(tile, discardedTile)) {
                    matchCount++;
                    if (matchCount >= 2) return true;
                }
            }
            
            return false;
        }
        
        function canCallKan() {
            if (!gameState || !gameState.players[0]) return false;
            
            // 既にリーチしている場合は鳴けない（暗槓は例外だが簡略化）
            if (gameState.players[0].hand.riichi) return false;
            
            const myTiles = gameState.players[0].hand.tiles;
            
            // 同じ牌が4枚あるかチェック（暗槓）
            const tileCounts = {};
            for (const tile of myTiles) {
                const key = `${tile.suit}_${tile.rank}_${tile.honor}`;
                tileCounts[key] = (tileCounts[key] || 0) + 1;
                if (tileCounts[key] >= 4) return true;
            }
            
            // 明槓の場合（相手の捨牌+手牌3枚）
            if (lastDiscardedTile) {
                let matchCount = 0;
                for (const tile of myTiles) {
                    if (isSameTile(tile, lastDiscardedTile)) {
                        matchCount++;
                        if (matchCount >= 3) return true;
                    }
                }
            }
            
            return false;
        }
        
        function canCallRon() {
            if (!gameState || !gameState.players[0] || !lastDiscardedTile) return false;
            
            const player = gameState.players[0];
            const handTiles = player.hand.tiles.length;
            const meldCount = player.hand.melds ? player.hand.melds.length : 0;
            const totalTiles = handTiles + (meldCount * 3);
            
            console.log('🔍 canCallRon DEBUG:', {
                handTiles,
                meldCount,
                totalTiles,
                currentPlayer: gameState.currentPlayer,
                lastDiscardedTile: lastDiscardedTile
            });
            
            // 総牌数が13枚でないとロンできない
            if (totalTiles !== 13) return false;
            
            // 自分のターンではロンできない
            if (gameState.currentPlayer === 0) return false;
            
            // 捨て牌を加えた14枚での和了形チェック
            const discardedTile = lastDiscardedTile.tile || lastDiscardedTile;
            const tilesWithRon = [...player.hand.tiles, discardedTile];
            
            console.log('🔍 ロン判定詳細:', {
                handTiles: player.hand.tiles,
                discardedTile: discardedTile,
                tilesWithRon: tilesWithRon,
                melds: player.hand.melds,
                totalTilesWithRon: tilesWithRon.length + (player.hand.melds?.length || 0) * 3
            });
            
            const canWin = checkClientWinning(tilesWithRon, player.hand.melds);
            console.log('🔍 ロン判定結果:', canWin);
            
            return canWin;
        }

        // クライアント側和了形チェック（簡易版）
        function checkClientWinning(tiles, melds = []) {
            if (!tiles || tiles.length === 0) return false;
            
            // メルドを含めた全牌数が14枚になるかチェック
            const totalTiles = tiles.length + (melds.length * 3);
            if (totalTiles !== 14) return false;
            
            try {
                // 基本和了形チェック（4面子1雀頭）
                if (checkClientBasicWin(tiles, melds)) return true;
                
                // 七対子チェック（メルドがない場合のみ）
                if (melds.length === 0 && checkClientChiitoi(tiles)) return true;
                
                return false;
            } catch (error) {
                console.error('🔍 checkClientWinning error:', error);
                console.error('🔍 tiles:', tiles);
                console.error('🔍 melds:', melds);
                return false;
            }
        }

        // 基本和了形チェック（簡易版）
        function checkClientBasicWin(tiles, melds) {
            console.log('🔍 checkClientBasicWin tiles:', tiles);
            
            // 手牌をソート
            const sortedTiles = [...tiles].filter(tile => tile).sort((a, b) => {
                if (!a || !b) return 0;
                
                // suitがundefinedの場合の安全な処理
                const aSuit = a.suit || '';
                const bSuit = b.suit || '';
                
                if (aSuit !== bSuit) return aSuit.localeCompare(bSuit);
                const aRank = a.rank || a.number || 0;
                const bRank = b.rank || b.number || 0;
                return aRank - bRank;
            });
            
            // 再帰的に面子を取り除いて雀頭が残るかチェック
            return findMentsusAndJantou(sortedTiles, []);
        }

        // 面子と雀頭の組み合わせを探す再帰関数
        function findMentsusAndJantou(tiles, usedGroups) {
            if (tiles.length === 0) return usedGroups.length > 0;
            if (tiles.length < 2) return false;
            
            // 雀頭を探す
            if (tiles.length >= 2 && tiles[0] && tiles[1] && tiles[0].suit === tiles[1].suit && tiles[0].rank === tiles[1].rank) {
                const remaining = tiles.slice(2);
                if (remaining.length === 0) return true; // 雀頭のみで終了
                
                // 残りの牌で面子を作れるかチェック
                if (findAllMentsus(remaining)) return true;
            }
            
            // 先頭から面子を作って再帰
            // 刻子チェック
            if (tiles.length >= 3 && tiles[0] && tiles[1] && tiles[2] &&
                tiles[0].suit === tiles[1].suit && tiles[0].rank === tiles[1].rank &&
                tiles[1].suit === tiles[2].suit && tiles[1].rank === tiles[2].rank) {
                const remaining = tiles.slice(3);
                if (findMentsusAndJantou(remaining, [...usedGroups, 'kotsu'])) return true;
            }
            
            // 順子チェック（数牌のみ）
            if (tiles[0] && tiles[0].suit !== 'honors' && tiles.length >= 3) {
                const tile1 = tiles[0];
                const tile1Rank = tile1.rank || tile1.number || 0;
                const tile2Index = tiles.findIndex(t => t && t.suit === tile1.suit && (t.rank || t.number || 0) === tile1Rank + 1);
                const tile3Index = tiles.findIndex(t => t && t.suit === tile1.suit && (t.rank || t.number || 0) === tile1Rank + 2);
                
                if (tile2Index !== -1 && tile3Index !== -1) {
                    const remaining = [...tiles];
                    remaining.splice(tile3Index, 1);
                    remaining.splice(tile2Index > tile3Index ? tile2Index - 1 : tile2Index, 1);
                    remaining.splice(0, 1);
                    
                    if (findMentsusAndJantou(remaining, [...usedGroups, 'shuntsu'])) return true;
                }
            }
            
            return false;
        }

        // すべて面子で構成されているかチェック
        function findAllMentsus(tiles) {
            if (tiles.length === 0) return true;
            if (tiles.length % 3 !== 0) return false;
            
            // 刻子チェック
            if (tiles.length >= 3 && tiles[0] && tiles[1] && tiles[2] &&
                tiles[0].suit === tiles[1].suit && tiles[0].rank === tiles[1].rank &&
                tiles[1].suit === tiles[2].suit && tiles[1].rank === tiles[2].rank) {
                return findAllMentsus(tiles.slice(3));
            }
            
            // 順子チェック
            if (tiles[0] && tiles[0].suit !== 'honors' && tiles.length >= 3) {
                const tile1 = tiles[0];
                const tile1Rank = tile1.rank || tile1.number || 0;
                const tile2Index = tiles.findIndex(t => t && t.suit === tile1.suit && (t.rank || t.number || 0) === tile1Rank + 1);
                const tile3Index = tiles.findIndex(t => t && t.suit === tile1.suit && (t.rank || t.number || 0) === tile1Rank + 2);
                
                if (tile2Index !== -1 && tile3Index !== -1) {
                    const remaining = [...tiles];
                    remaining.splice(tile3Index, 1);
                    remaining.splice(tile2Index > tile3Index ? tile2Index - 1 : tile2Index, 1);
                    remaining.splice(0, 1);
                    
                    return findAllMentsus(remaining);
                }
            }
            
            return false;
        }

        // 七対子チェック
        function checkClientChiitoi(tiles) {
            if (tiles.length !== 14) return false;
            
            const tileCounts = {};
            for (const tile of tiles) {
                if (!tile) continue;
                const rank = tile.rank || tile.number || 0;
                const key = `${tile.suit}_${rank}`;
                tileCounts[key] = (tileCounts[key] || 0) + 1;
            }
            
            const counts = Object.values(tileCounts);
            return counts.length === 7 && counts.every(count => count === 2);
        }

        // 牌選択
        function selectTile(playerIndex, tileIndex, tile) {
            // 視覚位置から実際のプレイヤーIDを取得
            const actualPlayerId = getActualPlayerId(playerIndex, myPlayerId);
            
            if (actualPlayerId !== myPlayerId) {
                showNotification('自分の牌のみ選択できます', 'warning');
                return;
            }
            
            if (gameState && gameState.currentPlayer !== myPlayerId) {
                showNotification('あなたのターンではありません', 'warning');
                return;
            }

            // 選択解除
            document.querySelectorAll('.tile.selected').forEach(t => t.classList.remove('selected'));

            // 既に選択されている牌をクリックした場合は打牌
            if (selectedTile && selectedTile.tileIndex === tileIndex && selectedTile.tile.id === tile.id) {
                discardSelected();
                return;
            }

            // 新しい牌を選択
            selectedTile = { playerIndex: actualPlayerId, tileIndex, tile };
            document.getElementById('hand0').children[tileIndex].classList.add('selected');
            soundManager.playSound('tileSelect');
            showNotification(`${tile.displayName || tile.unicode} を選択（再クリックで打牌）`, 'info');
        }

        // 打牌処理
        function discardSelected() {
            console.log('🎯 discardSelected called');
            console.log('🔍 selectedTile:', selectedTile);
            console.log('🔍 gameId:', gameId);
            console.log('🔍 isConnected:', isConnected);
            
            if (!selectedTile) {
                showNotification('牌を選択してください', 'warning');
                return;
            }
            
            if (!gameId) {
                showNotification('ゲームIDが設定されていません', 'error');
                console.error('❌ gameId is null/undefined');
                return;
            }
            
            if (!isConnected) {
                showNotification('サーバーに接続されていません', 'error');
                return;
            }

            console.log('🎯 打牌アクション送信:', selectedTile.tile);
            socket.emit('playerAction', {
                type: 'discard',
                playerId: 'player_0',
                tileId: selectedTile.tile.id,
                priority: 1,
                timestamp: Date.now()
            });
            
            selectedTile = null;
            soundManager.playSound('tilePlace');
        }

        // ツモ処理
        function drawTile() {
            if (!gameId || !isConnected) {
                showNotification('ゲームに接続されていません', 'error');
                return;
            }
            
            console.log('🎯 ツモアクション送信');
            socket.emit('playerAction', {
                type: 'draw',
                playerId: 'player_0',
                priority: 1,
                timestamp: Date.now()
            });
            
            soundManager.playSound('tilePlace');
        }

        // ゲーム状態取得
        function requestGameState() {
            if (!gameId || !isConnected) {
                showNotification('ゲームに接続されていません', 'error');
                return;
            }
            
            console.log('🔄 ゲーム状態をリクエスト');
            socket.emit('requestGameState');
        }

        // AI実行
        async function executeAI() {
            if (!gameId) return;
            
            try {
                const response = await fetch(`/api/game/${gameId}/ai`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });

                const result = await response.json();
                if (result.status === 'OK') {
                    gameState = result.data.gameState;
                    updateGameDisplay();
                    soundManager.playSound('tilePlace');
                    showNotification(result.message || 'AI が行動しました', 'success');
                } else {
                    showNotification(result.message || 'AI実行に失敗しました', 'error');
                }
            } catch (error) {
                console.error('AI error:', error);
                showNotification('エラーが発生しました', 'error');
            }
        }

        // パスボタンを非表示にする関数
        function hidePassButton() {
            const passBtn = document.getElementById('passBtn');
            if (passBtn) {
                passBtn.style.display = 'none';
            }
        }

        // メルドパス関数
        function passMeld() {
            console.log('⏩ passMeld() called');
            
            if (!gameId || !isConnected) {
                showNotification('ゲームに接続されていません', 'error');
                return;
            }
            
            console.log('⏩ パスアクション送信');
            socket.emit('playerAction', {
                type: 'pass',
                playerId: `player_${myPlayerId}`,
                timestamp: Date.now()
            });
            
            // パスボタンを非表示
            hidePassButton();
            
            // メルド選択UIを非表示
            const existingUI = document.querySelector('.meld-selection-modal');
            if (existingUI) {
                existingUI.remove();
            }
            
            // パスボタンも非表示
            hidePassButton();
            
            showNotification('パスしました', 'info');
        }

        // 鳴き関数
        // チー
        async function callChi() {
            console.log('🎯 callChi() called');
            console.log('🎯 gameState:', !!gameState);
            console.log('🎯 lastDiscardedTile:', lastDiscardedTile);
            console.log('🎯 lastDiscardedPlayer:', lastDiscardedPlayer);
            
            if (!gameState || !lastDiscardedTile) {
                console.log('🎯 Chi early return - missing gameState or lastDiscardedTile');
                showNotification('チーできません', 'error');
                return;
            }
            
            try {
                // 手牌からチーに使用する牌を見つける
                const myTiles = gameState.players[0].hand.tiles;
                const targetRank = lastDiscardedTile.rank;
                
                // 連続する牌の組み合わせを探す
                let chiTiles = null;
                for (let i = 0; i < myTiles.length - 1; i++) {
                    for (let j = i + 1; j < myTiles.length; j++) {
                        const tile1 = myTiles[i];
                        const tile2 = myTiles[j];
                        
                        if (tile1.suit !== lastDiscardedTile.suit || tile2.suit !== lastDiscardedTile.suit) continue;
                        if (tile1.suit === 'ji') continue; // 字牌はチー不可
                        
                        const ranks = [tile1.rank, tile2.rank, targetRank].sort((a, b) => a - b);
                        if (ranks[0] + 1 === ranks[1] && ranks[1] + 1 === ranks[2]) {
                            chiTiles = [tile1, tile2];
                            break;
                        }
                    }
                    if (chiTiles) break;
                }
                
                if (!chiTiles) {
                    showNotification('チーできる牌がありません', 'error');
                    return;
                }
                
                // メルドオブジェクトを構築
                const meld = {
                    id: `chi_${Date.now()}_player0`,
                    type: 'chi',
                    tiles: [...chiTiles, lastDiscardedTile],
                    fromPlayer: lastDiscardedPlayer,
                    isConcealed: false,
                    calledTile: lastDiscardedTile
                };

                console.log('🎯 チーアクション送信');
                socket.emit('playerAction', {
                    type: 'chi',
                    playerId: 'player_0',
                    meld: meld,
                    tile: lastDiscardedTile,
                    priority: 2,
                    timestamp: Date.now()
                });
                
                // パスボタンを非表示
                hidePassButton();
                
                soundManager.playSound('meld');
            } catch (error) {
                console.error('Chi error:', error);
                showNotification('エラーが発生しました', 'error');
            }
        }

        // ポン
        async function callPon() {
            console.log('🎯 callPon() called');
            console.log('🎯 gameState:', !!gameState);
            console.log('🎯 lastDiscardedTile:', lastDiscardedTile);
            console.log('🎯 lastDiscardedPlayer:', lastDiscardedPlayer);
            
            if (!gameState || !lastDiscardedTile) {
                console.log('🎯 Pon early return - missing gameState or lastDiscardedTile');
                showNotification('ポンできません', 'error');
                return;
            }
            
            try {
                // 手牌から同じ牌を2枚探す
                const myTiles = gameState.players[0].hand.tiles;
                const matchingTiles = [];
                
                for (const tile of myTiles) {
                    if (isSameTile(tile, lastDiscardedTile)) {
                        matchingTiles.push(tile);
                        if (matchingTiles.length >= 2) break;
                    }
                }
                
                if (matchingTiles.length < 2) {
                    showNotification('ポンできる牌がありません', 'error');
                    return;
                }
                
                // メルドオブジェクトを構築
                const meld = {
                    id: `pon_${Date.now()}_player0`,
                    type: 'pon',
                    tiles: [...matchingTiles, lastDiscardedTile],
                    fromPlayer: lastDiscardedPlayer,
                    isConcealed: false,
                    calledTile: lastDiscardedTile
                };

                console.log('🎯 ポンアクション送信');
                console.log('🀄 [PON DEBUG] lastDiscardedTile:', lastDiscardedTile);
                console.log('🀄 [PON DEBUG] matchingTiles:', matchingTiles);
                console.log('🀄 [PON DEBUG] meld:', meld);
                console.log('🀄 [PON DEBUG] currentPlayer:', gameState.currentPlayer);
                console.log('🀄 [PON DEBUG] lastDiscardedPlayer:', lastDiscardedPlayer);
                
                socket.emit('playerAction', {
                    type: 'pon',
                    playerId: 'player_0',
                    meld: meld,
                    tile: lastDiscardedTile,
                    priority: 2,
                    timestamp: Date.now()
                });
                
                soundManager.playSound('meld');
            } catch (error) {
                console.error('Pon error:', error);
                showNotification('エラーが発生しました', 'error');
            }
        }

        // カン
        // チー実行（改善版）
        async function callChi() {
            if (!gameState || !lastDiscardedTile) {
                showNotification('チーできません', 'error');
                return;
            }
            
            try {
                const myTiles = gameState.players[0].hand.tiles;
                const discardedTile = lastDiscardedTile;
                
                // チー可能な組み合わせを検索
                const chiCombinations = findChiCombinations(myTiles, discardedTile);
                
                if (chiCombinations.length === 0) {
                    showNotification('チーできる組み合わせがありません', 'error');
                    return;
                }
                
                if (chiCombinations.length === 1) {
                    // 1つだけの場合は直接実行
                    executeChiAction(chiCombinations[0], discardedTile);
                } else {
                    // 複数の場合は選択UIを表示
                    showChiSelectionUI(chiCombinations, discardedTile);
                }
            } catch (error) {
                console.error('Chi error:', error);
                showNotification('エラーが発生しました', 'error');
            }
        }
        
        // ポン実行（改善版）
        async function callPon() {
            if (!gameState || !lastDiscardedTile) {
                showNotification('ポンできません', 'error');
                return;
            }
            
            try {
                const myTiles = gameState.players[0].hand.tiles;
                const discardedTile = lastDiscardedTile;
                
                // ポン可能かチェック
                const ponTiles = findPonTiles(myTiles, discardedTile);
                
                if (ponTiles.length < 2) {
                    showNotification('ポンできる牌がありません', 'error');
                    return;
                }
                
                // ポンを実行
                executePonAction(ponTiles, discardedTile);
            } catch (error) {
                console.error('Pon error:', error);
                showNotification('エラーが発生しました', 'error');
            }
        }
        
        // メルド選択とアクションの統合関数
        async function callMeld() {
            if (!gameState || !lastDiscardedTile) {
                showNotification('メルドできません', 'error');
                return;
            }
            
            const myTiles = gameState.players[0].hand.tiles;
            const discardedTile = lastDiscardedTile;
            
            // 全ての可能なメルドを検索
            const chiCombinations = findChiCombinations(myTiles, discardedTile);
            const ponTiles = findPonTiles(myTiles, discardedTile);
            const kanTiles = findKanTiles(myTiles, discardedTile);
            
            const allOptions = [];
            
            // チー選択肢を追加
            chiCombinations.forEach((combo, index) => {
                allOptions.push({
                    type: 'chi',
                    displayName: `チー: ${combo.map(t => getTileDisplayName(t)).join('')}`,
                    tiles: combo,
                    discardedTile: discardedTile
                });
            });
            
            // ポン選択肢を追加
            if (ponTiles.length >= 2) {
                allOptions.push({
                    type: 'pon',
                    displayName: `ポン: ${getTileDisplayName(discardedTile)}${getTileDisplayName(discardedTile)}${getTileDisplayName(discardedTile)}`,
                    tiles: ponTiles,
                    discardedTile: discardedTile
                });
            }
            
            // カン選択肢を追加
            if (kanTiles.length >= 3) {
                allOptions.push({
                    type: 'kan',
                    displayName: `カン: ${getTileDisplayName(discardedTile)}${getTileDisplayName(discardedTile)}${getTileDisplayName(discardedTile)}${getTileDisplayName(discardedTile)}`,
                    tiles: kanTiles,
                    discardedTile: discardedTile
                });
            }
            
            if (allOptions.length === 0) {
                showNotification('メルドできません', 'error');
                return;
            }
            
            if (allOptions.length === 1) {
                // 1つだけの場合は直接実行
                executeMeldAction(allOptions[0]);
            } else {
                // 複数の場合は選択UIを表示
                showMeldSelectionUI(allOptions);
            }
        }
        
        // チー組み合わせ検索
        function findChiCombinations(tiles, discardedTile) {
            if (discardedTile.honor) return []; // 字牌はチーできない
            
            const combinations = [];
            const rank = discardedTile.rank;
            const suit = discardedTile.suit;
            
            // ABC型（discardedTileがC）
            if (rank >= 3) {
                const needed = [
                    { suit: suit, rank: rank - 2 },
                    { suit: suit, rank: rank - 1 }
                ];
                const found = findTilesInHand(tiles, needed);
                if (found.length === 2) {
                    combinations.push([...found, discardedTile]);
                }
            }
            
            // ABC型（discardedTileがB）
            if (rank >= 2 && rank <= 8) {
                const needed = [
                    { suit: suit, rank: rank - 1 },
                    { suit: suit, rank: rank + 1 }
                ];
                const found = findTilesInHand(tiles, needed);
                if (found.length === 2) {
                    combinations.push([found[0], discardedTile, found[1]]);
                }
            }
            
            // ABC型（discardedTileがA）
            if (rank <= 7) {
                const needed = [
                    { suit: suit, rank: rank + 1 },
                    { suit: suit, rank: rank + 2 }
                ];
                const found = findTilesInHand(tiles, needed);
                if (found.length === 2) {
                    combinations.push([discardedTile, ...found]);
                }
            }
            
            return combinations;
        }
        
        // ポン可能牌検索
        function findPonTiles(tiles, discardedTile) {
            const matchingTiles = [];
            for (const tile of tiles) {
                if (isSameTile(tile, discardedTile)) {
                    matchingTiles.push(tile);
                    if (matchingTiles.length >= 2) break;
                }
            }
            return matchingTiles;
        }
        
        // カン可能牌検索
        function findKanTiles(tiles, discardedTile) {
            const matchingTiles = [];
            for (const tile of tiles) {
                if (isSameTile(tile, discardedTile)) {
                    matchingTiles.push(tile);
                    if (matchingTiles.length >= 3) break;
                }
            }
            return matchingTiles;
        }
        
        // 手牌から必要な牌を検索
        function findTilesInHand(tiles, needed) {
            const found = [];
            const usedIndices = [];
            
            for (const needTile of needed) {
                let foundIndex = -1;
                for (let i = 0; i < tiles.length; i++) {
                    if (usedIndices.includes(i)) continue;
                    if (isSameTile(tiles[i], needTile)) {
                        foundIndex = i;
                        break;
                    }
                }
                if (foundIndex !== -1) {
                    found.push(tiles[foundIndex]);
                    usedIndices.push(foundIndex);
                } else {
                    return []; // 必要な牌が見つからない
                }
            }
            
            return found;
        }
        
        // メルド選択UI表示
        function showMeldSelectionUI(options) {
            // 既存の選択UIがあれば削除
            const existingUI = document.querySelector('.meld-selection-modal');
            if (existingUI) {
                existingUI.remove();
            }
            
            const modal = document.createElement('div');
            modal.className = 'meld-selection-modal';
            modal.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.95);
                border: 2px solid #ffc107;
                border-radius: 10px;
                padding: 20px;
                z-index: 10000;
                color: white;
                font-family: 'Noto Sans JP', sans-serif;
                max-width: 500px;
                width: 90%;
            `;
            
            const title = document.createElement('h3');
            title.textContent = 'メルド選択';
            title.style.cssText = `
                margin: 0 0 15px 0;
                color: #ffc107;
                text-align: center;
            `;
            
            const optionContainer = document.createElement('div');
            optionContainer.style.cssText = `
                display: flex;
                flex-direction: column;
                gap: 10px;
            `;
            
            options.forEach((option, index) => {
                const button = document.createElement('button');
                button.textContent = option.displayName;
                button.style.cssText = `
                    padding: 12px 20px;
                    background: linear-gradient(45deg, #007bff, #0056b3);
                    color: white;
                    border: none;
                    border-radius: 5px;
                    cursor: pointer;
                    font-size: 16px;
                    transition: all 0.3s ease;
                `;
                
                button.addEventListener('mouseenter', () => {
                    button.style.background = 'linear-gradient(45deg, #0056b3, #003d82)';
                    button.style.transform = 'scale(1.05)';
                });
                
                button.addEventListener('mouseleave', () => {
                    button.style.background = 'linear-gradient(45deg, #007bff, #0056b3)';
                    button.style.transform = 'scale(1)';
                });
                
                button.addEventListener('click', () => {
                    modal.remove();
                    executeMeldAction(option);
                });
                
                optionContainer.appendChild(button);
            });
            
            // キャンセルボタン
            const cancelButton = document.createElement('button');
            cancelButton.textContent = 'キャンセル';
            cancelButton.style.cssText = `
                padding: 10px 20px;
                background: #6c757d;
                color: white;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                margin-top: 10px;
            `;
            
            cancelButton.addEventListener('click', () => {
                modal.remove();
            });
            
            modal.appendChild(title);
            modal.appendChild(optionContainer);
            modal.appendChild(cancelButton);
            document.body.appendChild(modal);
            
            // 5秒後に自動削除
            setTimeout(() => {
                if (document.body.contains(modal)) {
                    modal.remove();
                }
            }, 5000);
        }
        
        // メルドアクション実行
        function executeMeldAction(option) {
            switch (option.type) {
                case 'chi':
                    executeChiAction(option.tiles, option.discardedTile);
                    break;
                case 'pon':
                    executePonAction(option.tiles, option.discardedTile);
                    break;
                case 'kan':
                    executeKanAction(option.tiles, option.discardedTile);
                    break;
                default:
                    console.error('Unknown meld type:', option.type);
            }
        }
        
        // チーアクション実行
        function executeChiAction(tiles, discardedTile) {
            const meld = {
                id: `chi_${Date.now()}_player0`,
                type: 'chi',
                tiles: tiles,
                fromPlayer: lastDiscardedPlayer,
                isConcealed: false,
                calledTile: discardedTile
            };
            
            console.log('🎯 チーアクション送信');
            socket.emit('playerAction', {
                type: 'chi',
                playerId: 'player_0',
                meld: meld,
                tile: discardedTile,
                priority: 1,
                timestamp: Date.now()
            });
            
            soundManager.playSound('meld');
        }
        
        // ポンアクション実行
        function executePonAction(tiles, discardedTile) {
            const meld = {
                id: `pon_${Date.now()}_player0`,
                type: 'pon',
                tiles: [...tiles, discardedTile],
                fromPlayer: lastDiscardedPlayer,
                isConcealed: false,
                calledTile: discardedTile
            };
            
            console.log('🎯 ポンアクション送信');
            socket.emit('playerAction', {
                type: 'pon',
                playerId: 'player_0',
                meld: meld,
                tile: discardedTile,
                priority: 2,
                timestamp: Date.now()
            });
            
            soundManager.playSound('meld');
        }
        
        // カンアクション実行
        function executeKanAction(tiles, discardedTile) {
            const meld = {
                id: `kan_${Date.now()}_player0`,
                type: 'kan',
                tiles: [...tiles, discardedTile],
                fromPlayer: lastDiscardedPlayer,
                isConcealed: false,
                calledTile: discardedTile
            };
            
            console.log('🎯 カンアクション送信');
            socket.emit('playerAction', {
                type: 'kan',
                playerId: 'player_0',
                meld: meld,
                tile: discardedTile,
                priority: 3,
                timestamp: Date.now()
            });
            
            soundManager.playSound('meld');
        }
        
        // 牌の表示名を取得
        function getTileDisplayName(tile) {
            // Unicodeが利用可能な場合は優先
            if (tile.unicode) {
                return tile.unicode;
            }
            
            if (tile.honor) {
                // 字牌のUnicode
                const honorUnicodes = {
                    'east': '🀀', 'south': '🀁', 'west': '🀂', 'north': '🀃',
                    'white': '🀆', 'green': '🀅', 'red': '🀄'
                };
                return honorUnicodes[tile.honor] || tile.honor;
            } else {
                // 数牌のUnicode
                const suitUnicodes = {
                    man: ['🀇', '🀈', '🀉', '🀊', '🀋', '🀌', '🀍', '🀎', '🀏'],
                    pin: ['🀙', '🀚', '🀛', '🀜', '🀝', '🀞', '🀟', '🀠', '🀡'],
                    sou: ['🀐', '🀑', '🀒', '🀓', '🀔', '🀕', '🀖', '🀗', '🀘']
                };
                
                if (suitUnicodes[tile.suit] && tile.rank >= 1 && tile.rank <= 9) {
                    return suitUnicodes[tile.suit][tile.rank - 1];
                }
                
                // フォールバック
                const suitNames = { 'man': 'm', 'pin': 'p', 'sou': 's' };
                return `${tile.rank}${suitNames[tile.suit] || tile.suit}`;
            }
        }
        
        // 牌が同じかチェック
        function isSameTile(tile1, tile2) {
            if (tile1.honor && tile2.honor) {
                return tile1.honor === tile2.honor;
            } else if (!tile1.honor && !tile2.honor) {
                return tile1.suit === tile2.suit && tile1.rank === tile2.rank;
            }
            return false;
        }

        async function callKan() {
            if (!gameState) {
                showNotification('カンできません', 'error');
                return;
            }
            
            try {
                const myTiles = gameState.players[0].hand.tiles;
                let kanTiles = [];
                let kanType = null;
                
                // 明槓の場合（相手の捨牌+手牌3枚）
                if (lastDiscardedTile) {
                    const matchingTiles = [];
                    for (const tile of myTiles) {
                        if (isSameTile(tile, lastDiscardedTile)) {
                            matchingTiles.push(tile);
                            if (matchingTiles.length >= 3) break;
                        }
                    }
                    
                    if (matchingTiles.length >= 3) {
                        kanTiles = [...matchingTiles, lastDiscardedTile];
                        kanType = 'kan';
                    }
                }
                
                // 加槓の場合（既存のポンに手牌の同じ牌を追加）
                if (kanTiles.length === 0) {
                    const myMelds = gameState.players[0].hand.melds || [];
                    for (const meld of myMelds) {
                        if (meld.type === 'pon') {
                            const meldTile = meld.tiles[0]; // ポンの牌
                            for (const handTile of myTiles) {
                                if (isSameTile(handTile, meldTile)) {
                                    kanTiles = [...meld.tiles, handTile];
                                    kanType = 'kakan'; // 加槓
                                    console.log('🔍 加槓可能:', kanTiles);
                                    break;
                                }
                            }
                            if (kanTiles.length > 0) break;
                        }
                    }
                }

                // 暗槓の場合（手牌4枚）
                if (kanTiles.length === 0) {
                    const tileCounts = {};
                    for (const tile of myTiles) {
                        const key = `${tile.suit}_${tile.rank}_${tile.honor}`;
                        if (!tileCounts[key]) tileCounts[key] = [];
                        tileCounts[key].push(tile);
                    }
                    
                    for (const [key, tiles] of Object.entries(tileCounts)) {
                        if (tiles.length >= 4) {
                            kanTiles = tiles.slice(0, 4);
                            kanType = 'ankan';
                            break;
                        }
                    }
                }
                
                if (kanTiles.length === 0) {
                    showNotification('カンできる牌がありません', 'error');
                    return;
                }
                
                // メルドオブジェクトを構築
                const meld = {
                    id: `kan_${Date.now()}_player0`,
                    type: kanType,
                    tiles: kanTiles,
                    fromPlayer: kanType === 'ankan' ? 0 : lastDiscardedPlayer,
                    isConcealed: kanType === 'ankan',
                    calledTile: kanType === 'ankan' ? null : lastDiscardedTile
                };

                console.log('🎯 カンアクション送信');
                socket.emit('playerAction', {
                    type: kanType,
                    playerId: 'player_0',
                    meld: meld,
                    tile: kanType === 'ankan' ? kanTiles[0] : lastDiscardedTile,
                    priority: 3,
                    timestamp: Date.now()
                });
                
                soundManager.playSound('meld');
            } catch (error) {
                console.error('Kan error:', error);
                showNotification('エラーが発生しました', 'error');
            }
        }

        // ツモ和了
        function callTsumo() {
            if (!gameState || gameState.currentPlayer !== 0) {
                showNotification('ツモできません（あなたのターンではありません）', 'error');
                return;
            }
            
            console.log('🎯 ツモアクション送信');
            socket.emit('playerAction', {
                type: 'tsumo',
                playerId: 'player_0',
                priority: 5,
                timestamp: Date.now()
            });
            
            soundManager.playSound('tilePlace');
        }

        // ロン和了
        function callRon() {
            if (!gameState || gameState.currentPlayer === 0) {
                showNotification('ロンできません', 'error');
                return;
            }
            
            console.log('🎯 ロンアクション送信');
            socket.emit('playerAction', {
                type: 'ron',
                playerId: 'player_0',
                priority: 5,
                timestamp: Date.now()
            });
            
            soundManager.playSound('tilePlace');
        }

        // リーチ
        function callRiichi() {
            if (!gameState || gameState.currentPlayer !== 0) {
                showNotification('リーチできません（あなたのターンではありません）', 'error');
                return;
            }
            
            if (!canCallRiichi()) {
                showNotification('リーチできません（条件を満たしていません）', 'error');
                return;
            }
            
            // リーチ棒演出
            showRiichiStick();
            
            performAction('riichi', {}, (result) => {
                if (result.success) {
                    showNotification('リーチ！', 'success');
                    requestGameState();
                } else {
                    showNotification(`リーチできません: ${result.error}`, 'error');
                    hideRiichiStick(); // 失敗時は棒を隠す
                }
            });
        }
        
        // リーチ棒演出
        function showRiichiStick() {
            const riichiStick = document.getElementById('riichiStick');
            if (riichiStick) {
                riichiStick.style.display = 'block';
                riichiStick.style.animation = 'riichiPlace 0.5s ease-out';
                riichiStick.textContent = '1000点棒';
            }
        }
        
        function hideRiichiStick() {
            const riichiStick = document.getElementById('riichiStick');
            if (riichiStick) {
                riichiStick.style.display = 'none';
            }
        }
        
        // 吹き出し表示機能
        function showSpeechBubble(playerIndex, message, duration = 2000) {
            const bubble = document.getElementById(`speechBubble${playerIndex}`);
            if (bubble) {
                bubble.textContent = message;
                bubble.style.display = 'block';
                bubble.style.animation = 'speechAppear 0.3s ease-out';
                
                // 一定時間後に自動非表示
                setTimeout(() => {
                    bubble.style.display = 'none';
                }, duration);
            }
        }
        
        // メルド宣言用の吹き出し
        function showMeldAnnouncement(playerIndex, meldType, tiles) {
            let message = '';
            switch (meldType) {
                case 'chi':
                    message = 'チー！';
                    break;
                case 'pon':
                    message = 'ポン！';
                    break;
                case 'kan':
                    message = 'カン！';
                    break;
                case 'riichi':
                    message = 'リーチ！';
                    break;
                case 'tsumo':
                    message = 'ツモ！';
                    break;
                case 'ron':
                    message = 'ロン！';
                    break;
                default:
                    message = meldType;
            }
            showSpeechBubble(playerIndex, message, 3000);
        }
        
        // メルド表示機能
        function updateMeldDisplay() {
            if (!gameState || !gameState.players) return;
            
            gameState.players.forEach((player, playerIndex) => {
                const meldArea = document.getElementById(`melds${playerIndex}`);
                if (!meldArea) return;
                
                meldArea.innerHTML = '';
                
                if (player.hand && player.hand.melds) {
                    player.hand.melds.forEach((meld, meldIndex) => {
                        const meldGroup = createMeldDisplay(meld);
                        meldArea.appendChild(meldGroup);
                    });
                }
            });
        }
        
        function createMeldDisplay(meld) {
            const meldGroup = document.createElement('div');
            meldGroup.className = `meld-group ${meld.type}`;
            
            // メルドラベル
            const label = document.createElement('div');
            label.className = 'meld-label';
            label.textContent = meld.type.toUpperCase();
            meldGroup.appendChild(label);
            
            // メルドの牌表示
            meld.tiles.forEach((tile, tileIndex) => {
                const tileElement = document.createElement('div');
                tileElement.className = 'meld-tile';
                
                if (tile.isRed) tileElement.classList.add('red');
                
                // 鳴いた牌は横向き（チー・ポンの場合、最後の牌）
                if (meld.type !== 'kan' && tileIndex === meld.tiles.length - 1) {
                    tileElement.classList.add('called');
                }
                
                tileElement.textContent = getTileDisplayName(tile);
                meldGroup.appendChild(tileElement);
            });
            
            return meldGroup;
        }

        function toggleDebug() {
            debugMode = !debugMode;
            showNotification(debugMode ? 'デバッグモードON' : 'デバッグモードOFF', 'info');
        }

        // CPU自動対戦モード切り替え
        let cpuAutoMode = false;
        function toggleCpuAuto() {
            if (!gameId) {
                showNotification('ゲームが開始されていません', 'error');
                return;
            }

            cpuAutoMode = !cpuAutoMode;
            const btn = document.getElementById('cpuAutoBtn');
            
            if (cpuAutoMode) {
                btn.textContent = 'CPU自動停止';
                btn.className = 'btn btn-danger';
                showNotification('🤖 CPU自動対戦モード開始', 'success');
                
                // サーバーにCPU自動モード開始を通知
                fetch(`/api/game/${gameId}/cpu-auto`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        enabled: true,
                        speed: 400
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'OK') {
                        console.log('✅ CPU自動対戦開始:', data.message);
                        // 定期的にゲーム状態を更新
                        startCpuAutoMonitoring();
                    } else {
                        throw new Error(data.message);
                    }
                })
                .catch(error => {
                    console.error('❌ CPU自動対戦開始エラー:', error);
                    showNotification('CPU自動対戦開始失敗: ' + error.message, 'error');
                    // ボタンを元に戻す
                    cpuAutoMode = false;
                    btn.textContent = 'CPU自動開始';
                    btn.className = 'btn btn-success';
                });
            } else {
                btn.textContent = 'CPU自動開始';
                btn.className = 'btn btn-success';
                showNotification('🛑 CPU自動対戦モード停止', 'warning');
                
                // サーバーにCPU自動モード停止を通知
                fetch(`/api/game/${gameId}/cpu-auto`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        enabled: false
                    })
                })
                .then(response => response.json())
                .then(data => {
                    console.log('🛑 CPU自動対戦停止:', data.message);
                    stopCpuAutoMonitoring();
                })
                .catch(error => {
                    console.error('❌ CPU自動対戦停止エラー:', error);
                });
            }
        }

        // CPU自動対戦モード監視
        let cpuAutoInterval = null;
        function startCpuAutoMonitoring() {
            if (cpuAutoInterval) clearInterval(cpuAutoInterval);
            
            cpuAutoInterval = setInterval(() => {
                if (cpuAutoMode && gameId) {
                    requestGameState();
                }
            }, 2000); // 2秒ごとに状態確認
        }

        function stopCpuAutoMonitoring() {
            if (cpuAutoInterval) {
                clearInterval(cpuAutoInterval);
                cpuAutoInterval = null;
            }
        }

        // プレイヤーオートツモ切りモード切り替え
        let playerAutoMode = false;
        function togglePlayerAuto() {
            if (!gameId) {
                showNotification('ゲームが開始されていません', 'error');
                return;
            }

            playerAutoMode = !playerAutoMode;
            const btn = document.getElementById('playerAutoBtn');
            
            if (playerAutoMode) {
                btn.textContent = 'オート切OFF';
                btn.className = 'btn btn-primary';
                showNotification('🎯 オートツモ切りモード開始', 'success');
                
                // サーバーにプレイヤーオートモード開始を通知
                fetch(`/api/game/${gameId}/player-auto`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        enabled: true
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'OK') {
                        console.log('✅ プレイヤーオートツモ切り開始:', data.message);
                    } else {
                        throw new Error(data.message);
                    }
                })
                .catch(error => {
                    console.error('❌ プレイヤーオートツモ切り開始エラー:', error);
                    showNotification('オートツモ切り開始失敗: ' + error.message, 'error');
                    // ボタンを元に戻す
                    playerAutoMode = false;
                    btn.textContent = 'オートツモ切り';
                    btn.className = 'btn btn-secondary';
                });
            } else {
                btn.textContent = 'オートツモ切り';
                btn.className = 'btn btn-secondary';
                showNotification('🛑 オートツモ切りモード停止', 'warning');
                
                // サーバーにプレイヤーオートモード停止を通知
                fetch(`/api/game/${gameId}/player-auto`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        enabled: false
                    })
                })
                .then(response => response.json())
                .then(data => {
                    console.log('🛑 プレイヤーオートツモ切り停止:', data.message);
                })
                .catch(error => {
                    console.error('❌ プレイヤーオートツモ切り停止エラー:', error);
                });
            }
        }

        // デバッグ関数群
        function forceCPUTurn() {
            if (!gameState) {
                showNotification('ゲーム状態がありません', 'error');
                return;
            }
            const currentPlayer = gameState.players[gameState.currentPlayer];
            if (currentPlayer && currentPlayer.name.includes('CPU')) {
                executeAI();
                showNotification(`${currentPlayer.name}のターンを強制実行`, 'info');
            } else {
                showNotification('現在のプレイヤーはCPUではありません', 'warning');
            }
        }

        function showGameLog() {
            if (!gameState || !gameState.gameLog) {
                console.log('📋 ゲームログ: なし');
                showNotification('ゲームログがありません', 'warning');
                return;
            }
            console.log('📋 ゲームログ:', gameState.gameLog);
            console.log('📋 ゲームログ詳細:');
            gameState.gameLog.forEach((log, index) => {
                console.log(`  ${index + 1}. [${log.type}] ${log.description}`, log);
            });
            showNotification(`ゲームログをコンソールに表示 (${gameState.gameLog.length}件)`, 'info');
        }

        function toggleDebugMode() {
            debugMode = !debugMode;
            showNotification(debugMode ? '🔧 デバッグモードON' : '🔧 デバッグモードOFF', 'info');
        }

        function skipToNextPlayer() {
            if (!gameState) {
                showNotification('ゲーム状態がありません', 'error');
                return;
            }
            const nextPlayer = (gameState.currentPlayer + 1) % 4;
            console.log(`⏭️ 次のプレイヤーに強制移行: ${gameState.currentPlayer} → ${nextPlayer}`);
            showNotification(`プレイヤー${nextPlayer}のターンに移行`, 'info');
        }

        function showDiscards() {
            if (!gameState) {
                showNotification('ゲーム状態がありません', 'error');
                return;
            }
            console.log('🗂️ 捨て牌情報:');
            gameState.players.forEach((player, index) => {
                console.log(`  プレイヤー${index} (${player.name}): `, player.hand.discards);
            });
            if (gameState.gameLog) {
                const discardLogs = gameState.gameLog.filter(log => log.type === 'discard');
                console.log(`🗂️ ゲームログ内の捨て牌: ${discardLogs.length}件`, discardLogs);
            }
            showNotification('捨て牌情報をコンソールに表示', 'info');
        }
        
        // サーバーエラーログ表示
        async function showErrorLogs() {
            try {
                const response = await fetch('/api/logs/error');
                const result = await response.json();
                
                if (result.status === 'OK') {
                    console.log('📋 サーバーエラーログ (最新50行):');
                    console.log('=' .repeat(60));
                    console.log(result.logs || 'エラーログはありません');
                    console.log('=' .repeat(60));
                    showNotification('エラーログをコンソールに表示しました', 'info');
                } else {
                    console.error('エラーログ取得失敗:', result.message);
                    showNotification('エラーログの取得に失敗しました', 'error');
                }
            } catch (error) {
                console.error('エラーログ取得エラー:', error);
                showNotification('エラーログの取得でエラーが発生しました', 'error');
            }
        }

        function clearConsole() {
            console.clear();
            showNotification('コンソールをクリアしました', 'info');
        }

        // 捨て牌座標テスト機能
        function testDiscardCoordinates() {
            console.log('🎯 捨て牌座標テスト開始');
            
            if (!gameState || !gameState.players) {
                showNotification('ゲーム状態が無効です', 'error');
                return;
            }
            
            // 各プレイヤーの捨て牌エリアの座標を確認
            for (let i = 0; i < 4; i++) {
                const discardElement = document.getElementById(`discards${i}`);
                if (discardElement) {
                    const rect = discardElement.getBoundingClientRect();
                    const style = window.getComputedStyle(discardElement);
                    
                    console.log(`📍 プレイヤー${i} 捨て牌エリア座標:`);
                    console.log(`  - 位置: x=${rect.left.toFixed(1)}, y=${rect.top.toFixed(1)}`);
                    console.log(`  - サイズ: width=${rect.width.toFixed(1)}, height=${rect.height.toFixed(1)}`);
                    console.log(`  - CSS: position=${style.position}, transform=${style.transform}`);
                    console.log(`  - 捨て牌数: ${gameState.players[i].hand.discards.length}枚`);
                    
                    // 捨て牌の配置方向をテスト
                    const discards = discardElement.children;
                    if (discards.length > 0) {
                        console.log(`  - 最初の牌位置: x=${discards[0].getBoundingClientRect().left.toFixed(1)}`);
                        if (discards.length > 1) {
                            console.log(`  - 最後の牌位置: x=${discards[discards.length-1].getBoundingClientRect().left.toFixed(1)}`);
                            console.log(`  - 配置方向: ${discards[0].getBoundingClientRect().left < discards[discards.length-1].getBoundingClientRect().left ? '左→右' : '右→左'}`);
                        }
                    }
                    
                    // 視覚的テスト用の一時的ハイライト
                    discardElement.style.border = '3px solid red';
                    setTimeout(() => {
                        discardElement.style.border = '';
                    }, 2000);
                }
            }
            
            // 捨て牌の向きと配置パターンをテスト
            testDiscardRotations();
            showNotification('捨て牌座標をコンソールに出力しました', 'info');
        }
        
        // 捨て牌の回転と配置テスト
        function testDiscardRotations() {
            console.log('🔄 捨て牌回転テスト:');
            
            for (let i = 0; i < 4; i++) {
                const playerName = ['プレイヤー1', 'CPU南', 'CPU西', 'CPU北'][i];
                const expectedRotation = [0, 0, 180, 0][i]; // 期待される回転角度
                const expectedDirection = ['左→右', '上→下', '右→左', '下→上'][i]; // 期待される配置方向
                
                console.log(`  ${playerName} (位置${i}):`);
                console.log(`    - 期待回転: ${expectedRotation}度`);
                console.log(`    - 期待配置: ${expectedDirection}`);
                
                const discardElement = document.getElementById(`discards${i}`);
                if (discardElement && discardElement.children.length > 0) {
                    const firstTile = discardElement.children[0];
                    const style = window.getComputedStyle(firstTile);
                    console.log(`    - 実際CSS: transform=${style.transform}`);
                }
            }
        }
        
        // 捨て牌エリアのクリック可能テスト
        function addDiscardClickTest() {
            for (let i = 0; i < 4; i++) {
                const discardElement = document.getElementById(`discards${i}`);
                if (discardElement) {
                    discardElement.addEventListener('click', function() {
                        console.log(`🖱️ プレイヤー${i}の捨て牌エリアがクリックされました`);
                        showNotification(`プレイヤー${i}の捨て牌エリア`, 'info');
                        
                        // 詳細な捨て牌情報を表示
                        showDiscardDetails(i);
                    });
                }
            }
        }
        
        // 指定プレイヤーの捨て牌詳細表示
        function showDiscardDetails(playerIndex) {
            if (!gameState || !gameState.players[playerIndex]) return;
            
            const player = gameState.players[playerIndex];
            const discards = player.hand.discards;
            
            console.log(`📋 プレイヤー${playerIndex} 捨て牌詳細:`);
            console.log(`  - 総数: ${discards.length}枚`);
            
            discards.forEach((tile, index) => {
                console.log(`  ${index + 1}. ${tile.displayName || tile.unicode} (ID: ${tile.id})`);
            });
            
            if (gameState.lastDiscard && gameState.lastDiscardPlayer === playerIndex) {
                console.log(`  ⭐ 最新捨て牌: ${gameState.lastDiscard.displayName || gameState.lastDiscard.unicode}`);
            }
        }
        
        // 捨て牌更新の監視（updateGameDisplayから呼び出し）
        function trackDiscardUpdates() {
            if (!gameState) return;
            
            const currentDiscardCounts = gameState.players.map(p => p.hand.discards.length);
            
            // 前回と比較して変更があった場合
            if (window.lastDiscardCounts) {
                for (let i = 0; i < 4; i++) {
                    if (currentDiscardCounts[i] !== window.lastDiscardCounts[i]) {
                        const change = currentDiscardCounts[i] - window.lastDiscardCounts[i];
                        // console.log(`🔄 プレイヤー${i} 捨て牌変更: ${window.lastDiscardCounts[i]}枚 → ${currentDiscardCounts[i]}枚 (${change > 0 ? '+' : ''}${change})`);
                        
                        if (change > 0 && gameState.players[i].hand.discards.length > 0) {
                            const latestDiscard = gameState.players[i].hand.discards[gameState.players[i].hand.discards.length - 1];
                            // console.log(`  新しい捨て牌: ${latestDiscard.displayName || latestDiscard.unicode}`);
                        }
                    }
                }
            }
            
            window.lastDiscardCounts = [...currentDiscardCounts];
        }

        // 点数計算テスト
        function testScoreCalculation() {
            console.log('💰 [点数計算テスト] 開始');
            
            const testCases = [
                {
                    name: 'タンヤオのみ（子ツモ）',
                    yaku: [{ name: 'タンヤオ', han: 1, isYakuman: false }],
                    fu: 30,
                    isParent: false,
                    isTsumo: true
                },
                {
                    name: 'リーチ・タンヤオ（子ロン）',
                    yaku: [
                        { name: 'リーチ', han: 1, isYakuman: false },
                        { name: 'タンヤオ', han: 1, isYakuman: false }
                    ],
                    fu: 30,
                    isParent: false,
                    isTsumo: false
                },
                {
                    name: '満貫（子ツモ）',
                    yaku: [
                        { name: 'リーチ', han: 1, isYakuman: false },
                        { name: 'タンヤオ', han: 1, isYakuman: false },
                        { name: 'ドラ', han: 3, isYakuman: false }
                    ],
                    fu: 30,
                    isParent: false,
                    isTsumo: true
                },
                {
                    name: '親満貫（ツモ）',
                    yaku: [
                        { name: 'リーチ', han: 1, isYakuman: false },
                        { name: 'ドラ', han: 4, isYakuman: false }
                    ],
                    fu: 30,
                    isParent: true,
                    isTsumo: true
                }
            ];
            
            testCases.forEach(testCase => {
                console.log(`\n💰 テストケース: ${testCase.name}`);
                console.log(`   役: ${testCase.yaku.map(y => `${y.name}(${y.han}翻)`).join(', ')}`);
                console.log(`   ${testCase.fu}符 ${testCase.isParent ? '親' : '子'} ${testCase.isTsumo ? 'ツモ' : 'ロン'}`);
                
                const totalHan = testCase.yaku.reduce((sum, y) => sum + y.han, 0);
                console.log(`   合計翻数: ${totalHan}翻`);
                
                const expectedScore = calculateExpectedScore(totalHan, testCase.fu, testCase.isParent, testCase.isTsumo);
                console.log(`   期待点数: ${expectedScore}点`);
            });
            
            showNotification('点数計算テストをコンソールで確認してください', 'info');
        }
        
        // 期待点数計算（検証用）
        function calculateExpectedScore(han, fu, isParent, isTsumo) {
            let baseScore;
            
            // 満貫以上判定
            if (han >= 5 || (han >= 4 && fu >= 40) || (han >= 3 && fu >= 70)) {
                baseScore = 2000; // 満貫
            } else if (han >= 6) {
                baseScore = 3000; // 跳満
            } else if (han >= 8) {
                baseScore = 4000; // 倍満
            } else if (han >= 11) {
                baseScore = 6000; // 三倍満
            } else if (han >= 13) {
                baseScore = 8000; // 数え役満
            } else {
                baseScore = fu * Math.pow(2, han + 2);
            }
            
            // 親補正
            if (isParent) {
                baseScore = Math.floor(baseScore * 1.5);
            }
            
            // ツモ/ロン補正（得点計算）
            if (isTsumo) {
                if (isParent) {
                    // 親ツモ：子が全額の1/3ずつ → 3人分合計
                    return Math.ceil(baseScore / 3 / 100) * 300;
                } else {
                    // 子ツモ：親が半額、他の子が1/4ずつ → 合計
                    const parentPay = Math.ceil(baseScore / 2 / 100) * 100;
                    const childPay = Math.ceil(baseScore / 4 / 100) * 200;
                    return parentPay + childPay;
                }
            } else {
                // ロン：放銃者が全額支払い
                return Math.ceil(baseScore / 100) * 100;
            }
        }

        // 役判定テスト機能
        function testYakuAnalysis() {
            console.log('🎰 役判定テスト開始');
            
            if (!gameState || !gameState.players) {
                showNotification('ゲーム状態が無効です', 'error');
                return;
            }
            
            // 各プレイヤーの手牌を分析
            gameState.players.forEach((player, index) => {
                console.log(`🎰 プレイヤー${index} (${player.name}) 手牌分析:`);
                console.log(`  手牌: ${player.hand.tiles.length}枚`);
                console.log(`  メルド: ${player.hand.melds.length}個`);
                console.log(`  リーチ: ${player.hand.riichi ? 'Yes' : 'No'}`);
                console.log(`  捨て牌: ${player.hand.discards.length}枚`);
                
                // 手牌の内容を表示
                if (index === 0) { // プレイヤー1の手牌は見える
                    console.log(`  手牌詳細: ${player.hand.tiles.map(t => t.displayName || t.unicode).join(' ')}`);
                    
                    // 和了形かチェック
                    testWinningHand(player.hand.tiles, player.hand.melds, index);
                    
                    // シャンテン数をテスト（フロントエンドでは簡易計算）
                    const shanten = calculateSimpleShanten(player.hand.tiles, player.hand.melds);
                    console.log(`  推定シャンテン数: ${shanten}`);
                    
                    // 待ち牌の可能性をテスト
                    if (shanten <= 1) {
                        testWaitingTiles(player.hand.tiles);
                    }
                } else {
                    console.log(`  手牌詳細: [非表示] ${player.hand.tiles.length}枚`);
                }
                
                // メルドの詳細
                if (player.hand.melds.length > 0) {
                    console.log(`  メルド詳細:`);
                    player.hand.melds.forEach((meld, meldIndex) => {
                        console.log(`    ${meldIndex + 1}. ${meld.type}: ${meld.tiles.map(t => t.displayName || t.unicode).join(' ')}`);
                    });
                }
                
                console.log(''); // 空行
            });
            
            showNotification('役判定テストを実行しました', 'info');
        }
        
        // 和了形テスト（簡易版）
        function testWinningHand(tiles, melds, playerIndex) {
            if (tiles.length + melds.length * 3 !== 14 && tiles.length + melds.length * 3 !== 13) {
                console.log(`  ⚠️ 牌数異常: ${tiles.length + melds.length * 3}枚`);
                return;
            }
            
            // 七対子チェック
            const isChiitoi = checkChiitoi(tiles);
            if (isChiitoi && tiles.length === 14) {
                console.log(`  🎉 七対子形: 和了可能`);
                simulateYaku(tiles, melds, playerIndex, '七対子');
                return;
            }
            
            // 国士無双チェック
            const isKokushi = checkKokushi(tiles);
            if (isKokushi && tiles.length === 14) {
                console.log(`  🎉 国士無双形: 役満！`);
                simulateYaku(tiles, melds, playerIndex, '国士無双');
                return;
            }
            
            // 標準形チェック（簡易）
            const isStandard = checkStandardForm(tiles, melds);
            if (isStandard) {
                console.log(`  🎉 標準形: 和了可能`);
                simulateYaku(tiles, melds, playerIndex, '標準形');
                return;
            }
            
            console.log(`  ❌ 和了形ではありません`);
        }
        
        // 役のシミュレーション（強化版）
        function simulateYaku(tiles, melds, playerIndex, formType) {
            console.log(`  📊 ${formType}の役分析:`);
            
            // 手牌を強化版フォーマットに変換
            const handForYaku = convertTilesToAdvancedFormat(tiles);
            const meldsForYaku = convertMeldsToAdvancedFormat(melds);
            
            // 強化版役計算を実行
            const yaku = calculateAdvancedYaku(handForYaku, meldsForYaku);
            
            if (yaku.length > 0) {
                const yakuStrings = yaku.map(y => `${y.name}(${y.han >= 13 ? '役満' : y.han + '翻'})`);
                console.log(`    役: ${yakuStrings.join(', ')}`);
                const totalHan = yaku.reduce((sum, y) => sum + y.han, 0);
                console.log(`    合計: ${totalHan >= 13 ? '役満' : totalHan + '翻'}`);
            } else {
                console.log(`    役: なし（役なし）`);
            }
        }
        
        // タイル形式変換関数
        function convertTilesToAdvancedFormat(tiles) {
            return tiles.map(tile => {
                if (tile.honor) {
                    const honorMap = {
                        'white': 'haku', 'green': 'hatsu', 'red': 'chun',
                        'east': 'east', 'south': 'south', 'west': 'west', 'north': 'north'
                    };
                    return { suit: 'honors', type: honorMap[tile.honor] };
                } else {
                    return { suit: tile.suit, rank: tile.rank };
                }
            });
        }
        
        // メルド形式変換関数
        function convertMeldsToAdvancedFormat(melds) {
            return melds.map(meld => ({
                type: meld.type,
                tiles: convertTilesToAdvancedFormat(meld.tiles),
                isConcealed: meld.isConcealed || false
            }));
        }
        
        // 強化版役計算メイン関数
        function calculateAdvancedYaku(hand, meldData = []) {
            const yaku = [];
            
            // グローバルな副露データを設定（一時的）
            const originalMelds = typeof melds !== 'undefined' ? melds : [];
            if (typeof melds === 'undefined') {
                window.melds = meldData;
            }
            
            try {
                // 役満優先判定
                if (checkKokushiAdvanced(hand)) {
                    yaku.push({ name: '国士無双', han: 13 });
                    return yaku;
                }
                if (checkSuuankouAdvanced(hand)) {
                    yaku.push({ name: '四暗刻', han: 13 });
                    return yaku;
                }
                if (checkDaisangenAdvanced(hand)) {
                    yaku.push({ name: '大三元', han: 13 });
                    return yaku;
                }
                if (checkTsuuiisouAdvanced(hand)) {
                    yaku.push({ name: '字一色', han: 13 });
                    return yaku;
                }
                if (checkChinroutouAdvanced(hand)) {
                    yaku.push({ name: '清老頭', han: 13 });
                    return yaku;
                }
                if (checkRyuuiisouAdvanced(hand)) {
                    yaku.push({ name: '緑一色', han: 13 });
                    return yaku;
                }
                if (checkChuurenAdvanced(hand)) {
                    yaku.push({ name: '九蓮宝燈', han: 13 });
                    return yaku;
                }
                if (checkSuukantsuAdvanced(hand)) {
                    yaku.push({ name: '四槓子', han: 13 });
                    return yaku;
                }

                // 特殊形判定
                if (checkChiitoiAdvanced(hand)) {
                    yaku.push({ name: '七対子', han: 2 });
                    if (checkTanyaoAdvanced(hand)) yaku.push({ name: 'タンヤオ', han: 1 });
                    if (checkChinitsuAdvanced(hand)) yaku.push({ name: '清一色', han: 6 });
                    if (checkHonitsuAdvanced(hand)) yaku.push({ name: '混一色', han: 3 });
                    return yaku;
                }

                // 通常役判定
                if (checkTanyaoAdvanced(hand)) yaku.push({ name: 'タンヤオ', han: 1 });
                
                // 一盃口・二盃口
                if (checkRyanpeikouAdvanced(hand)) {
                    yaku.push({ name: '二盃口', han: 3 });
                } else if (checkIipeikouAdvanced(hand)) {
                    yaku.push({ name: '一盃口', han: 1 });
                }
                
                // ピンフ
                if (checkPinfuAdvanced(hand)) {
                    yaku.push({ name: 'ピンフ', han: 1 });
                }
                
                // 役牌
                const yakuhaiDetails = getYakuhaiDetailsAdvanced(hand, meldData);
                yakuhaiDetails.forEach(yakuhai => {
                    yaku.push(yakuhai);
                });
                
                // その他の役
                if (checkToitoiAdvanced(hand)) yaku.push({ name: '対々和', han: 2 });
                if (checkSanankouAdvanced(hand)) yaku.push({ name: '三暗刻', han: 2 });
                if (checkSanshokuAdvanced(hand)) yaku.push({ name: '三色同順', han: 2 });
                if (checkIttsuAdvanced(hand)) yaku.push({ name: '一気通貫', han: 2 });
                if (checkChantaAdvanced(hand)) yaku.push({ name: '混全帯么九', han: 2 });
                if (checkJunchanAdvanced(hand)) yaku.push({ name: '純全帯么九', han: 3 });
                if (checkHonroutouAdvanced(hand)) yaku.push({ name: '混老頭', han: 2 });
                if (checkShousangenAdvanced(hand)) yaku.push({ name: '小三元', han: 2 });
                if (checkHonitsuAdvanced(hand)) yaku.push({ name: '混一色', han: 3 });
                if (checkChinitsuAdvanced(hand)) yaku.push({ name: '清一色', han: 6 });
                
                return yaku;
            } finally {
                // グローバル状態を復元
                if (typeof melds !== 'undefined' && originalMelds !== melds) {
                    window.melds = originalMelds;
                }
            }
        }
        
        // タイルカウント取得（強化版）
        function getTileCountsAdvanced(hand) {
            const counts = {};
            hand.forEach(tile => {
                const key = getTileKeyAdvanced(tile);
                counts[key] = (counts[key] || 0) + 1;
            });
            return counts;
        }
        
        // タイルキー取得（強化版）
        function getTileKeyAdvanced(tile) {
            if (tile.suit === 'honors') {
                return `honors_${tile.type}`;
            } else {
                return `${tile.suit}_${tile.rank}`;
            }
        }
        
        // === 役満判定関数群 ===
        
        function checkKokushiAdvanced(hand) {
            if (hand.length !== 14) return false;
            const yaochuTiles = [
                'man_1', 'man_9', 'pin_1', 'pin_9', 'sou_1', 'sou_9',
                'honors_east', 'honors_south', 'honors_west', 'honors_north',
                'honors_haku', 'honors_hatsu', 'honors_chun'
            ];
            
            const counts = getTileCountsAdvanced(hand);
            let pairFound = false;
            
            // 各么九牌が1枚以上あるかチェック
            for (const yaochu of yaochuTiles) {
                if (!counts[yaochu]) return false;
                if (counts[yaochu] === 2) {
                    if (pairFound) return false; // 雀頭は1つのみ
                    pairFound = true;
                } else if (counts[yaochu] !== 1) {
                    return false;
                }
            }
            
            return pairFound;
        }
        
        function checkSuuankouAdvanced(hand) {
            const counts = getTileCountsAdvanced(hand);
            const triplets = Object.values(counts).filter(count => count >= 3).length;
            const pairs = Object.values(counts).filter(count => count === 2).length;
            return triplets === 4 && pairs === 1;
        }
        
        function checkDaisangenAdvanced(hand) {
            const dragons = ['honors_haku', 'honors_hatsu', 'honors_chun'];
            const counts = getTileCountsAdvanced(hand);
            return dragons.every(dragon => counts[dragon] >= 3);
        }
        
        function checkTsuuiisouAdvanced(hand) {
            return hand.every(tile => tile.suit === 'honors');
        }
        
        function checkChinroutouAdvanced(hand) {
            return hand.every(tile => {
                if (tile.suit === 'honors') return false;
                return tile.rank === 1 || tile.rank === 9;
            });
        }
        
        function checkRyuuiisouAdvanced(hand) {
            const greenTiles = ['sou_2', 'sou_3', 'sou_4', 'sou_6', 'sou_8', 'honors_hatsu'];
            return hand.every(tile => {
                const key = getTileKeyAdvanced(tile);
                return greenTiles.includes(key);
            });
        }
        
        function checkChuurenAdvanced(hand) {
            const suits = ['man', 'pin', 'sou'];
            return suits.some(suit => {
                const suitTiles = hand.filter(tile => tile.suit === suit);
                if (suitTiles.length !== 14) return false;
                
                const counts = {};
                suitTiles.forEach(tile => {
                    counts[tile.rank] = (counts[tile.rank] || 0) + 1;
                });
                
                return counts[1] >= 3 && counts[9] >= 3 && 
                       [2,3,4,5,6,7,8].every(rank => counts[rank] >= 1);
            });
        }
        
        function checkSuukantsuAdvanced(hand) {
            const counts = getTileCountsAdvanced(hand);
            const quads = Object.values(counts).filter(count => count === 4).length;
            return quads === 4;
        }
        
        // === 特殊形判定関数群 ===
        
        function checkChiitoiAdvanced(hand) {
            if (hand.length !== 14) return false;
            const counts = getTileCountsAdvanced(hand);
            const values = Object.values(counts);
            return values.length === 7 && values.every(count => count === 2);
        }
        
        // === 通常役判定関数群 ===
        
        function checkTanyaoAdvanced(hand) {
            return hand.every(tile => {
                if (tile.suit === 'honors') return false;
                return tile.rank >= 2 && tile.rank <= 8;
            });
        }
        
        function checkPinfuAdvanced(hand) {
            if (checkChiitoiAdvanced(hand)) return false;
            
            const structure = analyzeHandStructureAdvanced(hand);
            if (!structure || !structure.isComplete) return false;
            
            // 4つの順子と1つの雀頭
            if (structure.sequences.length !== 4) return false;
            if (structure.triplets.length > 0 || structure.quads.length > 0) return false;
            if (structure.pairs.length !== 1) return false;
            
            // 雀頭が役牌でないこと
            const pairKey = structure.pairs[0];
            if (typeof pairKey === 'string' && pairKey.startsWith('honors')) return false;
            
            return true;
        }
        
        function checkIipeikouAdvanced(hand) {
            if (checkChiitoiAdvanced(hand)) return false;
            
            const structure = analyzeHandStructureAdvanced(hand);
            if (!structure || !structure.isComplete) return false;
            if (structure.sequences.length < 2) return false;
            
            // 順子を正規化して比較
            const sequencePatterns = structure.sequences.map(seq => {
                return seq.sort().join(',');
            });
            
            const patternCounts = {};
            sequencePatterns.forEach(pattern => {
                patternCounts[pattern] = (patternCounts[pattern] || 0) + 1;
            });
            
            // 同じ順子が2つ以上あるかチェック
            return Object.values(patternCounts).some(count => count >= 2);
        }
        
        function checkRyanpeikouAdvanced(hand) {
            if (checkChiitoiAdvanced(hand)) return false;
            
            const groups = analyzeHandStructureAdvanced(hand);
            if (!groups) return false;
            
            const sequences = groups.sequences.map(seq => seq.sort().join(''));
            const counts = {};
            
            sequences.forEach(seq => {
                counts[seq] = (counts[seq] || 0) + 1;
            });
            
            const pairs = Object.values(counts).filter(count => count >= 2);
            return pairs.length >= 2;
        }
        
        function getYakuhaiDetailsAdvanced(hand, meldData = []) {
            const counts = getTileCountsAdvanced(hand);
            const yakuhaiList = [];
            
            console.log('🔍 役牌判定:', {
                hand: hand,
                meldData: meldData,
                counts: counts
            });
            
            // 副露からもカウント追加
            meldData.forEach(meld => {
                if (meld.type === 'pon' || meld.type === 'kan' || meld.type === 'ankan') {
                    const key = getTileKeyAdvanced(meld.tiles[0]);
                    const meldCount = meld.tiles.length;
                    counts[key] = (counts[key] || 0) + meldCount;
                    console.log('🔍 メルドから役牌カウント追加:', {
                        key: key,
                        meldCount: meldCount,
                        newCount: counts[key]
                    });
                }
            });
            
            // 三元牌チェック
            const dragonNames = { haku: '白', hatsu: '發', chun: '中' };
            Object.entries(dragonNames).forEach(([type, name]) => {
                const key = `honors_${type}`;
                if (counts[key] >= 3) {
                    yakuhaiList.push({ name: `役牌(${name})`, han: 1, type: 'dragon' });
                }
            });
            
            // 場風チェック
            const gameWindKey = `honors_${gameSettings.gameWind}`;
            if (counts[gameWindKey] >= 3) {
                const windNames = { east: '東', south: '南', west: '西', north: '北' };
                yakuhaiList.push({ 
                    name: `場風(${windNames[gameSettings.gameWind]})`, 
                    han: 1, 
                    type: 'gameWind' 
                });
            }
            
            // 自風チェック
            const playerWindKey = `honors_${gameSettings.playerWind}`;
            if (counts[playerWindKey] >= 3) {
                const windNames = { east: '東', south: '南', west: '西', north: '北' };
                yakuhaiList.push({ 
                    name: `自風(${windNames[gameSettings.playerWind]})`, 
                    han: 1, 
                    type: 'playerWind' 
                });
            }
            
            return yakuhaiList;
        }
        
        function checkToitoiAdvanced(hand) {
            if (checkChiitoiAdvanced(hand)) return false;
            
            const counts = getTileCountsAdvanced(hand);
            const triplets = Object.values(counts).filter(count => count >= 3).length;
            const pairs = Object.values(counts).filter(count => count === 2).length;
            return triplets === 4 && pairs === 1;
        }
        
        function checkSanankouAdvanced(hand) {
            const counts = getTileCountsAdvanced(hand);
            const triplets = Object.values(counts).filter(count => count >= 3).length;
            return triplets >= 3;
        }
        
        function checkSanshokuAdvanced(hand) {
            if (checkChiitoiAdvanced(hand)) return false;
            
            // 三色同順の判定：3つの色で同じ順子
            for (let rank = 1; rank <= 7; rank++) {
                const manSeq = [`man_${rank}`, `man_${rank+1}`, `man_${rank+2}`];
                const pinSeq = [`pin_${rank}`, `pin_${rank+1}`, `pin_${rank+2}`];
                const souSeq = [`sou_${rank}`, `sou_${rank+1}`, `sou_${rank+2}`];
                
                const counts = getTileCountsAdvanced(hand);
                
                if (manSeq.every(tile => counts[tile] >= 1) &&
                    pinSeq.every(tile => counts[tile] >= 1) &&
                    souSeq.every(tile => counts[tile] >= 1)) {
                    return true;
                }
            }
            return false;
        }
        
        function checkIttsuAdvanced(hand) {
            // 一気通貫：同一色で1-9の順子
            const suits = ['man', 'pin', 'sou'];
            return suits.some(suit => {
                const seq1 = [`${suit}_1`, `${suit}_2`, `${suit}_3`];
                const seq2 = [`${suit}_4`, `${suit}_5`, `${suit}_6`];
                const seq3 = [`${suit}_7`, `${suit}_8`, `${suit}_9`];
                
                const counts = getTileCountsAdvanced(hand);
                
                return seq1.every(tile => counts[tile] >= 1) &&
                       seq2.every(tile => counts[tile] >= 1) &&
                       seq3.every(tile => counts[tile] >= 1);
            });
        }
        
        function checkChantaAdvanced(hand) {
            if (checkChiitoiAdvanced(hand)) return false;
            
            // 混全帯么九：各メンツに端牌か字牌が含まれる
            return hand.every(tile => {
                if (tile.suit === 'honors') return true;
                return tile.rank === 1 || tile.rank === 9;
            });
        }
        
        function checkJunchanAdvanced(hand) {
            if (checkChiitoiAdvanced(hand)) return false;
            
            // 純全帯么九：各メンツに端牌（1,9）が含まれ、字牌なし
            const hasHonors = hand.some(tile => tile.suit === 'honors');
            if (hasHonors) return false;
            
            return hand.every(tile => tile.rank === 1 || tile.rank === 9);
        }
        
        function checkHonroutouAdvanced(hand) {
            // 混老頭：端牌と字牌のみ
            return hand.every(tile => {
                if (tile.suit === 'honors') return true;
                return tile.rank === 1 || tile.rank === 9;
            });
        }
        
        function checkShousangenAdvanced(hand) {
            const dragons = ['honors_haku', 'honors_hatsu', 'honors_chun'];
            const counts = getTileCountsAdvanced(hand);
            
            let tripletCount = 0;
            let pairCount = 0;
            
            dragons.forEach(dragon => {
                if (counts[dragon] >= 3) tripletCount++;
                if (counts[dragon] === 2) pairCount++;
            });
            
            return tripletCount === 2 && pairCount === 1;
        }
        
        function checkHonitsuAdvanced(hand) {
            // 混一色：1つの数牌と字牌のみ
            const suits = new Set(hand.map(tile => tile.suit));
            const hasHonors = suits.has('honors');
            const numberSuits = [...suits].filter(suit => suit !== 'honors');
            
            return hasHonors && numberSuits.length === 1;
        }
        
        function checkChinitsuAdvanced(hand) {
            // 清一色：1つの数牌のみ
            const suits = new Set(hand.map(tile => tile.suit));
            return suits.size === 1 && !suits.has('honors');
        }
        
        // 手牌構造分析（簡易版）
        function analyzeHandStructureAdvanced(hand) {
            if (hand.length !== 14) return null;
            
            // 簡易実装：基本的な面子構成を判定
            const counts = getTileCountsAdvanced(hand);
            
            let pairs = 0;
            let triplets = 0;
            let sequences = 0;
            
            // 対子と刻子をカウント
            Object.values(counts).forEach(count => {
                if (count === 2) pairs++;
                else if (count >= 3) triplets++;
            });
            
            // 順子の推定（簡易）
            const remainingTiles = hand.length - (pairs * 2) - (triplets * 3);
            sequences = Math.floor(remainingTiles / 3);
            
            const isComplete = (pairs === 1 && triplets + sequences === 4);
            
            return {
                isComplete,
                pairs: pairs > 0 ? ['pair'] : [],
                triplets: Array(triplets).fill(['triplet']),
                sequences: Array(sequences).fill(['sequence']),
                quads: []
            };
        }
        
        // 簡易シャンテン計算
        function calculateSimpleShanten(tiles, melds) {
            if (tiles.length + melds.length * 3 === 14) return -1; // 和了形
            if (tiles.length + melds.length * 3 !== 13) return 8; // 異常
            
            // 超簡易計算（実際の計算は複雑）
            const tileCounts = {};
            tiles.forEach(tile => {
                const key = tile.honor || `${tile.suit}_${tile.rank}`;
                tileCounts[key] = (tileCounts[key] || 0) + 1;
            });
            
            let pairs = 0;
            let sets = 0;
            
            Object.values(tileCounts).forEach(count => {
                if (count >= 3) sets++;
                else if (count === 2) pairs++;
            });
            
            // 非常に簡易的な推定
            const currentSets = sets + melds.length;
            const neededSets = 4;
            const neededPairs = 1;
            
            return Math.max(0, (neededSets - currentSets) * 2 + Math.max(0, neededPairs - pairs));
        }
        
        // 待ち牌テスト（簡易版）
        function testWaitingTiles(tiles) {
            console.log(`  🎯 可能性のある待ち牌:`);
            
            // 超簡易的な待ち牌推定
            const suits = ['man', 'pin', 'sou'];
            const possibleWaits = [];
            
            suits.forEach(suit => {
                for (let rank = 1; rank <= 9; rank++) {
                    // この牌を加えて和了になるかチェック（超簡易）
                    const testTile = { suit, rank, unicode: '', displayName: `${suit}${rank}`, id: 0, isRed: false };
                    possibleWaits.push(`${suit}${rank}`);
                }
            });
            
            // 字牌
            ['東', '南', '西', '北', '白', '發', '中'].forEach(honor => {
                possibleWaits.push(honor);
            });
            
            console.log(`    推定待ち: ${possibleWaits.slice(0, 5).join(', ')}... (簡易推定)`);
        }
        
        // ヘルパー関数
        function checkChiitoi(tiles) {
            if (tiles.length !== 14) return false;
            const counts = {};
            tiles.forEach(tile => {
                const key = tile.honor || `${tile.suit}_${tile.rank}`;
                counts[key] = (counts[key] || 0) + 1;
            });
            
            const values = Object.values(counts);
            return values.length === 7 && values.every(count => count === 2);
        }
        
        function checkKokushi(tiles) {
            if (tiles.length !== 14) return false;
            // 簡易国士判定（実際はより複雑）
            const yaochuCount = tiles.filter(t => 
                t.honor || t.rank === 1 || t.rank === 9
            ).length;
            return yaochuCount >= 12;
        }
        
        function checkStandardForm(tiles, melds) {
            // 超簡易標準形判定
            const totalTiles = tiles.length + melds.length * 3;
            return totalTiles === 14 || totalTiles === 13;
        }

        // 通知表示
        function showNotification(message, type = 'success') {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.className = `notification ${type}`;
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        // =====================================
        // アニメーション・エフェクト関数
        // =====================================

        // 勝利セレブレーション
        function triggerWinCelebration(data) {
            console.log('🎊 勝利セレブレーション開始');
            
            // 自分の勝利の場合
            if (data.winner === 0) {
                // 手牌エリアにセレブレーションエフェクト
                const handArea = document.getElementById('hand0');
                if (handArea) {
                    handArea.classList.add('win-celebration');
                    setTimeout(() => {
                        handArea.classList.remove('win-celebration');
                    }, 800);
                }
                
                // 紙吹雪エフェクト
                createConfetti();
                
                // 勝利音効果
                soundManager.playSound('win');
            }
            
            // 背景フラッシュエフェクト
            flashBackground('#4CAF50', 500);
        }

        // 役満特別セレブレーション
        function triggerYakumanCelebration() {
            console.log('🌟 役満セレブレーション開始');
            
            // より派手な紙吹雪
            for (let i = 0; i < 3; i++) {
                setTimeout(() => createConfetti(), i * 200);
            }
            
            // 黄金の背景フラッシュ
            flashBackground('#FFD700', 1000);
            
            // 画面全体の祝賀エフェクト
            const body = document.body;
            body.style.animation = 'winCelebration 1s ease-in-out';
            setTimeout(() => {
                body.style.animation = '';
            }, 1000);
        }

        // リーチエフェクト
        function triggerRiichiEffect(playerId) {
            console.log(`🔥 リーチエフェクト開始: プレイヤー${playerId}`);
            
            if (playerId === 0) {
                // 自分のリーチ - 手牌に赤い光エフェクト
                const handArea = document.getElementById('hand0');
                if (handArea) {
                    handArea.classList.add('riichi-glow');
                    setTimeout(() => {
                        handArea.classList.remove('riichi-glow');
                    }, 3000);
                }
            }
            
            // 背景フラッシュ（赤）
            flashBackground('#FF5722', 300);
            
            // リーチ音効果
            soundManager.playSound('riichi');
        }

        // 紙吹雪生成
        function createConfetti() {
            const container = document.createElement('div');
            container.className = 'confetti-container';
            document.body.appendChild(container);
            
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57'];
            
            for (let i = 0; i < 50; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = Math.random() * 100 + '%';
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.animationDelay = Math.random() * 2 + 's';
                confetti.style.animationDuration = (Math.random() * 2 + 2) + 's';
                container.appendChild(confetti);
            }
            
            // 3秒後にコンテナを削除
            setTimeout(() => {
                document.body.removeChild(container);
            }, 3000);
        }

        // 三家和用花火エフェクト
        function createFireworks() {
            const container = document.createElement('div');
            container.className = 'fireworks-container';
            container.style.position = 'fixed';
            container.style.top = '0';
            container.style.left = '0';
            container.style.width = '100%';
            container.style.height = '100%';
            container.style.pointerEvents = 'none';
            container.style.zIndex = '9999';
            document.body.appendChild(container);
            
            const colors = ['#ff1744', '#ff9800', '#ffc107', '#4caf50', '#2196f3', '#9c27b0'];
            
            // 複数の花火を作成
            for (let firework = 0; firework < 5; firework++) {
                setTimeout(() => {
                    const centerX = Math.random() * window.innerWidth;
                    const centerY = Math.random() * (window.innerHeight * 0.6) + window.innerHeight * 0.2;
                    
                    // 花火の火花を作成
                    for (let i = 0; i < 30; i++) {
                        const spark = document.createElement('div');
                        spark.style.position = 'absolute';
                        spark.style.width = '4px';
                        spark.style.height = '4px';
                        spark.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                        spark.style.borderRadius = '50%';
                        spark.style.left = centerX + 'px';
                        spark.style.top = centerY + 'px';
                        
                        const angle = (i / 30) * 2 * Math.PI;
                        const distance = 150 + Math.random() * 100;
                        const endX = centerX + Math.cos(angle) * distance;
                        const endY = centerY + Math.sin(angle) * distance;
                        
                        spark.style.transition = 'all 1.5s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                        container.appendChild(spark);
                        
                        // アニメーション開始
                        setTimeout(() => {
                            spark.style.transform = `translate(${endX - centerX}px, ${endY - centerY}px)`;
                            spark.style.opacity = '0';
                        }, 10);
                    }
                }, firework * 400);
            }
            
            // 4秒後にコンテナを削除
            setTimeout(() => {
                document.body.removeChild(container);
            }, 4000);
        }

        // 流し満貫用波エフェクト
        function createWaveEffect() {
            const container = document.createElement('div');
            container.className = 'wave-container';
            container.style.position = 'fixed';
            container.style.top = '0';
            container.style.left = '0';
            container.style.width = '100%';
            container.style.height = '100%';
            container.style.pointerEvents = 'none';
            container.style.zIndex = '9999';
            container.style.overflow = 'hidden';
            document.body.appendChild(container);
            
            // 複数の波を作成
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const wave = document.createElement('div');
                    wave.style.position = 'absolute';
                    wave.style.bottom = '-50px';
                    wave.style.left = '-50%';
                    wave.style.width = '200%';
                    wave.style.height = '200px';
                    wave.style.background = `linear-gradient(135deg, rgba(76, 175, 80, 0.3), rgba(139, 195, 74, 0.3))`;
                    wave.style.borderRadius = '50%';
                    wave.style.transform = 'translateY(100%)';
                    wave.style.transition = 'all 2s ease-out';
                    container.appendChild(wave);
                    
                    // アニメーション開始
                    setTimeout(() => {
                        wave.style.transform = 'translateY(-100%)';
                        wave.style.opacity = '0';
                    }, 10);
                }, i * 300);
            }
            
            // 4秒後にコンテナを削除
            setTimeout(() => {
                document.body.removeChild(container);
            }, 4000);
        }

        // テンパイ表示更新システム
        function updateTenpaiDisplay(gameState) {
            if (!gameState || !gameState.players) return;
            
            gameState.players.forEach((player, index) => {
                const playerElement = document.querySelector(`#player${index}`);
                if (!playerElement) return;
                
                // 既存のテンパイ表示を削除
                const existingTenpai = playerElement.querySelector('.tenpai-indicator');
                if (existingTenpai) {
                    existingTenpai.remove();
                }
                
                // テンパイ情報がある場合のみ表示
                if (player.tenpaiInfo && player.tenpaiInfo.isTenpai) {
                    const tenpaiIndicator = createTenpaiIndicator(player.tenpaiInfo, index);
                    playerElement.appendChild(tenpaiIndicator);
                }
            });
        }
        
        // テンパイインジケーター作成
        function createTenpaiIndicator(tenpaiInfo, playerIndex) {
            const indicator = document.createElement('div');
            indicator.className = 'tenpai-indicator';
            indicator.style.cssText = `
                position: absolute;
                top: 5px;
                right: 5px;
                background: linear-gradient(45deg, #ff6b6b, #ee5a24);
                color: white;
                padding: 6px 12px;
                border-radius: 16px;
                font-size: 14px;
                font-weight: bold;
                box-shadow: 0 4px 8px rgba(0,0,0,0.4);
                border: 2px solid rgba(255,255,255,0.3);
                z-index: 100;
                animation: tenpai-pulse 2s infinite;
                min-width: 60px;
                text-align: center;
            `;
            
            // テンパイ情報のテキスト作成
            let text = 'テンパイ';
            
            // フリテンの場合は表示を変更
            if (tenpaiInfo.isFuriten) {
                text = 'フリテン';
                indicator.style.background = 'linear-gradient(45deg, #666, #444)';
            }
            
            // 待ちの種類表示（プレイヤー自身の場合のみ詳細表示）
            if (playerIndex === 0 && tenpaiInfo.waitType) {
                const waitTypeText = getWaitTypeDisplayName(tenpaiInfo.waitType);
                text += ` (${waitTypeText})`;
            }
            
            indicator.textContent = text;
            
            // 待ち牌表示（プレイヤー自身の場合のみ）- 正式版
            if (playerIndex === 0 && tenpaiInfo.waitingTiles && tenpaiInfo.waitingTiles.length > 0) {
                const waitingTilesDisplay = document.createElement('div');
                waitingTilesDisplay.style.cssText = `
                    margin-top: 4px;
                    font-size: 12px;
                    opacity: 1;
                    background: rgba(0,0,0,0.7);
                    padding: 2px 6px;
                    border-radius: 4px;
                    border: 1px solid rgba(255,215,0,0.3);
                `;
                
                // 待ち牌のシンボル表示
                const waitingSymbols = tenpaiInfo.waitingTiles
                    .map(tile => getTileDisplaySymbol(tile))
                    .join(' ');
                
                // 待ち枚数計算（実際の残り枚数を考慮）
                const totalWaitingCount = calculateActualWaitingCount(tenpaiInfo.waitingTiles);
                
                waitingTilesDisplay.innerHTML = `
                    <div style="color: #FFD700; font-weight: bold;">
                        待ち: ${waitingSymbols}
                    </div>
                    <div style="font-size: 10px; color: #AAA;">
                        ${tenpaiInfo.waitingTiles.length}種${totalWaitingCount}枚
                    </div>
                `;
                indicator.appendChild(waitingTilesDisplay);
            }
            
            return indicator;
        }
        
        // 待ちタイプの表示名
        function getWaitTypeDisplayName(waitType) {
            const typeMap = {
                'tanki': '単騎',
                'ryanmen': '両面',
                'kanchan': '嵌張',
                'penchan': '辺張',
                'shanpon': 'シャンポン',
                'sanmenchan': '三面張',
                'chiitoi': '七対子',
                'kokushi': '国士無双',
                'multiple': '多面待ち',
                'none': 'なし'
            };
            return typeMap[waitType] || waitType;
        }

        // 牌表示用シンボル取得（正式版）
        function getTileDisplaySymbol(tile) {
            if (!tile) return '?';
            
            if (tile.suit === 'honors') {
                const honorMap = {
                    east: '🀀', south: '🀁', west: '🀂', north: '🀃',
                    haku: '🀆', hatsu: '🀅', chun: '🀄'
                };
                return honorMap[tile.type] || tile.type;
            } else {
                // 数牌の場合は数字とスートシンボルを表示
                const suitMap = {
                    man: '🀇', pin: '🀙', sou: '🀐'
                };
                const baseSymbol = suitMap[tile.suit];
                if (baseSymbol && tile.rank >= 1 && tile.rank <= 9) {
                    // Unicodeの麻雀牌は連続した番号なので計算で求める
                    const offset = tile.rank - 1;
                    return String.fromCodePoint(baseSymbol.codePointAt(0) + offset);
                }
                return `${tile.rank}${tile.suit}`;
            }
        }

        // 数字を漢字に変換
        function numberToKanji(num) {
            const kanjiNumbers = {
                1: '一', 2: '二', 3: '三', 4: '四', 5: '五',
                6: '六', 7: '七', 8: '八', 9: '九'
            };
            return kanjiNumbers[num] || num;
        }

        // 牌の表示名取得（Unicode優先）
        function getTileDisplayName(tile) {
            if (!tile) return '🀫';
            
            try {
                // Unicodeが利用可能な場合は最優先
                if (tile.unicode) {
                    return tile.unicode;
                }
                
                // 字牌（役牌・風牌）の処理
                if (tile.suit === 'honors' || tile.honor) {
                    const honorUnicodes = {
                        east: '🀀', south: '🀁', west: '西', north: '🀃',
                        haku: '🀆', hatsu: '🀅', chun: '🀄',
                        white: '🀆', green: '🀅', red: '🀄'  // 英語表記にも対応
                    };
                    const key = tile.type || tile.honor;
                    return honorUnicodes[key] || key;
                }
                
                // 数牌（萬子・筒子・索子）の処理
                if (tile.suit && (tile.rank || tile.number)) {
                    const suitUnicodes = {
                        man: ['🀇', '🀈', '🀉', '🀊', '🀋', '🀌', '🀍', '🀎', '🀏'],
                        pin: ['🀙', '🀚', '🀛', '🀜', '🀝', '🀞', '🀟', '🀠', '🀡'],
                        sou: ['🀐', '🀑', '🀒', '🀓', '🀔', '🀕', '🀖', '🀗', '🀘']
                    };
                    
                    const rank = tile.rank || tile.number;
                    if (suitUnicodes[tile.suit] && rank >= 1 && rank <= 9) {
                        return suitUnicodes[tile.suit][rank - 1];
                    }
                }
                
                // フォールバック
                return tile.displayName || `${tile.suit}${tile.rank}` || '🀫';
                
            } catch (error) {
                console.error('getTileDisplayName error:', error, tile);
                return tile.displayName || tile.unicode || `${tile.suit}${tile.rank}` || '?';
            }
        }

        // 牌の詳細表示名取得（従来版も残す）
        function getTileDetailedName(tile) {
            if (!tile) return '不明';
            
            if (tile.suit === 'honors') {
                const honorMap = {
                    east: '東', south: '南', west: '西', north: '北',
                    haku: '白', hatsu: '發', chun: '中'
                };
                return honorMap[tile.type] || tile.type;
            } else {
                const suitMap = {
                    man: '萬', pin: '筒', sou: '索'
                };
                return `${tile.rank}${suitMap[tile.suit] || tile.suit}`;
            }
        }

        // 実際の待ち枚数計算（河や手牌を考慮）
        function calculateActualWaitingCount(waitingTiles) {
            if (!gameState || !gameState.discardPiles) {
                // ゲーム状態が取得できない場合は簡易計算
                return waitingTiles.length * 4;
            }

            let totalCount = 0;
            
            waitingTiles.forEach(waitTile => {
                let availableCount = 4; // 各牌は最大4枚
                
                // 全プレイヤーの河をチェック
                gameState.discardPiles.forEach(discardPile => {
                    if (discardPile && Array.isArray(discardPile)) {
                        discardPile.forEach(discardedTile => {
                            if (tilesEqual(discardedTile, waitTile)) {
                                availableCount--;
                            }
                        });
                    }
                });
                
                // 自分の手牌をチェック（既に持っている分を除外）
                if (gameState.players && gameState.players[0] && gameState.players[0].hand) {
                    const myTiles = gameState.players[0].hand.tiles || [];
                    myTiles.forEach(myTile => {
                        if (tilesEqual(myTile, waitTile)) {
                            availableCount--;
                        }
                    });
                }
                
                totalCount += Math.max(0, availableCount);
            });
            
            return totalCount;
        }

        // 牌の比較関数
        function tilesEqual(tile1, tile2) {
            if (!tile1 || !tile2) return false;
            
            if (tile1.suit !== tile2.suit) return false;
            
            if (tile1.suit === 'honors') {
                return tile1.type === tile2.type;
            } else {
                return tile1.rank === tile2.rank;
            }
        }

        // 背景フラッシュエフェクト
        function flashBackground(color, duration) {
            const flash = document.createElement('div');
            flash.style.position = 'fixed';
            flash.style.top = '0';
            flash.style.left = '0';
            flash.style.width = '100%';
            flash.style.height = '100%';
            flash.style.backgroundColor = color;
            flash.style.opacity = '0.3';
            flash.style.pointerEvents = 'none';
            flash.style.zIndex = '9998';
            flash.style.transition = `opacity ${duration}ms ease-out`;
            
            document.body.appendChild(flash);
            
            // フェードアウト
            setTimeout(() => {
                flash.style.opacity = '0';
                setTimeout(() => {
                    document.body.removeChild(flash);
                }, duration);
            }, 50);
        }

        // 牌の配牌アニメーション
        function animateTileDistribution() {
            const handArea = document.getElementById('hand0');
            const tiles = handArea.querySelectorAll('.tile');
            
            tiles.forEach((tile, index) => {
                tile.style.opacity = '0';
                tile.style.transform = 'scale(0.8)';
                
                setTimeout(() => {
                    tile.style.transition = 'all 0.3s ease-out';
                    tile.style.opacity = '1';
                    tile.style.transform = 'scale(1)';
                }, index * 100);
            });
        }

        // 打牌アニメーション
        function animateDiscard(tileElement) {
            if (!tileElement) return;
            
            tileElement.style.transition = 'all 0.4s cubic-bezier(0.4, 0, 0.2, 1)';
            tileElement.style.transform = 'scale(0.9)';
            tileElement.style.opacity = '0.7';
            
            setTimeout(() => {
                tileElement.style.transform = 'scale(1)';
                tileElement.style.opacity = '1';
            }, 400);
        }

        // リーチ表示更新関数
        function updateRiichiDisplay(playerElement, player, playerIndex) {
            // 既存のリーチ表示を削除
            const existingRiichiIndicator = playerElement.querySelector('.riichi-indicator');
            if (existingRiichiIndicator) {
                existingRiichiIndicator.remove();
            }
            
            // リーチ中の場合は表示を追加
            if (player.hand && player.hand.riichi) {
                const riichiIndicator = document.createElement('div');
                riichiIndicator.className = 'riichi-indicator';
                riichiIndicator.innerHTML = '🔥 リーチ';
                riichiIndicator.style.cssText = `
                    position: absolute;
                    top: -15px;
                    right: -15px;
                    background: linear-gradient(135deg, #ff4444, #cc0000);
                    color: white;
                    padding: 5px 10px;
                    border-radius: 15px;
                    font-size: 0.8rem;
                    font-weight: bold;
                    border: 2px solid #fff;
                    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
                    animation: riichiGlow 2s ease-in-out infinite;
                    z-index: 100;
                `;
                playerElement.appendChild(riichiIndicator);
                console.log(`🔥 リーチ表示追加: プレイヤー${playerIndex} (${player.name})`);
            }
        }

        // キーボードショートカット
        document.addEventListener('keydown', function(e) {
            if (e.key === 'd' || e.key === 'D') drawTile();
            if (e.key === 's' || e.key === 'S') discardSelected();
            if (e.key === 'a' || e.key === 'A') executeAI();
            if (e.key === 'r' || e.key === 'R') requestGameState();
            if (e.key === 'n' || e.key === 'N') newGame();
            if (e.key === 'q' || e.key === 'Q') toggleDebug();
        });

        // Socket.IOによるリアルタイム通信を使用するため、定期ポーリングは不要
        // ただし、接続確認のために60秒ごとにpingを送信
        setInterval(() => {
            if (isConnected) {
                socket.emit('ping');
            }
        }, 60000);
    </script>
</body>
</html>