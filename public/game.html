<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>éº»é›€ã‚²ãƒ¼ãƒ  - ãƒ—ãƒ¬ã‚¤ãƒ†ã‚¹ãƒˆ</title>
    <style>
        body {
            font-family: 'Hiragino Sans', 'Yu Gothic', 'Meiryo', sans-serif;
            margin: 20px;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            min-height: 100vh;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        h1 { 
            text-align: center;
            color: #FFD700;
            margin-bottom: 30px;
        }
        .section {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            margin: 20px 0;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        .button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        .button:hover { background: #45a049; }
        .button:disabled { 
            background: #666; 
            cursor: not-allowed; 
        }
        .game-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        .player-info {
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }
        .current-player {
            border: 2px solid #FFD700;
        }
        .tiles {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin: 10px 0;
        }
        .tile {
            background: #f0f0f0;
            color: #333;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            border: 2px solid transparent;
        }
        .tile:hover {
            background: #FFD700;
            border-color: #333;
        }
        .tile.selected {
            background: #ff6b6b;
            color: white;
        }
        .debug-mode .player-info {
            border: 2px solid #00ff00;
        }
        .debug-info {
            background: rgba(0,255,0,0.1);
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            font-size: 12px;
        }
        .waiting-tiles {
            color: #ffff00;
            font-weight: bold;
        }
        .possible-melds {
            color: #ff9500;
            font-weight: bold;
        }
        .status {
            margin: 10px 0;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 5px;
        }
        .log {
            background: #000;
            color: #0f0;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            max-height: 200px;
            overflow-y: auto;
        }
        input[type="text"] {
            padding: 8px;
            margin: 5px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ€„ éº»é›€ã‚²ãƒ¼ãƒ  - ãƒ—ãƒ¬ã‚¤ãƒ†ã‚¹ãƒˆ</h1>
        
        <!-- ã‚²ãƒ¼ãƒ ä½œæˆã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
        <div class="section">
            <h3>ğŸ® æ–°ã—ã„ã‚²ãƒ¼ãƒ ä½œæˆ</h3>
            <div>
                <input type="text" id="player1" placeholder="ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1" value="ã‚ãªãŸ">
                <input type="text" id="player2" placeholder="ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼2" value="CPU1">
                <input type="text" id="player3" placeholder="ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼3" value="CPU2">
                <input type="text" id="player4" placeholder="ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼4" value="CPU3">
                <button class="button" onclick="createGame()">ã‚²ãƒ¼ãƒ ä½œæˆ</button>
            </div>
        </div>

        <!-- ç¾åœ¨ã®ã‚²ãƒ¼ãƒ æƒ…å ± -->
        <div class="section" id="gameSection" style="display: none;">
            <h3>ğŸ¯ ç¾åœ¨ã®ã‚²ãƒ¼ãƒ </h3>
            <div class="status" id="gameStatus"></div>
            
            <div class="game-info">
                <div>
                    <h4>ğŸ² ã‚²ãƒ¼ãƒ æ“ä½œ</h4>
                    <button class="button" onclick="refreshGameState()">çŠ¶æ…‹æ›´æ–°</button>
                    <button class="button" onclick="testDiscard()" id="discardBtn" disabled>é¸æŠç‰Œã‚’æ¨ç‰Œ</button>
                    <button class="button" onclick="manualDraw()" id="drawBtn" disabled>ğŸ¯ ãƒ„ãƒ¢</button>
                    <button class="button" onclick="toggleDebugMode()" id="debugBtn">ğŸ” ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰</button>
                    
                    <!-- é³´ãå‡¦ç†ãƒœã‚¿ãƒ³ -->
                    <div id="meldButtons" style="display: none; margin-top: 10px;">
                        <button class="button" onclick="processMeld('chi')" id="chiBtn" disabled>ğŸ”— ãƒãƒ¼</button>
                        <button class="button" onclick="processMeld('pon')" id="ponBtn" disabled>âš« ãƒãƒ³</button>
                        <button class="button" onclick="processMeld('kan')" id="kanBtn" disabled>ğŸŸ© ã‚«ãƒ³</button>
                        <button class="button" onclick="passMeld()" id="passBtn" disabled>âŒ ãƒ‘ã‚¹</button>
                    </div>
                    <div>é¸æŠä¸­ã®ç‰Œ: <span id="selectedTile">ãªã—</span></div>
                    <div>æ“ä½œãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼: <span id="selectedPlayer">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1</span></div>
                    <div>ãƒ¢ãƒ¼ãƒ‰: <span id="currentMode">é€šå¸¸è¡¨ç¤º</span></div>
                </div>
                
                <div>
                    <h4>ğŸ“Š ã‚²ãƒ¼ãƒ æƒ…å ±</h4>
                    <div id="gameInfo"></div>
                </div>
            </div>

            <!-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æƒ…å ± -->
            <div id="playersInfo"></div>
        </div>

        <!-- ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚²ãƒ¼ãƒ ä¸€è¦§ -->
        <div class="section">
            <h3>ğŸ“‹ ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚²ãƒ¼ãƒ ä¸€è¦§</h3>
            <button class="button" onclick="loadActiveGames()">ä¸€è¦§æ›´æ–°</button>
            <div id="activeGames"></div>
        </div>

        <!-- ãƒ­ã‚° -->
        <div class="section">
            <h3>ğŸ“ ãƒ­ã‚°</h3>
            <div class="log" id="log"></div>
        </div>
    </div>

    <script>
        let currentGameId = null;
        let currentGameState = null;
        let selectedTileId = null;
        let selectedPlayerId = null;
        let debugMode = false;
        let availableMelds = [];
        let lastDiscardInfo = null;

        function log(message) {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            logDiv.innerHTML += `[${timestamp}] ${message}<br>`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        // æ–°ã—ã„ã‚²ãƒ¼ãƒ ä½œæˆ
        async function createGame() {
            const playerNames = [
                document.getElementById('player1').value,
                document.getElementById('player2').value,
                document.getElementById('player3').value,
                document.getElementById('player4').value
            ];

            try {
                const response = await fetch('/api/game/create', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ playerNames })
                });

                const result = await response.json();
                
                if (result.status === 'OK') {
                    currentGameId = result.data.gameId;
                    currentGameState = result.data.gameState;
                    
                    log(`âœ… ã‚²ãƒ¼ãƒ ä½œæˆæˆåŠŸ: ${currentGameId}`);
                    document.getElementById('gameSection').style.display = 'block';
                    updateGameDisplay();
                } else {
                    log(`âŒ ã‚²ãƒ¼ãƒ ä½œæˆå¤±æ•—: ${result.message}`);
                }
            } catch (error) {
                log(`âŒ ã‚¨ãƒ©ãƒ¼: ${error.message}`);
            }
        }

        // ã‚²ãƒ¼ãƒ çŠ¶æ…‹æ›´æ–°
        async function refreshGameState() {
            if (!currentGameId) return;

            try {
                const endpoint = debugMode ? `/api/game/${currentGameId}/debug` : `/api/game/${currentGameId}`;
                const response = await fetch(endpoint);
                const result = await response.json();
                
                if (result.status === 'OK') {
                    currentGameState = result.data.gameState || result.data;
                    if (debugMode && result.data.playerDetails) {
                        // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰æ™‚ã¯è©³ç´°æƒ…å ±ã‚‚ä¿å­˜
                        currentGameState.debugDetails = result.data;
                    }
                    updateGameDisplay();
                    log(`ğŸ”„ ã‚²ãƒ¼ãƒ çŠ¶æ…‹æ›´æ–°å®Œäº† ${debugMode ? '(ãƒ‡ãƒãƒƒã‚°æƒ…å ±å«ã‚€)' : ''}`);
                } else {
                    log(`âŒ çŠ¶æ…‹å–å¾—å¤±æ•—: ${result.message}`);
                }
            } catch (error) {
                log(`âŒ ã‚¨ãƒ©ãƒ¼: ${error.message}`);
            }
        }

        // æ¨ç‰Œãƒ†ã‚¹ãƒˆ
        async function testDiscard() {
            if (!currentGameId || !selectedTileId) return;

            // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰æ™‚ã¯é¸æŠã•ã‚ŒãŸãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã€é€šå¸¸ãƒ¢ãƒ¼ãƒ‰ã¯ç¾åœ¨ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
            let targetPlayerId;
            let targetPlayer;
            
            if (debugMode && selectedPlayerId !== null) {
                targetPlayerId = selectedPlayerId;
                targetPlayer = currentGameState.players[selectedPlayerId];
            } else {
                targetPlayerId = currentGameState.currentPlayer;
                targetPlayer = currentGameState.players[currentGameState.currentPlayer];
            }

            const selectedTile = targetPlayer.hand.tiles.find(tile => tile.id === selectedTileId);

            if (!selectedTile) {
                log(`âŒ é¸æŠã•ã‚ŒãŸç‰ŒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`);
                return;
            }

            // æ‰‹ç‰Œæšæ•°ãƒã‚§ãƒƒã‚¯ï¼ˆ14æšã®æ™‚ã®ã¿æ¨ç‰Œå¯èƒ½ï¼‰
            if (targetPlayer.hand.tiles.length !== 14) {
                log(`âŒ ${targetPlayer.name}ã®æ‰‹ç‰Œã¯${targetPlayer.hand.tiles.length}æšã§ã™ã€‚æ¨ç‰Œã¯14æšã®æ™‚ã®ã¿å¯èƒ½ã§ã™`);
                return;
            }

            // ã‚¿ãƒ¼ãƒ³å¤–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ“ä½œãƒã‚§ãƒƒã‚¯ï¼ˆãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰æ™‚ã¯è¨±å¯ï¼‰
            if (!debugMode && targetPlayerId !== currentGameState.currentPlayer) {
                log(`âŒ ${targetPlayer.name}ã®ã‚¿ãƒ¼ãƒ³ã§ã¯ã‚ã‚Šã¾ã›ã‚“`);
                return;
            }

            try {
                const response = await fetch(`/api/game/${currentGameId}/action`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        type: 'discard',
                        playerId: targetPlayer.id,
                        tile: selectedTile
                    })
                });

                const result = await response.json();
                
                if (result.status === 'OK') {
                    currentGameState = result.data.gameState;
                    selectedTileId = null;
                    selectedPlayerId = null;
                    updateGameDisplay();
                    log(`ğŸ€„ ${targetPlayer.name}ã®æ¨ç‰ŒæˆåŠŸ: ${selectedTile.displayName}`);
                    
                    // é³´ãæ©Ÿä¼šã‚’ãƒã‚§ãƒƒã‚¯
                    if (debugMode) {
                        checkMeldOpportunities();
                    }
                } else {
                    log(`âŒ æ¨ç‰Œå¤±æ•—: ${result.message}`);
                }
            } catch (error) {
                log(`âŒ ã‚¨ãƒ©ãƒ¼: ${error.message}`);
            }
        }

        // ç‰Œé¸æŠ
        function selectTile(tileId, displayName, playerId = null) {
            selectedTileId = tileId;
            selectedPlayerId = playerId;
            document.getElementById('selectedTile').textContent = displayName;
            
            // æ¨ç‰Œãƒœã‚¿ãƒ³ã®çŠ¶æ…‹æ›´æ–°ï¼ˆ14æšã®æ™‚ã®ã¿æœ‰åŠ¹ï¼‰
            if (currentGameState && playerId !== null) {
                const player = currentGameState.players[playerId];
                document.getElementById('discardBtn').disabled = player.hand.tiles.length !== 14;
            } else {
                document.getElementById('discardBtn').disabled = false;
            }
            
            // é¸æŠçŠ¶æ…‹ã®è¦‹ãŸç›®æ›´æ–°
            document.querySelectorAll('.tile').forEach(tile => tile.classList.remove('selected'));
            document.querySelector(`[data-tile-id="${tileId}"]`).classList.add('selected');
            
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¡¨ç¤ºæ›´æ–°
            if (playerId !== null && currentGameState) {
                const playerName = currentGameState.players[playerId].name;
                document.getElementById('selectedPlayer').textContent = playerName;
                log(`ğŸ¯ ${playerName}ã®ç‰Œé¸æŠ: ${displayName}`);
            } else {
                log(`ğŸ¯ ç‰Œé¸æŠ: ${displayName}`);
            }
        }

        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼é¸æŠ
        function selectPlayer(playerId, playerName) {
            selectedPlayerId = playerId;
            selectedTileId = null;
            document.getElementById('selectedPlayer').textContent = playerName;
            document.getElementById('selectedTile').textContent = 'ãªã—';
            document.getElementById('discardBtn').disabled = true;
            
            // ãƒ„ãƒ¢ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹æ›´æ–°
            updateDrawButtonState();
            
            // é¸æŠçŠ¶æ…‹ãƒªã‚»ãƒƒãƒˆ
            document.querySelectorAll('.tile').forEach(tile => tile.classList.remove('selected'));
            
            log(`ğŸ‘¤ æ“ä½œãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å¤‰æ›´: ${playerName}`);
        }

        // ãƒ„ãƒ¢ãƒœã‚¿ãƒ³çŠ¶æ…‹æ›´æ–°
        function updateDrawButtonState() {
            const drawBtn = document.getElementById('drawBtn');
            
            // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰æ™‚ã®ã¿è¡¨ç¤º
            if (!debugMode) {
                drawBtn.style.display = 'none';
                drawBtn.disabled = true;
                return;
            }
            
            drawBtn.style.display = 'inline-block';
            
            if (!currentGameState) {
                drawBtn.disabled = true;
                return;
            }
            
            const targetPlayerId = selectedPlayerId !== null ? selectedPlayerId : currentGameState.currentPlayer;
            const targetPlayer = currentGameState.players[targetPlayerId];
            
            // æ‰‹ç‰ŒãŒ13æšã®æ™‚ã®ã¿ãƒ„ãƒ¢å¯èƒ½
            if (targetPlayer && targetPlayer.hand.tiles.length === 13) {
                drawBtn.disabled = false;
                drawBtn.textContent = `ğŸ¯ ${targetPlayer.name}ãƒ„ãƒ¢`;
            } else {
                drawBtn.disabled = true;
                drawBtn.textContent = 'ğŸ¯ ãƒ„ãƒ¢';
            }
        }

        // æ‰‹å‹•ãƒ„ãƒ¢
        async function manualDraw() {
            if (!currentGameId || !debugMode) return;

            const targetPlayerId = selectedPlayerId !== null ? selectedPlayerId : currentGameState.currentPlayer;
            const targetPlayer = currentGameState.players[targetPlayerId];

            try {
                const response = await fetch(`/api/game/${currentGameId}/draw`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        playerId: targetPlayer.id
                    })
                });

                const result = await response.json();
                
                if (result.status === 'OK') {
                    currentGameState = result.data.gameState;
                    updateGameDisplay();
                    log(`ğŸ€„ ${targetPlayer.name}ãŒãƒ„ãƒ¢: ${result.data.tile.displayName}`);
                } else {
                    log(`âŒ ãƒ„ãƒ¢å¤±æ•—: ${result.message}`);
                }
            } catch (error) {
                log(`âŒ ã‚¨ãƒ©ãƒ¼: ${error.message}`);
            }
        }

        // ã‚²ãƒ¼ãƒ ç”»é¢æ›´æ–°
        function updateGameDisplay() {
            if (!currentGameState) return;

            // ã‚²ãƒ¼ãƒ çŠ¶æ…‹è¡¨ç¤º
            const gameStatus = document.getElementById('gameStatus');
            gameStatus.innerHTML = `
                <strong>ã‚²ãƒ¼ãƒ ID:</strong> ${currentGameState.id}<br>
                <strong>ãƒ•ã‚§ãƒ¼ã‚º:</strong> ${currentGameState.phase}<br>
                <strong>ç¾åœ¨ã®ã‚¿ãƒ¼ãƒ³:</strong> ${currentGameState.players[currentGameState.currentPlayer].name}<br>
                <strong>æ®‹ã‚Šç‰Œæ•°:</strong> ${currentGameState.remainingTiles}
            `;

            // ã‚²ãƒ¼ãƒ æƒ…å ±è¡¨ç¤º
            const gameInfo = document.getElementById('gameInfo');
            gameInfo.innerHTML = `
                <strong>å±€:</strong> æ±${currentGameState.round.roundNumber}å±€<br>
                <strong>æœ¬å ´:</strong> ${currentGameState.round.honbaCount}<br>
                <strong>ãƒªãƒ¼ãƒæ£’:</strong> ${currentGameState.round.riichiSticks}<br>
                <strong>ãƒ‰ãƒ©:</strong> ${currentGameState.doraIndicators.map(tile => tile.unicode).join(' ')}
                ${debugMode && currentGameState.debugDetails && currentGameState.debugDetails.wallInfo ? `
                    <br><strong>ğŸ” ç‰Œå±±æƒ…å ±:</strong><br>
                    <strong>å¼•ãæ¸ˆã¿:</strong> ${currentGameState.debugDetails.wallInfo.totalDrawn}æš<br>
                    <strong>æ®‹ã‚Šæšæ•°:</strong> ${currentGameState.debugDetails.wallInfo.remainingTiles}æš<br>
                    <strong>ãƒ‰ãƒ©æšæ•°:</strong> ${currentGameState.debugDetails.wallInfo.doraCount}æš
                ` : ''}
            `;

            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æƒ…å ±è¡¨ç¤º
            const playersInfo = document.getElementById('playersInfo');
            playersInfo.innerHTML = currentGameState.players.map((player, index) => {
                const isCurrentPlayer = index === currentGameState.currentPlayer;
                const isCurrentUser = index === 0; // ä»®ã«æœ€åˆã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¨ã™ã‚‹
                const showHand = debugMode || isCurrentUser;
                const canOperate = debugMode || isCurrentUser;
                
                return `
                    <div class="player-info ${isCurrentPlayer ? 'current-player' : ''}">
                        <h4 ${debugMode ? `onclick="selectPlayer(${index}, '${player.name}')" style="cursor: pointer; color: #FFD700;"` : ''}>${player.name} (${player.wind}é¢¨) ${player.isDealer ? 'ğŸ‘‘' : ''} ${isCurrentPlayer ? 'ğŸ¯' : ''} ${debugMode ? 'ğŸ‘†' : ''}</h4>
                        <div><strong>ç‚¹æ•°:</strong> ${player.score}ç‚¹</div>
                        <div><strong>æ‰‹ç‰Œ:</strong> ${player.hand.tiles.length}æš</div>
                        ${showHand ? `
                            <div class="tiles">
                                ${player.hand.tiles.map(tile => 
                                    `<div class="tile" data-tile-id="${tile.id}" ${canOperate ? `onclick="selectTile(${tile.id}, '${tile.displayName}', ${index})"` : ''}>${tile.unicode} ${tile.displayName}</div>`
                                ).join('')}
                            </div>
                        ` : `
                            <div class="tiles">
                                ${Array(player.hand.tiles.length).fill('ğŸ€«').join(' ')} (${player.hand.tiles.length}æš)
                            </div>
                        `}
                        ${debugMode ? `
                            <div class="debug-info">
                                <div><strong>ğŸ” ãƒ‡ãƒãƒƒã‚°æƒ…å ±:</strong></div>
                                <div>æ‰‹ç‰Œè©³ç´°: ${player.hand.tiles.map(t => t.displayName).join(', ')}</div>
                                <div>çŠ¶æ…‹: ${player.status}</div>
                                ${currentGameState.debugDetails && currentGameState.debugDetails.playerDetails ? `
                                    <div>ç‰Œç¨®é¡æ•°: ${currentGameState.debugDetails.playerDetails[index].handAnalysis.uniqueTiles}ç¨®é¡</div>
                                    <div>è¬å­: ${currentGameState.debugDetails.playerDetails[index].handAnalysis.suitDistribution.man}æš</div>
                                    <div>ç­’å­: ${currentGameState.debugDetails.playerDetails[index].handAnalysis.suitDistribution.pin}æš</div>
                                    <div>ç´¢å­: ${currentGameState.debugDetails.playerDetails[index].handAnalysis.suitDistribution.sou}æš</div>
                                    <div>å­—ç‰Œ: ${currentGameState.debugDetails.playerDetails[index].handAnalysis.suitDistribution.honor}æš</div>
                                    <div>è´ç‰Œåˆ¤å®š: ${currentGameState.debugDetails.playerDetails[index].handAnalysis.isReadyHand ? 'å¯èƒ½æ€§ã‚ã‚Š' : 'ãªã—'}</div>
                                ` : ''}
                                <div class="waiting-tiles">å¾…ã¡ç‰Œ: ${getWaitingTiles(player).join(', ') || 'ãªã—'}</div>
                                <div class="possible-melds">å¯èƒ½ãªé³´ã: ${getPossibleMelds(player).join(', ') || 'ãªã—'}</div>
                            </div>
                        ` : ''}
                        ${player.hand.discards.length > 0 ? `
                            <div><strong>æ¨ç‰Œ:</strong> ${player.hand.discards.map(tile => tile.unicode).join(' ')}</div>
                        ` : ''}
                        ${player.hand.melds && player.hand.melds.length > 0 ? `
                            <div><strong>é³´ã:</strong> ${player.hand.melds.map(meld => 
                                `[${meld.type.toUpperCase()}: ${meld.tiles.map(t => t.unicode).join('')}]`
                            ).join(' ')}</div>
                        ` : ''}
                    </div>
                `;
            }).join('');

            // æ¨ç‰Œãƒœã‚¿ãƒ³ã®çŠ¶æ…‹æ›´æ–°
            const currentPlayer = currentGameState.players[currentGameState.currentPlayer];
            const isUserTurn = currentGameState.currentPlayer === 0;
            
            // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰æ™‚ã¯å¸¸ã«è¡¨ç¤ºã€é€šå¸¸ãƒ¢ãƒ¼ãƒ‰ã¯è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³ã®ã¿è¡¨ç¤º
            if (debugMode) {
                document.getElementById('discardBtn').style.display = 'inline-block';
            } else {
                document.getElementById('discardBtn').style.display = isUserTurn ? 'inline-block' : 'none';
            }
            
            // ãƒ„ãƒ¢ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹æ›´æ–°
            updateDrawButtonState();
        }

        // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚²ãƒ¼ãƒ ä¸€è¦§å–å¾—
        async function loadActiveGames() {
            try {
                const response = await fetch('/api/games');
                const result = await response.json();
                
                if (result.status === 'OK') {
                    const activeGamesDiv = document.getElementById('activeGames');
                    if (result.data.totalSessions === 0) {
                        activeGamesDiv.innerHTML = '<p>ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚²ãƒ¼ãƒ ã¯ã‚ã‚Šã¾ã›ã‚“</p>';
                    } else {
                        activeGamesDiv.innerHTML = result.data.sessions.map(session => `
                            <div style="margin: 10px 0; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 5px;">
                                <strong>ID:</strong> ${session.gameId}<br>
                                <strong>ãƒ•ã‚§ãƒ¼ã‚º:</strong> ${session.phase}<br>
                                <strong>ç¾åœ¨ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼:</strong> ${session.currentPlayer}<br>
                                <strong>ä½œæˆæ™‚åˆ»:</strong> ${new Date(session.createdAt).toLocaleString()}
                            </div>
                        `).join('');
                    }
                    log(`ğŸ“‹ ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚²ãƒ¼ãƒ : ${result.data.totalSessions}å€‹`);
                } else {
                    log(`âŒ ã‚²ãƒ¼ãƒ ä¸€è¦§å–å¾—å¤±æ•—: ${result.message}`);
                }
            } catch (error) {
                log(`âŒ ã‚¨ãƒ©ãƒ¼: ${error.message}`);
            }
        }

        // ãƒ‡ãƒãƒƒã‚°ç”¨ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
        function getWaitingTiles(player) {
            // ç°¡æ˜“çš„ãªå¾…ã¡ç‰Œåˆ¤å®šï¼ˆå®Ÿéš›ã¯ã‚ˆã‚Šè¤‡é›‘ãªå®Ÿè£…ãŒå¿…è¦ï¼‰
            const tiles = player.hand.tiles;
            if (tiles.length % 3 !== 1) return [];
            
            // TODO: å®Ÿéš›ã®å¾…ã¡ç‰Œè¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯
            return ['ä»®å®Ÿè£…'];
        }
        
        function getPossibleMelds(player) {
            // ç°¡æ˜“çš„ãªé³´ãå¯èƒ½åˆ¤å®š
            const melds = [];
            
            // TODO: å®Ÿéš›ã®é³´ãåˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯
            if (currentGameState && currentGameState.lastDiscard) {
                const lastDiscard = currentGameState.lastDiscard;
                
                // ãƒãƒ³åˆ¤å®šï¼ˆåŒã˜ç‰ŒãŒ2æšä»¥ä¸Šï¼‰
                const sameCount = player.hand.tiles.filter(t => 
                    t.suit === lastDiscard.suit && t.rank === lastDiscard.rank && t.honor === lastDiscard.honor
                ).length;
                if (sameCount >= 2) {
                    melds.push('ãƒãƒ³');
                }
                
                // ãƒãƒ¼åˆ¤å®šï¼ˆé †å­ã®å¯èƒ½æ€§ã€ç°¡æ˜“ç‰ˆï¼‰
                if (lastDiscard.suit && lastDiscard.rank) {
                    const suit = lastDiscard.suit;
                    const rank = lastDiscard.rank;
                    const hasNeighbors = player.hand.tiles.some(t => 
                        t.suit === suit && Math.abs(t.rank - rank) <= 2
                    );
                    if (hasNeighbors) {
                        melds.push('ãƒãƒ¼');
                    }
                }
            }
            
            return melds;
        }

        // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ
        async function toggleDebugMode() {
            debugMode = !debugMode;
            document.getElementById('currentMode').textContent = debugMode ? 'ğŸ” ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰' : 'é€šå¸¸è¡¨ç¤º';
            document.getElementById('debugBtn').textContent = debugMode ? 'ğŸ‘ï¸ é€šå¸¸ãƒ¢ãƒ¼ãƒ‰' : 'ğŸ” ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰';
            
            // ã‚µãƒ¼ãƒãƒ¼ã«ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰è¨­å®šã‚’é€ä¿¡
            if (currentGameId) {
                try {
                    const response = await fetch(`/api/game/${currentGameId}/debug`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ enabled: debugMode })
                    });
                    
                    const result = await response.json();
                    if (result.status !== 'OK') {
                        log(`âŒ ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰è¨­å®šå¤±æ•—: ${result.message}`);
                    }
                } catch (error) {
                    log(`âŒ ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰è¨­å®šã‚¨ãƒ©ãƒ¼: ${error.message}`);
                }
            }
            
            if (debugMode) {
                document.body.classList.add('debug-mode');
                log('ğŸ” ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ ON - å…¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ“ä½œå¯èƒ½');
            } else {
                document.body.classList.remove('debug-mode');
                log('ğŸ‘ï¸ é€šå¸¸ãƒ¢ãƒ¼ãƒ‰ ON - è‡ªåˆ†ã®æ‰‹ç‰Œã®ã¿è¡¨ç¤º');
                // é¸æŠçŠ¶æ…‹ãƒªã‚»ãƒƒãƒˆ
                selectedPlayerId = null;
                selectedTileId = null;
                document.getElementById('selectedPlayer').textContent = 'ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼1';
                document.getElementById('selectedTile').textContent = 'ãªã—';
                document.getElementById('discardBtn').disabled = true;
            }
            
            if (currentGameState) {
                updateGameDisplay();
            }
        }

        // é³´ãå‡¦ç†é–¢æ•°
        async function processMeld(meldType) {
            if (!currentGameId || !lastDiscardInfo || availableMelds.length === 0) {
                log(`âŒ é³´ãã§ãã¾ã›ã‚“: æƒ…å ±ä¸è¶³`);
                return;
            }

            const targetPlayerId = selectedPlayerId !== null ? selectedPlayerId : currentGameState.currentPlayer;
            const targetPlayer = currentGameState.players[targetPlayerId];
            
            // æŒ‡å®šã•ã‚ŒãŸã‚¿ã‚¤ãƒ—ã®é³´ããŒå¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
            const availableMeld = availableMelds.find(m => m.type === meldType);
            if (!availableMeld) {
                log(`âŒ ${meldType}ã¯ã§ãã¾ã›ã‚“`);
                return;
            }

            try {
                const response = await fetch(`/api/game/${currentGameId}/action`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        type: meldType,
                        playerId: targetPlayer.id,
                        tile: lastDiscardInfo.tile,
                        meld: availableMeld
                    })
                });

                const result = await response.json();
                
                if (result.status === 'OK') {
                    currentGameState = result.data.gameState;
                    updateGameDisplay();
                    hideMeldButtons();
                    log(`ğŸ”— ${targetPlayer.name}ãŒ${meldType}ã—ã¾ã—ãŸ`);
                } else {
                    log(`âŒ ${meldType}å¤±æ•—: ${result.message}`);
                }
            } catch (error) {
                log(`âŒ ã‚¨ãƒ©ãƒ¼: ${error.message}`);
            }
        }

        // é³´ããƒ‘ã‚¹
        async function passMeld() {
            if (!currentGameId || !lastDiscardInfo) return;

            const targetPlayerId = selectedPlayerId !== null ? selectedPlayerId : currentGameState.currentPlayer;
            const targetPlayer = currentGameState.players[targetPlayerId];

            try {
                const response = await fetch(`/api/game/${currentGameId}/action`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        type: 'pass',
                        playerId: targetPlayer.id
                    })
                });

                const result = await response.json();
                
                if (result.status === 'OK') {
                    currentGameState = result.data.gameState;
                    updateGameDisplay();
                    hideMeldButtons();
                    log(`âŒ ${targetPlayer.name}ãŒãƒ‘ã‚¹ã—ã¾ã—ãŸ`);
                } else {
                    log(`âŒ ãƒ‘ã‚¹å¤±æ•—: ${result.message}`);
                }
            } catch (error) {
                log(`âŒ ã‚¨ãƒ©ãƒ¼: ${error.message}`);
            }
        }

        // é³´ããƒœã‚¿ãƒ³è¡¨ç¤º
        function showMeldButtons(melds, discardInfo) {
            availableMelds = melds;
            lastDiscardInfo = discardInfo;
            
            const meldButtonsDiv = document.getElementById('meldButtons');
            meldButtonsDiv.style.display = 'block';
            
            // å„ãƒœã‚¿ãƒ³ã®æœ‰åŠ¹/ç„¡åŠ¹çŠ¶æ…‹ã‚’è¨­å®š
            document.getElementById('chiBtn').disabled = !melds.some(m => m.type === 'chi');
            document.getElementById('ponBtn').disabled = !melds.some(m => m.type === 'pon');
            document.getElementById('kanBtn').disabled = !melds.some(m => m.type === 'kan');
            document.getElementById('passBtn').disabled = false;
            
            log(`ğŸ”— é³´ãå¯èƒ½: ${melds.map(m => m.type).join(', ')}`);
        }

        // é³´ããƒœã‚¿ãƒ³éè¡¨ç¤º
        function hideMeldButtons() {
            document.getElementById('meldButtons').style.display = 'none';
            availableMelds = [];
            lastDiscardInfo = null;
        }

        // é³´ãæ©Ÿä¼šãƒã‚§ãƒƒã‚¯
        async function checkMeldOpportunities() {
            if (!currentGameId || !currentGameState || !currentGameState.lastDiscard) {
                return;
            }

            try {
                const response = await fetch(`/api/game/${currentGameId}/melds`);
                const result = await response.json();
                
                if (result.status === 'OK' && result.data.opportunities.length > 0) {
                    const opportunities = result.data.opportunities;
                    log(`ğŸ”— é³´ãæ©Ÿä¼šç™ºè¦‹: ${opportunities.length}äººãŒé³´ãå¯èƒ½`);
                    
                    // ç¾åœ¨é¸æŠä¸­ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒé³´ãå¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
                    const targetPlayerId = selectedPlayerId !== null ? selectedPlayerId : currentGameState.currentPlayer;
                    const targetPlayerIdStr = `player_${targetPlayerId}`;
                    
                    const playerOpportunity = opportunities.find(opp => opp.playerId === targetPlayerIdStr);
                    if (playerOpportunity) {
                        showMeldButtons(playerOpportunity.possibleMelds, {
                            tile: currentGameState.lastDiscard,
                            fromPlayer: currentGameState.lastDiscardPlayer
                        });
                    } else {
                        // ä»–ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒé³´ãå¯èƒ½ãªå ´åˆã®é€šçŸ¥
                        const playerNames = opportunities.map(opp => opp.playerName).join(', ');
                        log(`ğŸ’¡ ${playerNames}ãŒé³´ãå¯èƒ½ã§ã™`);
                    }
                }
            } catch (error) {
                log(`âŒ é³´ãæ©Ÿä¼šãƒã‚§ãƒƒã‚¯ã‚¨ãƒ©ãƒ¼: ${error.message}`);
            }
        }

        // åˆæœŸåŒ–
        log('ğŸ® éº»é›€ã‚²ãƒ¼ãƒ ãƒ†ã‚¹ãƒˆãƒšãƒ¼ã‚¸åˆæœŸåŒ–å®Œäº†');
        loadActiveGames();
    </script>
</body>
</html>