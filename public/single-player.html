<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üÄÑ ‰∏Ä‰∫∫Áî®È∫ªÈõÄ„Éá„Éê„ÉÉ„Ç∞„ÉÑ„Éº„É´</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700;900&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Sans JP', sans-serif;
            background: linear-gradient(135deg, #0f4c75, #3282b8, #bbe1fa);
            min-height: 100vh;
            color: white;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 32px;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .header p {
            font-size: 16px;
            opacity: 0.8;
        }

        .game-area {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
            margin-bottom: 20px;
        }

        .main-area {
            background: rgba(0,0,0,0.3);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .info-panel {
            background: rgba(0,0,0,0.4);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .hand-area {
            margin-bottom: 30px;
        }

        .hand-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #FFD700;
        }

        .hand-tiles {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            min-height: 100px;
            padding: 15px;
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
            border: 2px dashed rgba(255,255,255,0.3);
        }

        .tile {
            width: 50px;
            height: 70px;
            background: linear-gradient(145deg, #ffffff, #f0f2f5);
            border: 2px solid #2c3e50;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 6px rgba(0,0,0,0.2);
            position: relative;
        }

        .tile:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.3);
        }

        .tile.selected {
            background: linear-gradient(145deg, #FFD700, #FFA500);
            transform: translateY(-8px);
            box-shadow: 0 8px 16px rgba(255,215,0,0.4);
        }

        .tile.man { border-color: #e74c3c; }
        .tile.pin { border-color: #3498db; }
        .tile.sou { border-color: #27ae60; }
        .tile.honors { border-color: #9b59b6; }

        .tile-symbol {
            font-size: 24px;
            font-weight: bold;
            color: #2c3e50;
        }

        .tile.man .tile-symbol { color: #e74c3c; }
        .tile.pin .tile-symbol { color: #3498db; }
        .tile.sou .tile-symbol { color: #27ae60; }
        .tile.honors .tile-symbol { color: #9b59b6; }

        .tile-suit {
            font-size: 10px;
            color: #7f8c8d;
            margin-top: 2px;
        }

        .available-tiles {
            margin-bottom: 30px;
        }

        .tile-selector {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(45px, 1fr));
            gap: 5px;
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
        }

        .available-tile {
            width: 40px;
            height: 55px;
            background: linear-gradient(145deg, #ffffff, #f0f2f5);
            border: 1px solid #2c3e50;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 18px;
        }

        .available-tile:hover {
            background: linear-gradient(145deg, #e8f4f8, #d1ecf1);
            transform: scale(1.1);
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
            text-align: center;
        }

        .btn-primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(45deg, #f093fb, #f5576c);
            color: white;
            box-shadow: 0 4px 8px rgba(240, 147, 251, 0.3);
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(240, 147, 251, 0.4);
        }

        .info-section {
            margin-bottom: 25px;
        }

        .info-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #FFD700;
            border-bottom: 1px solid rgba(255,215,0,0.3);
            padding-bottom: 5px;
        }

        .status-display {
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #3498db;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .status-item:last-child {
            margin-bottom: 0;
        }

        .waiting-tiles {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
        }

        .waiting-tile {
            background: rgba(255,215,0,0.2);
            border: 1px solid #FFD700;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 18px;
        }

        .yaku-list {
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #e74c3c;
            max-height: 200px;
            overflow-y: auto;
        }

        .yaku-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .yaku-item:last-child {
            border-bottom: none;
        }

        .debug-info {
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 10px;
            font-family: monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
        }

        .meld-analysis {
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
            line-height: 1.4;
        }

        .meld-option {
            margin-bottom: 8px;
            padding: 4px 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            border-left: 3px solid #3498db;
        }

        .meld-option.pon { border-left-color: #e74c3c; }
        .meld-option.chi { border-left-color: #f39c12; }
        .meld-option.kan { border-left-color: #9b59b6; }
        .meld-option.ankan { border-left-color: #27ae60; }

        .melds-display {
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
            max-height: 150px;
            overflow-y: auto;
            line-height: 1.4;
        }

        .winning-tiles-analysis {
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
            line-height: 1.4;
        }

        .winning-tile-item {
            margin-bottom: 8px;
            padding: 6px 10px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            border-left: 3px solid #27ae60;
        }

        .winning-tile-header {
            font-weight: bold;
            color: #FFD700;
            margin-bottom: 4px;
        }

        .winning-tile-details {
            font-size: 11px;
            color: #CCC;
            line-height: 1.3;
        }

        @media (max-width: 768px) {
            .game-area {
                grid-template-columns: 1fr;
            }
            
            .tile {
                width: 40px;
                height: 60px;
            }
            
            .tile-symbol {
                font-size: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üÄÑ ‰∏Ä‰∫∫Áî®È∫ªÈõÄ„Éá„Éê„ÉÉ„Ç∞„ÉÑ„Éº„É´</h1>
            <p>CPUÊç®„Å¶Áâå„Ç¢„É´„Ç¥„É™„Ç∫„É†ÈñãÁô∫„Éª„ÉÜ„Çπ„ÉàÁî®</p>
        </div>

        <div class="game-area">
            <div class="main-area">
                <div class="hand-area">
                    <div class="hand-title">ÊâãÁâå (14Êûö)</div>
                    <div class="hand-tiles" id="handTiles"></div>
                </div>

                <div class="wind-settings" style="margin-bottom: 20px; padding: 15px; background: rgba(0,0,0,0.2); border-radius: 10px;">
                    <div class="wind-title" style="font-size: 16px; font-weight: bold; margin-bottom: 10px; color: #FFD700;">üå™Ô∏è È¢®Ë®≠ÂÆö</div>
                    <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-size: 14px;">Â†¥È¢®:</label>
                            <select id="gameWind" onchange="updateWindSettings()" style="padding: 5px; border-radius: 5px; background: #fff; color: #000;">
                                <option value="east">Êù±Â†¥</option>
                                <option value="south">ÂçóÂ†¥</option>
                            </select>
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-size: 14px;">Ëá™È¢®:</label>
                            <select id="playerWind" onchange="updateWindSettings()" style="padding: 5px; border-radius: 5px; background: #fff; color: #000;">
                                <option value="east">Êù±ÂÆ∂</option>
                                <option value="south">ÂçóÂÆ∂</option>
                                <option value="west">Ë•øÂÆ∂</option>
                                <option value="north">ÂåóÂÆ∂</option>
                            </select>
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-size: 14px;">Â±Ä:</label>
                            <input type="number" id="roundNumber" value="1" min="1" max="4" onchange="updateWindSettings()" style="width: 60px; padding: 5px; border-radius: 5px; background: #fff; color: #000;">
                        </div>
                        <div style="display: flex; align-items: end;">
                            <button class="btn btn-secondary" onclick="resetWindSettings()" style="padding: 8px 16px; font-size: 12px;">„É™„Çª„ÉÉ„Éà</button>
                        </div>
                    </div>
                </div>

                <div class="controls">
                    <button class="btn btn-primary" onclick="dealNewHand()">Êñ∞„Åó„ÅÑÈÖçÁâå</button>
                    <button class="btn btn-secondary" onclick="drawTile()">„ÉÑ„É¢</button>
                    <button class="btn btn-primary" onclick="calculateStatus()">Áä∂ÊÖãÊõ¥Êñ∞</button>
                    <button class="btn btn-secondary" onclick="autoComplete()">Ëá™ÂãïÂÆåÊàê</button>
                    <button class="btn btn-primary" onclick="manualSort()">ÊâãÂãï„ÇΩ„Éº„Éà</button>
                </div>

                <div class="controls">
                    <button class="btn btn-primary" onclick="simulateOptimalPlay()">ÊúÄÈÅ©ÊâìÁâå„Ç∑„Éü„É•„É¨„Éº„Éà</button>
                    <button class="btn btn-secondary" onclick="analyzeBestDiscard()">ÊúÄÈÅ©Êç®„Å¶ÁâåÂàÜÊûê</button>
                    <button class="btn btn-primary" onclick="generateTestCases()">„ÉÜ„Çπ„Éà„Ç±„Éº„ÇπÁîüÊàê</button>
                </div>

                <div class="controls">
                    <button class="btn btn-primary" onclick="runCpuAlgorithm()">ü§ñ CPUÊÄùËÄÉ„Ç¢„É´„Ç¥„É™„Ç∫„É†</button>
                    <button class="btn btn-secondary" onclick="compareDiscardOptions()">üìä ÂÖ®ÈÅ∏ÊäûËÇ¢ÊØîËºÉ</button>
                    <button class="btn btn-primary" onclick="simulateGameProgress()">‚ö° „Ç≤„Éº„É†ÈÄ≤Ë°å„Ç∑„Éü„É•„É¨„Éº„Éà</button>
                </div>

                <div class="controls">
                    <button class="btn btn-primary" onclick="executePon()">„Éù„É≥</button>
                    <button class="btn btn-secondary" onclick="executeChi()">„ÉÅ„Éº</button>
                    <button class="btn btn-primary" onclick="executeKan()">„Ç´„É≥</button>
                    <button class="btn btn-secondary" onclick="executeAnkan()">„Ç¢„É≥„Ç´„É≥</button>
                </div>

                <div class="controls">
                    <button class="btn btn-primary" onclick="selectWinTile()">‰∏ä„Åå„ÇäÁâåÊåáÂÆö</button>
                    <button class="btn btn-secondary" onclick="clearWinTile()">‰∏ä„Åå„ÇäÁâå„ÇØ„É™„Ç¢</button>
                    <span id="winTileDisplay" style="color: #FFD700; margin-left: 10px;">‰∏ä„Åå„ÇäÁâå: „Å™„Åó</span>
                </div>

                <div class="available-tiles">
                    <div class="hand-title">‰ΩøÁî®ÂèØËÉΩ„Å™Áâå („ÇØ„É™„ÉÉ„ÇØ„ÅßÊâãÁâå„Å´ËøΩÂä†)</div>
                    <div class="tile-selector" id="availableTiles"></div>
                </div>
            </div>

            <div class="info-panel">
                <div class="info-section">
                    <div class="info-title">üéØ ÊâãÁâåÁä∂ÊÖã</div>
                    <div class="status-display" id="handStatus">
                        <div class="status-item">
                            <span>Áä∂ÊÖã:</span>
                            <span id="handState">Êú™Âà§ÂÆö</span>
                        </div>
                        <div class="status-item">
                            <span>ÂêëËÅ¥Êï∞:</span>
                            <span id="shantenCount">-</span>
                        </div>
                        <div class="status-item">
                            <span>ÊûöÊï∞:</span>
                            <span id="tileCount">0/14</span>
                        </div>
                    </div>
                    <div class="waiting-tiles" id="waitingTiles"></div>
                </div>

                <div class="info-section">
                    <div class="info-title">üÄÑ ÂΩπÊÉÖÂ†±</div>
                    <div class="yaku-list" id="yakuList">
                        <div class="yaku-item">
                            <span>ÂΩπ„Å™„Åó</span>
                            <span>0Áøª</span>
                        </div>
                    </div>
                </div>

                <div class="info-section">
                    <div class="info-title">üÄÑ È≥¥„ÅçÂà§ÂÆö</div>
                    <div class="meld-analysis" id="meldAnalysis">
                        È≥¥„ÅçÂà§ÂÆö„Åå„Åì„Åì„Å´Ë°®Á§∫„Åï„Çå„Åæ„Åô...
                    </div>
                </div>

                <div class="info-section">
                    <div class="info-title">üéØ ÂΩì„Åü„ÇäÁâåÂàÜÊûê</div>
                    <div class="winning-tiles-analysis" id="winningTilesAnalysis">
                        ÂΩì„Åü„ÇäÁâåÂàÜÊûê„Åå„Åì„Åì„Å´Ë°®Á§∫„Åï„Çå„Åæ„Åô...
                    </div>
                </div>

                <div class="info-section">
                    <div class="info-title">üîì ÂâØÈú≤(Êôí„Åó)</div>
                    <div class="melds-display" id="meldsDisplay">
                        ÂâØÈú≤„Å™„Åó
                    </div>
                </div>

                <div class="info-section">
                    <div class="info-title">üîß „Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†±</div>
                    <div class="debug-info" id="debugInfo">
                        „Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†±„Åå„Åì„Åì„Å´Ë°®Á§∫„Åï„Çå„Åæ„Åô...
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // „Ç≤„Éº„É†Áä∂ÊÖã
        let currentHand = [];
        let selectedTileIndex = -1;
        let gameSettings = {
            gameWind: 'east',    // Â†¥È¢® (east/south/west/north)
            playerWind: 'east',  // Ëá™È¢® (east/south/west/north) 
            round: 1             // Â±ÄÊï∞
        };
        let gameStats = {
            handsPlayed: 0,
            completedHands: 0,
            averageShanten: 0
        };

        // ÂÖ®Áâå„Çø„Ç§„ÉóÂÆöÁæ©
        const allTileTypes = [];

        // Êï∞ÁâåÁîüÊàê
        ['man', 'pin', 'sou'].forEach(suit => {
            for (let rank = 1; rank <= 9; rank++) {
                allTileTypes.push({ suit, rank });
            }
        });

        // Â≠óÁâåÁîüÊàê
        ['east', 'south', 'west', 'north', 'haku', 'hatsu', 'chun'].forEach(type => {
            allTileTypes.push({ suit: 'honors', type });
        });

        // ÂàùÊúüÂåñ
        document.addEventListener('DOMContentLoaded', function() {
            generateAvailableTiles();
            dealNewHand();
            calculateStatus();
            updateMeldsDisplay();
        });

        // Âà©Áî®ÂèØËÉΩ„Å™Áâå„ÇíÁîüÊàê
        function generateAvailableTiles() {
            const container = document.getElementById('availableTiles');
            container.innerHTML = '';

            allTileTypes.forEach(tile => {
                const tileElement = createAvailableTile(tile);
                container.appendChild(tileElement);
            });
        }

        // Âà©Áî®ÂèØËÉΩ„Å™ÁâåË¶ÅÁ¥†‰ΩúÊàê
        function createAvailableTile(tile) {
            const div = document.createElement('div');
            div.className = `available-tile ${tile.suit}`;
            div.textContent = getTileSymbol(tile);
            
            div.addEventListener('click', function() {
                addTileToHand(tile);
            });
            
            return div;
        }

        // ÊâãÁâå„Å´Áâå„ÇíËøΩÂä†
        function addTileToHand(tile) {
            if (currentHand.length >= 14) {
                alert('ÊâãÁâå„ÅØÊúÄÂ§ß14Êûö„Åß„Åô');
                return;
            }
            
            currentHand.push({ ...tile });
            sortHand(); // Ëá™Âãï„ÇΩ„Éº„Éà
            updateHandDisplay();
            calculateStatus();
            logDebug(`ÁâåËøΩÂä†: ${getTileDisplayName(tile)}, ÊâãÁâåÊûöÊï∞: ${currentHand.length}`);
        }

        // È¢®Ë®≠ÂÆöÊõ¥Êñ∞
        function updateWindSettings() {
            gameSettings.gameWind = document.getElementById('gameWind').value;
            gameSettings.playerWind = document.getElementById('playerWind').value;
            gameSettings.round = parseInt(document.getElementById('roundNumber').value);
            
            // ÂΩπÁâåÂà§ÂÆö„Å´ÂΩ±Èüø„Åô„Çã„Åü„ÇÅÁä∂ÊÖã„ÇíÂÜçË®àÁÆó
            calculateStatus();
            
            logDebug(`È¢®Ë®≠ÂÆöÊõ¥Êñ∞: Â†¥È¢®=${gameSettings.gameWind}, Ëá™È¢®=${gameSettings.playerWind}, ${gameSettings.round}Â±Ä`);
        }

        // È¢®Ë®≠ÂÆö„É™„Çª„ÉÉ„Éà
        function resetWindSettings() {
            gameSettings.gameWind = 'east';
            gameSettings.playerWind = 'east';
            gameSettings.round = 1;
            
            document.getElementById('gameWind').value = 'east';
            document.getElementById('playerWind').value = 'east';
            document.getElementById('roundNumber').value = 1;
            
            calculateStatus();
            logDebug('È¢®Ë®≠ÂÆö„Çí„É™„Çª„ÉÉ„Éà');
        }

        // Êñ∞„Åó„ÅÑÈÖçÁâå
        function dealNewHand() {
            currentHand = [];
            
            // „É©„É≥„ÉÄ„É†„Å´13ÊûöÈÖçÁâå
            for (let i = 0; i < 13; i++) {
                const randomTile = allTileTypes[Math.floor(Math.random() * allTileTypes.length)];
                currentHand.push({ ...randomTile });
            }
            
            // ÈÖçÁâå„ÇíËá™Âãï„ÇΩ„Éº„Éà
            sortHand();
            
            gameStats.handsPlayed++;
            updateHandDisplay();
            calculateStatus();
            logDebug(`Êñ∞„Åó„ÅÑÈÖçÁâåÁîüÊàê: ${currentHand.length}ÊûöÔºà„ÇΩ„Éº„ÉàÊ∏à„ÅøÔºâ`);
        }

        // ÊâãÁâå„ÇΩ„Éº„Éà
        function sortHand() {
            currentHand.sort((a, b) => {
                // „Çπ„Éº„ÉàÈ†Ü: man, pin, sou, honors
                const suitOrder = { man: 0, pin: 1, sou: 2, honors: 3 };
                
                if (suitOrder[a.suit] !== suitOrder[b.suit]) {
                    return suitOrder[a.suit] - suitOrder[b.suit];
                }
                
                // Âêå„Åò„Çπ„Éº„ÉàÂÜÖ„Åß„ÅÆ„ÇΩ„Éº„Éà
                if (a.suit === 'honors') {
                    const honorOrder = { east: 0, south: 1, west: 2, north: 3, haku: 4, hatsu: 5, chun: 6 };
                    return honorOrder[a.type] - honorOrder[b.type];
                } else {
                    return a.rank - b.rank;
                }
            });
        }

        // ÊâãÂãï„ÇΩ„Éº„Éà
        function manualSort() {
            sortHand();
            updateHandDisplay();
            logDebug('ÊâãÁâå„ÇíÊâãÂãï„ÇΩ„Éº„Éà„Åó„Åæ„Åó„Åü');
        }

        // „ÉÑ„É¢
        function drawTile() {
            if (currentHand.length >= 14) {
                alert('ÊâãÁâå„ÅØÊúÄÂ§ß14Êûö„Åß„Åô');
                return;
            }
            
            const randomTile = allTileTypes[Math.floor(Math.random() * allTileTypes.length)];
            currentHand.push({ ...randomTile });
            sortHand(); // Ëá™Âãï„ÇΩ„Éº„Éà
            updateHandDisplay();
            calculateStatus();
            logDebug(`„ÉÑ„É¢: ${getTileDisplayName(randomTile)}`);
        }

        // ÊâãÁâåË°®Á§∫Êõ¥Êñ∞
        function updateHandDisplay() {
            const container = document.getElementById('handTiles');
            container.innerHTML = '';

            currentHand.forEach((tile, index) => {
                const tileElement = createHandTile(tile, index);
                container.appendChild(tileElement);
            });

            const meldTileCount = melds.reduce((total, meld) => total + meld.tiles.length, 0);
            const totalTiles = currentHand.length + meldTileCount;
            document.getElementById('tileCount').textContent = `${currentHand.length}+${meldTileCount}=${totalTiles}`;
        }

        // ÊâãÁâå„Çø„Ç§„É´Ë¶ÅÁ¥†‰ΩúÊàê
        function createHandTile(tile, index) {
            const div = document.createElement('div');
            div.className = `tile ${tile.suit}`;
            if (selectedTileIndex === index) {
                div.classList.add('selected');
            }

            const symbol = getTileSymbol(tile);
            const suitName = getSuitName(tile.suit);

            div.innerHTML = `
                <div class="tile-symbol">${symbol}</div>
                <div class="tile-suit">${suitName}</div>
            `;

            div.addEventListener('click', function() {
                if (selectedTileIndex === index) {
                    // ÈÅ∏ÊäûËß£Èô§
                    selectedTileIndex = -1;
                } else if (selectedTileIndex >= 0) {
                    // Áâå„ÇíÂâäÈô§
                    currentHand.splice(selectedTileIndex, 1);
                    selectedTileIndex = -1;
                    logDebug(`ÁâåÂâäÈô§: ÊâãÁâåÊûöÊï∞: ${currentHand.length}`);
                } else {
                    // Áâå„ÇíÈÅ∏Êäû
                    selectedTileIndex = index;
                }
                updateHandDisplay();
                calculateStatus();
            });

            return div;
        }

        // Áâå„Ç∑„É≥„Éú„É´ÂèñÂæó
        function getTileSymbol(tile) {
            if (tile.suit === 'honors') {
                const honorMap = {
                    east: 'Êù±', south: 'Âçó', west: 'Ë•ø', north: 'Âåó',
                    haku: 'ÁôΩ', hatsu: 'Áôº', chun: '‰∏≠'
                };
                return honorMap[tile.type] || tile.type;
            } else {
                return tile.rank.toString();
            }
        }

        // „Çπ„Éº„ÉàÂêçÂèñÂæó
        function getSuitName(suit) {
            const suitMap = {
                man: 'Ëê¨', pin: 'Á≠í', sou: 'Á¥¢', honors: 'Â≠ó'
            };
            return suitMap[suit] || suit;
        }

        // ÁâåË°®Á§∫ÂêçÂèñÂæó
        function getTileDisplayName(tile) {
            if (tile.suit === 'honors') {
                return getTileSymbol(tile);
            } else {
                return `${tile.rank}${getSuitName(tile.suit)}`;
            }
        }

        // Áä∂ÊÖãË®àÁÆó
        function calculateStatus() {
            const handState = analyzeHandState(currentHand);
            
            // Áä∂ÊÖãË°®Á§∫Êõ¥Êñ∞
            document.getElementById('handState').textContent = handState.message;
            document.getElementById('shantenCount').textContent = handState.shanten >= 0 ? `${handState.shanten}„Ç∑„É£„É≥„ÉÜ„É≥` : '-';
            
            // ÂæÖ„Å°ÁâåË°®Á§∫
            updateWaitingTiles(handState.waitingTiles || [], handState);
            
            // ÂΩπÊÉÖÂ†±Ë°®Á§∫
            updateYakuDisplay(handState.yaku || []);
            
            // „Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†±Êõ¥Êñ∞
            updateDebugInfo(handState);
            
            // È≥¥„ÅçÂà§ÂÆöÊõ¥Êñ∞
            updateMeldAnalysis();
            
            // ÂΩì„Åü„ÇäÁâåÂàÜÊûêÊõ¥Êñ∞
            updateWinningTilesAnalysis();
        }

        // ÊâãÁâåÁä∂ÊÖãÂàÜÊûê
        function analyzeHandState(hand) {
            if (!hand || hand.length === 0) {
                return {
                    message: 'ÊâãÁâå„Å™„Åó',
                    shanten: -1,
                    waitingTiles: [],
                    yaku: [],
                    discardToTenpai: null
                };
            }

            // Âíå‰∫ÜÂΩ¢„ÉÅ„Çß„ÉÉ„ÇØ
            if (hand.length === 14 && isWinningShape(hand)) {
                const yaku = calculateYaku(hand);
                return {
                    message: 'Âíå‰∫ÜÂΩ¢',
                    shanten: -1,
                    waitingTiles: [],
                    yaku: yaku,
                    isComplete: true,
                    discardToTenpai: null
                };
            }

            // 14Êûö„ÅÆÂ†¥ÂêàÔºöÊç®„Å¶ÁâåÂæå„ÉÜ„É≥„Éë„Ç§ÂàÜÊûê
            if (hand.length === 14) {
                const discardAnalysis = analyzeDiscardToTenpai(hand);
                const baseShanten = calculateShanten(hand.slice(0, 13)); // ‰ªÆ„ÅÆ13Êûö„Åß„ÅÆÂêëËÅ¥Êï∞
                
                if (discardAnalysis.canReachTenpai) {
                    return {
                        message: `${baseShanten}„Ç∑„É£„É≥„ÉÜ„É≥ÔºàÊç®„Å¶Áâå„Åß„ÉÜ„É≥„Éë„Ç§ÂèØËÉΩÔºâ`,
                        shanten: baseShanten,
                        waitingTiles: [],
                        yaku: [],
                        discardToTenpai: discardAnalysis
                    };
                } else {
                    return {
                        message: `${baseShanten}„Ç∑„É£„É≥„ÉÜ„É≥`,
                        shanten: baseShanten,
                        waitingTiles: [],
                        yaku: [],
                        discardToTenpai: null
                    };
                }
            }

            // „ÉÜ„É≥„Éë„Ç§„ÉÅ„Çß„ÉÉ„ÇØÔºà13ÊûöÔºâ
            if (hand.length === 13) {
                const waitingTiles = getWaitingTiles(hand);
                const yaku = calculateYaku(hand); // 13Êûö„Åß„ÇÇÂΩπÂà§ÂÆö„ÇíÂÆüË°å
                if (waitingTiles.length > 0) {
                    return {
                        message: '„ÉÜ„É≥„Éë„Ç§',
                        shanten: 0,
                        waitingTiles: waitingTiles,
                        yaku: yaku,
                        discardToTenpai: null
                    };
                }
            }

            // ÂêëËÅ¥Êï∞Ë®àÁÆó
            const shanten = calculateShanten(hand);
            const yaku = calculateYaku(hand); // ÂêëËÅ¥Êï∞Ë®àÁÆóÊôÇ„ÇÇÂΩπÂà§ÂÆö„ÇíÂÆüË°å
            return {
                message: shanten === 1 ? '„Ç§„Éº„Ç∑„É£„É≥„ÉÜ„É≥' : `${shanten}„Ç∑„É£„É≥„ÉÜ„É≥`,
                shanten: shanten,
                waitingTiles: [],
                yaku: yaku,
                discardToTenpai: null
            };
        }

        // Êç®„Å¶ÁâåÂæå„ÉÜ„É≥„Éë„Ç§ÂàÜÊûê
        function analyzeDiscardToTenpai(hand) {
            if (hand.length !== 14) {
                return { canReachTenpai: false, tenpaiOptions: [] };
            }

            const tenpaiOptions = [];

            // ÂêÑÁâå„ÇíÊç®„Å¶„ÅüÂ†¥Âêà„ÅÆ„ÉÜ„É≥„Éë„Ç§„ÉÅ„Çß„ÉÉ„ÇØ
            for (let i = 0; i < hand.length; i++) {
                const testHand = [...hand];
                const discardTile = testHand.splice(i, 1)[0];
                
                // 13Êûö„Åß„ÉÜ„É≥„Éë„Ç§„ÉÅ„Çß„ÉÉ„ÇØ
                const waitingTiles = getWaitingTiles(testHand);
                if (waitingTiles.length > 0) {
                    tenpaiOptions.push({
                        discardTile: discardTile,
                        waitingTiles: waitingTiles,
                        waitCount: waitingTiles.length,
                        totalWaitingTiles: waitingTiles.length * 4 // Á∞°ÊòìË®àÁÆó
                    });
                }
            }

            return {
                canReachTenpai: tenpaiOptions.length > 0,
                tenpaiOptions: tenpaiOptions,
                bestOption: tenpaiOptions.length > 0 ? 
                    tenpaiOptions.reduce((best, current) => 
                        current.waitCount > best.waitCount ? current : best
                    ) : null
            };
        }

        // Âíå‰∫ÜÂΩ¢Âà§ÂÆö
        function isWinningShape(tiles) {
            if (tiles.length !== 14) return false;

            // ‰∏ÉÂØæÂ≠ê„ÉÅ„Çß„ÉÉ„ÇØ
            if (checkSevenPairs(tiles)) return true;

            // ÂõΩÂ£´ÁÑ°Âèå„ÉÅ„Çß„ÉÉ„ÇØ  
            if (checkThirteenOrphans(tiles)) return true;

            // ÈÄöÂ∏∏ÂΩ¢„ÉÅ„Çß„ÉÉ„ÇØ
            return checkNormalWinning(tiles);
        }

        // ‰∏ÉÂØæÂ≠êÂà§ÂÆö
        function checkSevenPairs(tiles) {
            const counts = getTileCounts(tiles);
            const values = Object.values(counts);
            return values.length === 7 && values.every(count => count === 2);
        }

        // ÂõΩÂ£´ÁÑ°ÂèåÂà§ÂÆö
        function checkThirteenOrphans(tiles) {
            const required = [
                'man_1', 'man_9', 'pin_1', 'pin_9', 'sou_1', 'sou_9',
                'honors_east', 'honors_south', 'honors_west', 'honors_north',
                'honors_haku', 'honors_hatsu', 'honors_chun'
            ];
            
            const counts = {};
            tiles.forEach(tile => {
                const key = getTileKey(tile);
                counts[key] = (counts[key] || 0) + 1;
            });
            
            return required.every(req => counts[req] >= 1) && 
                   required.some(req => counts[req] === 2);
        }

        // ÈÄöÂ∏∏ÂΩ¢Âà§ÂÆö
        function checkNormalWinning(tiles) {
            const counts = getTileCounts(tiles);
            return checkMeldsRecursive(counts, 0);
        }

        // ÂæÖ„Å°ÁâåË®àÁÆó
        function getWaitingTiles(tiles) {
            if (tiles.length !== 13) return [];

            const waitingTiles = [];

            for (const testTile of allTileTypes) {
                const testHand = [...tiles, testTile];
                if (isWinningShape(testHand)) {
                    waitingTiles.push(testTile);
                }
            }

            return waitingTiles;
        }

        // ÂêëËÅ¥Êï∞Ë®àÁÆó
        function calculateShanten(tiles) {
            if (tiles.length === 0) return 8;
            
            const counts = getTileCounts(tiles);
            const uniqueTiles = Object.keys(counts).length;
            
            // Á∞°ÊòìÂÆüË£Ö
            if (uniqueTiles <= 7) return 1;
            if (uniqueTiles <= 10) return 2;
            if (uniqueTiles <= 12) return 3;
            return Math.min(6, uniqueTiles - 8);
        }

        // ÂΩπË®àÁÆóÔºàÂº∑ÂåñÁâàÔºâ
        function calculateYaku(hand) {
            const yaku = [];
            
            // ÂΩπÊ∫ÄÂÑ™ÂÖàÂà§ÂÆö
            if (checkKokushi(hand)) {
                yaku.push({ name: 'ÂõΩÂ£´ÁÑ°Âèå', han: 13 });
                return yaku; // ÂΩπÊ∫Ä„ÅØ‰ªñ„ÅÆÂΩπ„Å®Ë§áÂêà„Åó„Å™„ÅÑ
            }
            if (checkSuuankou(hand)) {
                yaku.push({ name: 'ÂõõÊöóÂàª', han: 13 });
                return yaku;
            }
            if (checkDaisangen(hand)) {
                yaku.push({ name: 'Â§ß‰∏âÂÖÉ', han: 13 });
                return yaku;
            }
            if (checkTsuuiisou(hand)) {
                yaku.push({ name: 'Â≠ó‰∏ÄËâ≤', han: 13 });
                return yaku;
            }
            if (checkChinroutou(hand)) {
                yaku.push({ name: 'Ê∏ÖËÄÅÈ†≠', han: 13 });
                return yaku;
            }
            if (checkRyuuiisou(hand)) {
                yaku.push({ name: 'Á∑ë‰∏ÄËâ≤', han: 13 });
                return yaku;
            }
            if (checkChuuren(hand)) {
                yaku.push({ name: '‰πùËìÆÂÆùÁáà', han: 13 });
                return yaku;
            }
            if (checkSuukantsu(hand)) {
                yaku.push({ name: 'ÂõõÊßìÂ≠ê', han: 13 });
                return yaku;
            }

            // ÁâπÊÆäÂΩ¢Âà§ÂÆö
            if (checkChiitoi(hand)) {
                yaku.push({ name: '‰∏ÉÂØæÂ≠ê', han: 2 });
                // ‰∏ÉÂØæÂ≠ê„ÅØ‰ªñ„ÅÆÂΩπ„Å®Ë§áÂêàÂèØËÉΩ„Å™Â†¥Âêà„Åå„ÅÇ„Çã„Åå„ÄÅÂü∫Êú¨ÁöÑ„Å´„ÅØÂçòÁã¨
                if (checkTanyao(hand)) yaku.push({ name: '„Çø„É≥„É§„Ç™', han: 1 });
                if (checkChinitsu(hand)) yaku.push({ name: 'Ê∏Ö‰∏ÄËâ≤', han: 6 });
                if (checkHonitsu(hand)) yaku.push({ name: 'Ê∑∑‰∏ÄËâ≤', han: 3 });
                return yaku;
            }

            // ÈÄöÂ∏∏ÂΩπÂà§ÂÆöÔºàÈ†ÜÂ∫èÈáçË¶ÅÔºâ
            if (checkTanyao(hand)) yaku.push({ name: '„Çø„É≥„É§„Ç™', han: 1 });
            
            // ‰∏ÄÁõÉÂè£„Éª‰∫åÁõÉÂè£„ÉÅ„Çß„ÉÉ„ÇØÔºà„Éî„É≥„Éï„Çà„ÇäÂÖàÔºâ
            if (checkRyanpeikou(hand)) {
                yaku.push({ name: '‰∫åÁõÉÂè£', han: 3 });
            } else if (checkIipeikou(hand)) {
                yaku.push({ name: '‰∏ÄÁõÉÂè£', han: 1 });
            }
            
            // „Éî„É≥„Éï„ÉÅ„Çß„ÉÉ„ÇØÔºà‰∏ÄÁõÉÂè£„Åå„ÅÇ„Å£„Å¶„ÇÇ„Éî„É≥„Éï„ÅØÊàêÁ´ãÂèØËÉΩÔºâ
            if (checkPinfu(hand)) {
                yaku.push({ name: '„Éî„É≥„Éï', han: 1 });
            }
            
            // Ë©≥Á¥∞ÂΩπÁâåÂà§ÂÆö
            const yakuhaiDetails = getYakuhaiDetails(hand);
            console.log('ÂΩπÁâåÂà§ÂÆöÁµêÊûú:', yakuhaiDetails);
            console.log('ÁèæÂú®„ÅÆÂâØÈú≤:', melds);
            console.log('ÂΩπÁâåË©≥Á¥∞:', JSON.stringify(yakuhaiDetails, null, 2));
            yakuhaiDetails.forEach(yakuhai => {
                console.log('ÂΩπ„ÇíËøΩÂä†:', yakuhai);
                yaku.push(yakuhai);
            });
            
            if (checkToitoi(hand)) yaku.push({ name: 'ÂØæ„ÄÖÂíå', han: 2 });
            if (checkSanankou(hand)) yaku.push({ name: '‰∏âÊöóÂàª', han: 2 });
            if (checkSanshoku(hand)) yaku.push({ name: '‰∏âËâ≤ÂêåÈ†Ü', han: 2 });
            if (checkIttsu(hand)) yaku.push({ name: '‰∏ÄÊ∞óÈÄöË≤´', han: 2 });
            if (checkChanta(hand)) yaku.push({ name: 'Ê∑∑ÂÖ®Â∏Ø‰πà‰πù', han: 2 });
            if (checkJunchan(hand)) yaku.push({ name: 'Á¥îÂÖ®Â∏Ø‰πà‰πù', han: 3 });
            if (checkHonroutou(hand)) yaku.push({ name: 'Ê∑∑ËÄÅÈ†≠', han: 2 });
            if (checkShousangen(hand)) yaku.push({ name: 'Â∞è‰∏âÂÖÉ', han: 2 });
            if (checkHonitsu(hand)) yaku.push({ name: 'Ê∑∑‰∏ÄËâ≤', han: 3 });
            if (checkChinitsu(hand)) yaku.push({ name: 'Ê∏Ö‰∏ÄËâ≤', han: 6 });

            // ÂâØÈú≤„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØÂΩπ„Å™„Åó„Åß„ÇÇË°®Á§∫ÔºàÂÆüÈöõ„ÅÆÂíå‰∫ÜÊôÇ„ÅÆ„Åø„ÉÑ„É¢Á≠â„ÇíÂà§ÂÆöÔºâ
            console.log('ÊúÄÁµÇÂΩπÁµêÊûú:', yaku);
            
            return yaku;
        }

        // ÂΩπÂà§ÂÆöÈñ¢Êï∞Áæ§
        function checkTanyao(hand) {
            return hand.every(tile => {
                if (tile.suit === 'honors') return false;
                return tile.rank >= 2 && tile.rank <= 8;
            });
        }

        function checkPinfu(hand) {
            if (checkChiitoi(hand)) return false;
            
            const structure = analyzeHandStructure(hand);
            if (!structure || !structure.isComplete) return false;
            
            // 4„Å§„ÅÆÈ†ÜÂ≠ê„Å®1„Å§„ÅÆÈõÄÈ†≠
            if (structure.sequences.length !== 4) return false;
            if (structure.triplets.length > 0 || structure.quads.length > 0) return false;
            if (structure.pairs.length !== 1) return false;
            
            // ÈõÄÈ†≠„ÅåÂΩπÁâå„Åß„Å™„ÅÑ„Åì„Å®
            const pairKey = structure.pairs[0];
            if (Array.isArray(pairKey)) {
                const suit = pairKey[0];
                const rankOrType = pairKey[1];
                
                // Â≠óÁâå„ÅØÂΩπÁâå
                if (suit === 'honors') return false;
                
                // Â†¥È¢®„ÉªËá™È¢®„ÉÅ„Çß„ÉÉ„ÇØ
                if (suit === 'honors') {
                    if (rankOrType === gameSettings.gameWind) return false;
                    if (rankOrType === gameSettings.playerWind) return false;
                }
            } else {
                // ÊñáÂ≠óÂàó„ÅÆÂ†¥Âêà„ÅÆÂá¶ÁêÜ
                if (typeof pairKey === 'string' && pairKey.startsWith('honors')) return false;
            }
            
            return true;
        }

        function checkChiitoi(hand) {
            const counts = getTileCounts(hand);
            const values = Object.values(counts);
            return values.length === 7 && values.every(count => count === 2);
        }

        function checkKokushi(hand) {
            return checkThirteenOrphans(hand);
        }

        function checkSuuankou(hand) {
            const counts = getTileCounts(hand);
            const triplets = Object.values(counts).filter(count => count >= 3).length;
            const pairs = Object.values(counts).filter(count => count === 2).length;
            return triplets === 4 && pairs === 1;
        }

        function checkDaisangen(hand) {
            const dragons = ['honors_haku', 'honors_hatsu', 'honors_chun'];
            const counts = getTileCounts(hand);
            return dragons.every(dragon => counts[dragon] >= 3);
        }

        function checkTsuuiisou(hand) {
            return hand.every(tile => tile.suit === 'honors');
        }

        function checkChinroutou(hand) {
            return hand.every(tile => {
                if (tile.suit === 'honors') return false;
                return tile.rank === 1 || tile.rank === 9;
            });
        }

        function checkRyuuiisou(hand) {
            const greenTiles = ['sou_2', 'sou_3', 'sou_4', 'sou_6', 'sou_8', 'honors_hatsu'];
            return hand.every(tile => {
                const key = getTileKey(tile);
                return greenTiles.includes(key);
            });
        }

        function checkChuuren(hand) {
            const suits = ['man', 'pin', 'sou'];
            return suits.some(suit => {
                const suitTiles = hand.filter(tile => tile.suit === suit);
                if (suitTiles.length !== 14) return false;
                
                const counts = {};
                suitTiles.forEach(tile => {
                    counts[tile.rank] = (counts[tile.rank] || 0) + 1;
                });
                
                return counts[1] >= 3 && counts[9] >= 3 && 
                       [2,3,4,5,6,7,8].every(rank => counts[rank] >= 1);
            });
        }

        function checkSuukantsu(hand) {
            const counts = getTileCounts(hand);
            const quads = Object.values(counts).filter(count => count === 4).length;
            return quads === 4;
        }

        function checkIipeikou(hand) {
            if (checkChiitoi(hand)) return false;
            
            const structure = analyzeHandStructure(hand);
            if (!structure || !structure.isComplete) return false;
            if (structure.sequences.length < 2) return false;
            
            // È†ÜÂ≠ê„ÇíÊ≠£Ë¶èÂåñ„Åó„Å¶ÊØîËºÉ
            const sequencePatterns = structure.sequences.map(seq => {
                return seq.sort().join(',');
            });
            
            const patternCounts = {};
            sequencePatterns.forEach(pattern => {
                patternCounts[pattern] = (patternCounts[pattern] || 0) + 1;
            });
            
            // Âêå„ÅòÈ†ÜÂ≠ê„Åå2„Å§‰ª•‰∏ä„ÅÇ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
            return Object.values(patternCounts).some(count => count >= 2);
        }

        function checkRyanpeikou(hand) {
            if (checkChiitoi(hand)) return false;
            
            const groups = analyzeHandStructure(hand);
            if (!groups) return false;
            
            const sequences = groups.sequences.map(seq => seq.sort().join(''));
            const counts = {};
            
            sequences.forEach(seq => {
                counts[seq] = (counts[seq] || 0) + 1;
            });
            
            const pairs = Object.values(counts).filter(count => count >= 2);
            return pairs.length >= 2;
        }

        function checkYakuhai(hand) {
            const counts = getTileCounts(hand);
            
            // ÂâØÈú≤„Åã„Çâ„ÇÇ„Ç´„Ç¶„É≥„ÉàËøΩÂä†
            melds.forEach(meld => {
                if (meld.type === 'pon' || meld.type === 'kan' || meld.type === 'ankan') {
                    const key = meld.tiles[0];
                    counts[key] = (counts[key] || 0) + meld.tiles.length;
                }
            });
            
            let yakuhaiCount = 0;
            
            // ‰∏âÂÖÉÁâå„ÉÅ„Çß„ÉÉ„ÇØÔºàÂ∏∏„Å´ÂΩπÁâåÔºâ
            const dragons = ['honors_haku', 'honors_hatsu', 'honors_chun'];
            dragons.forEach(dragon => {
                if (counts[dragon] >= 3) {
                    yakuhaiCount++;
                }
            });
            
            // Â†¥È¢®„ÉÅ„Çß„ÉÉ„ÇØ
            const gameWindKey = `honors_${gameSettings.gameWind}`;
            if (counts[gameWindKey] >= 3) {
                yakuhaiCount++;
            }
            
            // Ëá™È¢®„ÉÅ„Çß„ÉÉ„ÇØÔºàÂ†¥È¢®„Å®ÈáçË§á„Åô„ÇãÂ†¥Âêà„ÇÇ„Ç´„Ç¶„É≥„ÉàÔºâ
            const playerWindKey = `honors_${gameSettings.playerWind}`;
            if (counts[playerWindKey] >= 3) {
                yakuhaiCount++;
            }
            
            return yakuhaiCount > 0;
        }

        // Ë©≥Á¥∞ÂΩπÁâåÊÉÖÂ†±ÂèñÂæóÔºàÊâãÁâå+ÂâØÈú≤Ôºâ
        function getYakuhaiDetails(hand) {
            const counts = getTileCounts(hand);
            const yakuhaiList = [];
            
            // ÂâØÈú≤„Åã„Çâ„ÇÇ„Ç´„Ç¶„É≥„ÉàËøΩÂä†
            melds.forEach(meld => {
                if (meld.type === 'pon' || meld.type === 'kan' || meld.type === 'ankan') {
                    // ÂàªÂ≠ê/ÊßìÂ≠ê„ÅÆÂ†¥Âêà„ÅØ3Êûö„Åæ„Åü„ÅØ4Êûö„Å®„Åø„Å™„Åô
                    const key = meld.tiles[0]; // Âêå„ÅòÁâå„Å™„ÅÆ„ÅßÊúÄÂàù„ÅÆË¶ÅÁ¥†„ÅßOK
                    counts[key] = (counts[key] || 0) + meld.tiles.length;
                }
            });
            
            // ‰∏âÂÖÉÁâå„ÉÅ„Çß„ÉÉ„ÇØ
            const dragonNames = { haku: 'ÁôΩ', hatsu: 'Áôº', chun: '‰∏≠' };
            Object.entries(dragonNames).forEach(([type, name]) => {
                const key = `honors_${type}`;
                if (counts[key] >= 3) {
                    yakuhaiList.push({ name: `ÂΩπÁâå(${name})`, han: 1, type: 'dragon' });
                }
            });
            
            // Â†¥È¢®„ÉÅ„Çß„ÉÉ„ÇØ
            const gameWindKey = `honors_${gameSettings.gameWind}`;
            if (counts[gameWindKey] >= 3) {
                const windNames = { east: 'Êù±', south: 'Âçó', west: 'Ë•ø', north: 'Âåó' };
                yakuhaiList.push({ 
                    name: `Â†¥È¢®(${windNames[gameSettings.gameWind]})`, 
                    han: 1, 
                    type: 'gameWind' 
                });
            }
            
            // Ëá™È¢®„ÉÅ„Çß„ÉÉ„ÇØ
            const playerWindKey = `honors_${gameSettings.playerWind}`;
            if (counts[playerWindKey] >= 3) {
                const windNames = { east: 'Êù±', south: 'Âçó', west: 'Ë•ø', north: 'Âåó' };
                yakuhaiList.push({ 
                    name: `Ëá™È¢®(${windNames[gameSettings.playerWind]})`, 
                    han: 1, 
                    type: 'playerWind' 
                });
            }
            
            return yakuhaiList;
        }

        function checkToitoi(hand) {
            if (checkChiitoi(hand)) return false;
            
            const counts = getTileCounts(hand);
            const triplets = Object.values(counts).filter(count => count >= 3).length;
            const pairs = Object.values(counts).filter(count => count === 2).length;
            return triplets === 4 && pairs === 1;
        }

        function checkSanankou(hand) {
            const counts = getTileCounts(hand);
            const triplets = Object.values(counts).filter(count => count >= 3).length;
            return triplets >= 3;
        }

        function checkSanshoku(hand) {
            if (checkChiitoi(hand)) return false;
            
            // ‰∏âËâ≤ÂêåÈ†Ü„ÅÆÂà§ÂÆöÔºö3„Å§„ÅÆËâ≤„ÅßÂêå„ÅòÈ†ÜÂ≠ê
            for (let rank = 1; rank <= 7; rank++) {
                const manSeq = [`man_${rank}`, `man_${rank+1}`, `man_${rank+2}`];
                const pinSeq = [`pin_${rank}`, `pin_${rank+1}`, `pin_${rank+2}`];
                const souSeq = [`sou_${rank}`, `sou_${rank+1}`, `sou_${rank+2}`];
                
                const counts = getTileCounts(hand);
                
                if (manSeq.every(tile => counts[tile] >= 1) &&
                    pinSeq.every(tile => counts[tile] >= 1) &&
                    souSeq.every(tile => counts[tile] >= 1)) {
                    return true;
                }
            }
            return false;
        }

        function checkIttsu(hand) {
            // ‰∏ÄÊ∞óÈÄöË≤´ÔºöÂêå‰∏ÄËâ≤„Åß1-9„ÅÆÈ†ÜÂ≠ê
            const suits = ['man', 'pin', 'sou'];
            return suits.some(suit => {
                const seq1 = [`${suit}_1`, `${suit}_2`, `${suit}_3`];
                const seq2 = [`${suit}_4`, `${suit}_5`, `${suit}_6`];
                const seq3 = [`${suit}_7`, `${suit}_8`, `${suit}_9`];
                
                const counts = getTileCounts(hand);
                
                return seq1.every(tile => counts[tile] >= 1) &&
                       seq2.every(tile => counts[tile] >= 1) &&
                       seq3.every(tile => counts[tile] >= 1);
            });
        }

        function checkChanta(hand) {
            if (checkChiitoi(hand)) return false;
            
            // Ê∑∑ÂÖ®Â∏Ø‰πà‰πùÔºöÂêÑ„É°„É≥„ÉÑ„Å´Á´ØÁâå„ÅãÂ≠óÁâå„ÅåÂê´„Åæ„Çå„Çã
            return hand.every(tile => {
                if (tile.suit === 'honors') return true;
                return tile.rank === 1 || tile.rank === 9;
            });
        }

        function checkJunchan(hand) {
            if (checkChiitoi(hand)) return false;
            
            // Á¥îÂÖ®Â∏Ø‰πà‰πùÔºöÂêÑ„É°„É≥„ÉÑ„Å´Á´ØÁâåÔºà1,9Ôºâ„ÅåÂê´„Åæ„Çå„ÄÅÂ≠óÁâå„Å™„Åó
            const hasHonors = hand.some(tile => tile.suit === 'honors');
            if (hasHonors) return false;
            
            return hand.every(tile => tile.rank === 1 || tile.rank === 9);
        }

        function checkHonroutou(hand) {
            // Ê∑∑ËÄÅÈ†≠ÔºöÁ´ØÁâå„Å®Â≠óÁâå„ÅÆ„Åø
            return hand.every(tile => {
                if (tile.suit === 'honors') return true;
                return tile.rank === 1 || tile.rank === 9;
            });
        }

        function checkShousangen(hand) {
            const dragons = ['honors_haku', 'honors_hatsu', 'honors_chun'];
            const counts = getTileCounts(hand);
            
            let tripletCount = 0;
            let pairCount = 0;
            
            dragons.forEach(dragon => {
                if (counts[dragon] >= 3) tripletCount++;
                if (counts[dragon] === 2) pairCount++;
            });
            
            return tripletCount === 2 && pairCount === 1;
        }

        function checkHonitsu(hand) {
            // Ê∑∑‰∏ÄËâ≤Ôºö1„Å§„ÅÆÊï∞Áâå„Å®Â≠óÁâå„ÅÆ„Åø
            const suits = new Set(hand.map(tile => tile.suit));
            const hasHonors = suits.has('honors');
            const numberSuits = [...suits].filter(suit => suit !== 'honors');
            
            return hasHonors && numberSuits.length === 1;
        }

        function checkChinitsu(hand) {
            // Ê∏Ö‰∏ÄËâ≤Ôºö1„Å§„ÅÆÊï∞Áâå„ÅÆ„Åø
            const suits = new Set(hand.map(tile => tile.suit));
            return suits.size === 1 && !suits.has('honors');
        }

        // ÊâãÁâåÊßãÈÄ†ÂàÜÊûêÔºàÂº∑ÂåñÁâàÔºâ
        function analyzeHandStructure(hand) {
            if (hand.length !== 14) return null;
            
            // ÊúÄÈÅ©„Å™Èù¢Â≠êÊßãÊàê„ÇíÊé¢Á¥¢
            const bestStructure = findBestMeldStructure(hand);
            return bestStructure;
        }

        // ÊúÄÈÅ©„Å™Èù¢Â≠êÊßãÊàê„ÇíÊé¢Á¥¢
        function findBestMeldStructure(hand) {
            const counts = getTileCounts(hand);
            
            // ÂèØËÉΩ„Å™ÂÖ®„Å¶„ÅÆÈù¢Â≠êÊßãÊàê„ÇíË©¶Ë°å
            const possibleStructures = [];
            
            // ÂêÑÁâå„ÇíÈõÄÈ†≠„Å®„Åó„Å¶Ë©¶„Åô
            Object.keys(counts).forEach(pairKey => {
                if (counts[pairKey] >= 2) {
                    const testCounts = { ...counts };
                    testCounts[pairKey] -= 2;
                    
                    // ÂÖ®„Å¶„ÅÆÂèØËÉΩ„Å™ÊßãÈÄ†„ÇíÊé¢Á¥¢
                    const structures = findAllMeldStructures(testCounts, [], pairKey);
                    structures.forEach(structure => {
                        if (structure && structure.isComplete) {
                            possibleStructures.push(structure);
                        }
                    });
                }
            });
            
            // ÊúÄ„ÇÇÈÅ©Âàá„Å™ÊßãÈÄ†„ÇíÈÅ∏ÊäûÔºà‰∏ÄÁõÉÂè£Ê§úÂá∫„ÅÆ„Åü„ÇÅÂÖ®ÊßãÈÄ†„Çí‰øùÊåÅÔºâ
            if (possibleStructures.length === 0) return null;
            
            // ‰∏ÄÁõÉÂè£„ÅåÊ§úÂá∫„Åß„Åç„ÇãÊßãÈÄ†„ÇíÂÑ™ÂÖà
            const iipeikouStructures = possibleStructures.filter(structure => {
                return hasIipeikou(structure);
            });
            
            if (iipeikouStructures.length > 0) {
                return iipeikouStructures[0];
            }
            
            // ÈÄöÂ∏∏„ÅØÈ†ÜÂ≠êÂÑ™ÂÖà„ÅÆÊßãÈÄ†„ÇíÈÅ∏Êäû
            return possibleStructures.reduce((best, current) => {
                const bestScore = calculateStructureScore(best);
                const currentScore = calculateStructureScore(current);
                return currentScore > bestScore ? current : best;
            });
        }

        // ÂÖ®„Å¶„ÅÆÈù¢Â≠êÊßãÈÄ†„ÇíÊé¢Á¥¢
        function findAllMeldStructures(counts, melds, pairKey) {
            const remainingTiles = Object.values(counts).reduce((sum, count) => sum + count, 0);
            
            if (remainingTiles === 0) {
                return [{
                    isComplete: true,
                    pairs: [pairKey.split('_')],
                    triplets: melds.filter(m => m.type === 'triplet').map(m => m.tiles),
                    quads: melds.filter(m => m.type === 'quad').map(m => m.tiles),
                    sequences: melds.filter(m => m.type === 'sequence').map(m => m.tiles)
                }];
            }
            
            const allStructures = [];
            
            // È†ÜÂ≠ê„ÇíÊé¢„Åô
            ['man', 'pin', 'sou'].forEach(suit => {
                for (let rank = 1; rank <= 7; rank++) {
                    const key1 = `${suit}_${rank}`;
                    const key2 = `${suit}_${rank + 1}`;
                    const key3 = `${suit}_${rank + 2}`;
                    
                    if (counts[key1] >= 1 && counts[key2] >= 1 && counts[key3] >= 1) {
                        const newCounts = { ...counts };
                        newCounts[key1] -= 1;
                        newCounts[key2] -= 1;
                        newCounts[key3] -= 1;
                        const newMelds = [...melds, { type: 'sequence', tiles: [key1, key2, key3] }];
                        
                        const structures = findAllMeldStructures(newCounts, newMelds, pairKey);
                        allStructures.push(...structures);
                    }
                }
            });
            
            // ÂàªÂ≠ê„ÇíÊé¢„Åô
            for (const [key, count] of Object.entries(counts)) {
                if (count >= 3) {
                    const newCounts = { ...counts };
                    newCounts[key] -= 3;
                    const newMelds = [...melds, { type: 'triplet', tiles: [key, key, key] }];
                    
                    const structures = findAllMeldStructures(newCounts, newMelds, pairKey);
                    allStructures.push(...structures);
                }
            }
            
            return allStructures;
        }

        // ‰∏ÄÁõÉÂè£„Éë„Çø„Éº„É≥„ÅÆÊ§úÂá∫
        function hasIipeikou(structure) {
            if (!structure || structure.sequences.length < 2) return false;
            
            const sequencePatterns = structure.sequences.map(seq => {
                return seq.sort().join(',');
            });
            
            const patternCounts = {};
            sequencePatterns.forEach(pattern => {
                patternCounts[pattern] = (patternCounts[pattern] || 0) + 1;
            });
            
            return Object.values(patternCounts).some(count => count >= 2);
        }

        // Èù¢Â≠ê„ÅÆÂÜçÂ∏∞ÁöÑÊé¢Á¥¢ÔºàÊîπËâØÁâàÔºâ
        function findMeldsRecursive(counts, melds, pairKey) {
            const remainingTiles = Object.values(counts).reduce((sum, count) => sum + count, 0);
            
            if (remainingTiles === 0) {
                return {
                    isComplete: true,
                    pairs: [pairKey.split('_')],
                    triplets: melds.filter(m => m.type === 'triplet').map(m => m.tiles),
                    quads: melds.filter(m => m.type === 'quad').map(m => m.tiles),
                    sequences: melds.filter(m => m.type === 'sequence').map(m => m.tiles)
                };
            }
            
            // È†ÜÂ≠ê„ÇíÂÑ™ÂÖà„Åó„Å¶Êé¢„ÅôÔºà‰∏ÄÁõÉÂè£„Éë„Çø„Éº„É≥„ÇíÊ≠£„Åó„ÅèÊ§úÂá∫„Åô„Çã„Åü„ÇÅÔºâ
            ['man', 'pin', 'sou'].forEach(suit => {
                for (let rank = 1; rank <= 7; rank++) {
                    const key1 = `${suit}_${rank}`;
                    const key2 = `${suit}_${rank + 1}`;
                    const key3 = `${suit}_${rank + 2}`;
                    
                    if (counts[key1] >= 1 && counts[key2] >= 1 && counts[key3] >= 1) {
                        const newCounts = { ...counts };
                        newCounts[key1] -= 1;
                        newCounts[key2] -= 1;
                        newCounts[key3] -= 1;
                        const newMelds = [...melds, { type: 'sequence', tiles: [key1, key2, key3] }];
                        
                        const result = findMeldsRecursive(newCounts, newMelds, pairKey);
                        if (result && result.isComplete) return result;
                    }
                }
            });
            
            // ÂàªÂ≠ê„ÇíÊé¢„Åô
            for (const [key, count] of Object.entries(counts)) {
                if (count >= 3) {
                    const newCounts = { ...counts };
                    newCounts[key] -= 3;
                    const newMelds = [...melds, { type: 'triplet', tiles: [key, key, key] }];
                    
                    const result = findMeldsRecursive(newCounts, newMelds, pairKey);
                    if (result && result.isComplete) return result;
                }
            }
            
            return null;
        }

        // ÊßãÈÄ†„Çπ„Ç≥„Ç¢Ë®àÁÆóÔºàÈ†ÜÂ≠ê„ÇíÂÑ™ÂÖàÔºâ
        function calculateStructureScore(structure) {
            if (!structure) return 0;
            return structure.sequences.length * 2 + structure.triplets.length;
        }

        function isHonorTile(tile) {
            return typeof tile === 'object' ? tile.suit === 'honors' : tile.startsWith('honors');
        }

        // „É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£Èñ¢Êï∞
        function getTileCounts(tiles) {
            const counts = {};
            tiles.forEach(tile => {
                const key = getTileKey(tile);
                counts[key] = (counts[key] || 0) + 1;
            });
            return counts;
        }

        function getTileKey(tile) {
            return `${tile.suit}_${tile.rank || tile.type}`;
        }

        function checkMeldsRecursive(counts, pairCount) {
            const entries = Object.entries(counts).filter(([_, count]) => count > 0);
            
            if (entries.length === 0) {
                return pairCount === 1;
            }
            
            for (const [tileKey, count] of entries) {
                // ÈõÄÈ†≠„Çí‰Ωú„Çã
                if (count >= 2 && pairCount === 0) {
                    const newCounts = { ...counts };
                    newCounts[tileKey] -= 2;
                    if (checkMeldsRecursive(newCounts, 1)) return true;
                }
                
                // ÂàªÂ≠ê„Çí‰Ωú„Çã
                if (count >= 3) {
                    const newCounts = { ...counts };
                    newCounts[tileKey] -= 3;
                    if (checkMeldsRecursive(newCounts, pairCount)) return true;
                }
                
                // È†ÜÂ≠ê„Çí‰Ωú„Çã
                const [suit, rank] = tileKey.split('_');
                if (suit !== 'honors' && parseInt(rank) <= 7) {
                    const key1 = `${suit}_${parseInt(rank)}`;
                    const key2 = `${suit}_${parseInt(rank) + 1}`;
                    const key3 = `${suit}_${parseInt(rank) + 2}`;
                    
                    if (counts[key1] >= 1 && counts[key2] >= 1 && counts[key3] >= 1) {
                        const newCounts = { ...counts };
                        newCounts[key1] -= 1;
                        newCounts[key2] -= 1;
                        newCounts[key3] -= 1;
                        if (checkMeldsRecursive(newCounts, pairCount)) return true;
                    }
                }
                
                break;
            }
            
            return false;
        }

        // Èù¢Â≠êÊßãÈÄ†„Éá„Éê„ÉÉ„Ç∞ÂàÜÊûê
        function analyzeMeldStructureDebug(hand) {
            const counts = getTileCounts(hand);
            const allStructures = [];
            
            // ÂÖ®„Å¶„ÅÆÂèØËÉΩ„Å™ÈõÄÈ†≠„Å´„Å§„ÅÑ„Å¶ÊßãÈÄ†„ÇíÊé¢„Åô
            for (const [tileKey, count] of Object.entries(counts)) {
                if (count >= 2) {
                    const newCounts = { ...counts };
                    newCounts[tileKey] -= 2;
                    const structures = findAllMeldStructures(newCounts, [], tileKey);
                    if (structures && structures.length > 0) {
                        allStructures.push(...structures);
                    }
                }
            }
            
            return {
                ÂèØËÉΩÊßãÈÄ†Êï∞: allStructures.length,
                ÂÖ®ÊßãÈÄ†: allStructures.map((structure, index) => ({
                    ÊßãÈÄ†Áï™Âè∑: index + 1,
                    ÈõÄÈ†≠: structure.pairs.map(pair => {
                        const key = Array.isArray(pair) ? pair.join('_') : pair;
                        const [suit, rank] = key.split('_');
                        return getTileDisplayName({suit, rank: parseInt(rank) || rank});
                    }).join(''),
                    ÂàªÂ≠ê: structure.triplets.map(triplet => 
                        triplet.map(key => {
                            const [suit, rank] = key.split('_');
                            return getTileDisplayName({suit, rank: parseInt(rank) || rank});
                        }).join('')
                    ).join(', '),
                    È†ÜÂ≠ê: structure.sequences.map(sequence => 
                        sequence.map(key => {
                            const [suit, rank] = key.split('_');
                            return getTileDisplayName({suit, rank: parseInt(rank) || rank});
                        }).join('')
                    ).join(', '),
                    ‰∏ÄÁõÉÂè£Âà§ÂÆö: structure.sequences.length >= 2 ? 
                        checkIipeikouInStructure(structure.sequences) : false
                })),
                „Éë„Çø„Éº„É≥ÂàÜÊûê: {
                    ÈÄ£Á∂ö„Éë„Çø„Éº„É≥: analyzeConsecutivePatterns(counts),
                    ÈáçË§áÂà§ÂÆö: analyzeOverlappingPatterns(counts)
                }
            };
        }

        // ÊßãÈÄ†ÂÜÖ„Åß„ÅÆ‰∏ÄÁõÉÂè£„ÉÅ„Çß„ÉÉ„ÇØ
        function checkIipeikouInStructure(sequences) {
            const sequenceStrings = sequences.map(seq => seq.join(''));
            const uniqueSequences = [...new Set(sequenceStrings)];
            return sequenceStrings.length > uniqueSequences.length;
        }

        // ÈÄ£Á∂ö„Éë„Çø„Éº„É≥ÂàÜÊûê
        function analyzeConsecutivePatterns(counts) {
            const patterns = [];
            const suits = ['man', 'pin', 'sou'];
            
            suits.forEach(suit => {
                for (let rank = 1; rank <= 7; rank++) {
                    const key1 = `${suit}_${rank}`;
                    const key2 = `${suit}_${rank + 1}`;
                    const key3 = `${suit}_${rank + 2}`;
                    
                    const count1 = counts[key1] || 0;
                    const count2 = counts[key2] || 0;
                    const count3 = counts[key3] || 0;
                    
                    if (count1 > 0 && count2 > 0 && count3 > 0) {
                        patterns.push({
                            ‰ΩçÁΩÆ: `${suit}_${rank}-${rank + 2}`,
                            ÊûöÊï∞: [count1, count2, count3],
                            ÊúÄÂ∞è: Math.min(count1, count2, count3),
                            „Éë„Çø„Éº„É≥: count1 === count2 && count2 === count3 ? 'ÂêåÊï∞' : 'Áï∞Êï∞'
                        });
                    }
                }
            });
            
            return patterns;
        }

        // ÈáçË§á„Éë„Çø„Éº„É≥ÂàÜÊûê
        function analyzeOverlappingPatterns(counts) {
            const overlaps = [];
            const suits = ['man', 'pin', 'sou'];
            
            suits.forEach(suit => {
                for (let rank = 1; rank <= 9; rank++) {
                    const key = `${suit}_${rank}`;
                    const count = counts[key] || 0;
                    
                    if (count >= 2) {
                        overlaps.push({
                            Áâå: getTileDisplayName({suit, rank}),
                            ÊûöÊï∞: count,
                            ÂèØËÉΩÊÄß: count >= 3 ? ['ÂàªÂ≠ê', 'ÈõÄÈ†≠'] : ['ÈõÄÈ†≠„ÅÆ„Åø']
                        });
                    }
                }
            });
            
            return overlaps;
        }

        // ÂæÖ„Å°ÁâåË°®Á§∫Êõ¥Êñ∞
        function updateWaitingTiles(waitingTiles, handState) {
            const container = document.getElementById('waitingTiles');
            container.innerHTML = '';

            // ÈÄöÂ∏∏„ÅÆÂæÖ„Å°ÁâåË°®Á§∫
            if (waitingTiles && waitingTiles.length > 0) {
                waitingTiles.forEach(tile => {
                    const tileElement = document.createElement('div');
                    tileElement.className = 'waiting-tile';
                    tileElement.textContent = getTileSymbol(tile);
                    container.appendChild(tileElement);
                });
                return;
            }

            // Êç®„Å¶Áâå„Åß„ÉÜ„É≥„Éë„Ç§ÂèØËÉΩ„Å™Â†¥Âêà„ÅÆË°®Á§∫
            if (handState && handState.discardToTenpai && handState.discardToTenpai.canReachTenpai) {
                const bestOption = handState.discardToTenpai.bestOption;
                
                const discardInfo = document.createElement('div');
                discardInfo.style.cssText = `
                    color: #FFD700; 
                    font-size: 12px; 
                    margin-bottom: 8px;
                    font-weight: bold;
                `;
                discardInfo.textContent = `${getTileDisplayName(bestOption.discardTile)}„ÇíÊç®„Å¶„Çå„Å∞„ÉÜ„É≥„Éë„Ç§`;
                container.appendChild(discardInfo);

                // Êç®„Å¶ÁâåÂæå„ÅÆÂæÖ„Å°Áâå„ÇíË°®Á§∫
                bestOption.waitingTiles.forEach(tile => {
                    const tileElement = document.createElement('div');
                    tileElement.className = 'waiting-tile';
                    tileElement.style.cssText += `
                        border: 1px dashed #FFD700;
                        background: rgba(255,215,0,0.1);
                    `;
                    tileElement.textContent = getTileSymbol(tile);
                    container.appendChild(tileElement);
                });

                const countInfo = document.createElement('div');
                countInfo.style.cssText = `
                    color: #AAA; 
                    font-size: 10px; 
                    margin-top: 4px;
                `;
                countInfo.textContent = `${bestOption.waitCount}Á®Æ${bestOption.totalWaitingTiles}ÊûöÂæÖ„Å°`;
                container.appendChild(countInfo);
                
                return;
            }

            // „Éá„Éï„Ç©„É´„ÉàË°®Á§∫
            container.innerHTML = '<div style="color: #999; font-size: 14px;">ÂæÖ„Å°Áâå„Å™„Åó</div>';
        }

        // ÂΩπË°®Á§∫Êõ¥Êñ∞
        function updateYakuDisplay(yaku) {
            const container = document.getElementById('yakuList');
            container.innerHTML = '';

            if (yaku.length === 0) {
                container.innerHTML = '<div class="yaku-item"><span>ÂΩπ„Å™„Åó</span><span>0Áøª</span></div>';
                return;
            }

            // ÂΩπ‰∏ÄË¶ßË°®Á§∫
            yaku.forEach(y => {
                const yakuElement = document.createElement('div');
                yakuElement.className = 'yaku-item';
                yakuElement.innerHTML = `<span>${y.name}</span><span>${y.han}Áøª</span>`;
                container.appendChild(yakuElement);
            });

            // Á¨¶„Å®ÁÇπÊï∞„ÅÆË©≥Á¥∞Ë°®Á§∫
            const totalHan = yaku.reduce((sum, y) => sum + y.han, 0);
            if (totalHan > 0) {
                const fuDetails = calculateDetailedFu(currentHand, yaku, isRon, winTile);
                const detailedPoints = calculateDetailedPoints(totalHan, fuDetails.total, gameSettings.playerWind === 'east');
                
                // Á¨¶„ÅÆË©≥Á¥∞Ë°®Á§∫
                const fuSectionElement = document.createElement('div');
                fuSectionElement.style.borderTop = '1px solid rgba(255,215,0,0.3)';
                fuSectionElement.style.marginTop = '8px';
                fuSectionElement.style.paddingTop = '8px';
                container.appendChild(fuSectionElement);
                
                // Á¨¶Ë®àÁÆóË©≥Á¥∞
                fuDetails.breakdown.forEach(item => {
                    const fuItemElement = document.createElement('div');
                    fuItemElement.className = 'yaku-item';
                    fuItemElement.style.fontSize = '12px';
                    fuItemElement.style.color = '#CCC';
                    fuItemElement.innerHTML = `<span>${item.source}</span><span>+${item.fu}Á¨¶</span>`;
                    container.appendChild(fuItemElement);
                });
                
                // Á¨¶ÂêàË®à
                const fuTotalElement = document.createElement('div');
                fuTotalElement.className = 'yaku-item';
                fuTotalElement.style.fontWeight = 'bold';
                fuTotalElement.innerHTML = `<span>Á¨¶Ë®à</span><span>${fuDetails.total}Á¨¶</span>`;
                container.appendChild(fuTotalElement);
                
                // ÁÇπÊï∞Ë°®Á§∫
                const pointElement = document.createElement('div');
                pointElement.className = 'yaku-item';
                pointElement.style.fontWeight = 'bold';
                pointElement.style.color = '#FFD700';
                pointElement.style.marginTop = '4px';
                pointElement.innerHTML = `<span>${detailedPoints.category}</span><span>${detailedPoints.ronPoints}ÁÇπ</span>`;
                container.appendChild(pointElement);
                
                // „ÉÑ„É¢ÁÇπÊï∞Ë°®Á§∫
                const tsumoElement = document.createElement('div');
                tsumoElement.className = 'yaku-item';
                tsumoElement.style.fontSize = '12px';
                tsumoElement.style.color = '#AAA';
                tsumoElement.innerHTML = `<span>„ÉÑ„É¢</span><span>${detailedPoints.tsumoPoints}</span>`;
                container.appendChild(tsumoElement);
            }
        }

        // „Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†±Êõ¥Êñ∞
        function updateDebugInfo(handState) {
            const container = document.getElementById('debugInfo');
            
            // Ë©≥Á¥∞„Å™ÂΩπÊÉÖÂ†±„ÇíÂê´„ÇÄ
            const yakuDetails = (handState.yaku || []).map(yaku => ({
                name: yaku.name,
                han: yaku.han,
                type: getYakuType(yaku.han)
            }));
            
            const totalHan = yakuDetails.reduce((sum, yaku) => sum + yaku.han, 0);
            
            // Á¨¶„Å®ÁÇπÊï∞„ÅÆË©≥Á¥∞Ë®àÁÆó
            const fuDetails = calculateDetailedFu(currentHand, handState.yaku || [], isRon, winTile);
            const detailedPoints = totalHan > 0 ? calculateDetailedPoints(totalHan, fuDetails.total, gameSettings.playerWind === 'east') : null;
            
            const debugData = {
                „Ç≤„Éº„É†Ë®≠ÂÆö: {
                    Â†¥È¢®: getWindName(gameSettings.gameWind),
                    Ëá™È¢®: getWindName(gameSettings.playerWind),
                    Â±ÄÊï∞: `${gameSettings.round}Â±Ä`,
                    Ë¶™ÂÆ∂: gameSettings.playerWind === 'east' ? '„ÅØ„ÅÑ' : '„ÅÑ„ÅÑ„Åà'
                },
                ÊâãÁâåÊÉÖÂ†±: {
                    ÊâãÁâå: currentHand.map(getTileDisplayName).join(' '),
                    „ÇΩ„Éº„ÉàÊ∏à„Åø: currentHand.map(tile => getTileKey(tile)).join(' '),
                    ÁâåÊßãÊàê: getTileCounts(currentHand)
                },
                ÊâãÁâåÂàÜÊûê: {
                    ÊûöÊï∞: currentHand.length,
                    Áä∂ÊÖã: handState.message,
                    ÂêëËÅ¥Êï∞: handState.shanten,
                    ÂÆåÊàê: handState.isComplete || false
                },
                ÂΩπÊÉÖÂ†±: {
                    ÂΩπÊï∞: yakuDetails.length,
                    Á∑èÁøªÊï∞: totalHan,
                    ÂΩπË©≥Á¥∞: yakuDetails,
                    Á¨¶Ë©≥Á¥∞: fuDetails,
                    ÁÇπÊï∞Ë©≥Á¥∞: detailedPoints,
                    Á∞°ÊòìÁÇπÊï∞: calculatePoints(totalHan)
                },
                ‰∏ä„Åå„ÇäË®≠ÂÆö: {
                    ‰∏ä„Åå„ÇäÁâå: winTile ? getTileDisplayName(winTile) : '„Å™„Åó',
                    Âíå‰∫ÜÊñπÊ≥ï: winTile ? (isRon ? '„É≠„É≥' : '„ÉÑ„É¢') : '„Å™„Åó'
                },
                ÂæÖ„Å°ÊÉÖÂ†±: {
                    ÂæÖ„Å°Á®ÆÈ°ûÊï∞: (handState.waitingTiles || []).length,
                    ÂæÖ„Å°Áâå: (handState.waitingTiles || []).map(getTileDisplayName)
                },
                „ÉÜ„É≥„Éë„Ç§ÂèØËÉΩÊÄß: handState.discardToTenpai ? {
                    Êç®„Å¶Áâå„Åß„ÉÜ„É≥„Éë„Ç§: handState.discardToTenpai.canReachTenpai,
                    ÈÅ∏ÊäûËÇ¢Êï∞: handState.discardToTenpai.tenpaiOptions.length,
                    ÊúÄÈÅ©Ëß£: handState.discardToTenpai.bestOption ? {
                        Êç®„Å¶Áâå: getTileDisplayName(handState.discardToTenpai.bestOption.discardTile),
                        ÂæÖ„Å°Á®ÆÈ°û: handState.discardToTenpai.bestOption.waitCount,
                        ÂæÖ„Å°Áâå: handState.discardToTenpai.bestOption.waitingTiles.map(getTileDisplayName).join(' ')
                    } : null,
                    ÂÖ®ÈÅ∏ÊäûËÇ¢: handState.discardToTenpai.tenpaiOptions.map(option => ({
                        Êç®„Å¶Áâå: getTileDisplayName(option.discardTile),
                        ÂæÖ„Å°: `${option.waitCount}Á®Æ`,
                        ÂæÖ„Å°Áâå: option.waitingTiles.map(getTileDisplayName).join(' ')
                    }))
                } : null,
                ÊâãÁâåÊßãÊàê: analyzeHandComposition(currentHand),
                Èù¢Â≠êÊßãÈÄ†: analyzeMeldStructureDebug(currentHand),
                ÂâØÈú≤ÊÉÖÂ†±: {
                    ÂâØÈú≤Êï∞: melds.length,
                    Ë©≥Á¥∞: melds.map(meld => ({
                        Á®ÆÈ°û: meld.type,
                        Áâå: meld.display,
                        ÂÜÖÈÉ®„Ç≠„Éº: meld.tiles
                    }))
                },
                Áµ±Ë®à: gameStats
            };
            
            container.textContent = JSON.stringify(debugData, null, 2);
        }

        // È¢®„ÅÆÂêçÂâçÂèñÂæó
        function getWindName(wind) {
            const windNames = { east: 'Êù±', south: 'Âçó', west: 'Ë•ø', north: 'Âåó' };
            return windNames[wind] || wind;
        }

        // ÂΩπ„ÅÆ„Çø„Ç§„Éó„ÇíÂèñÂæó
        function getYakuType(han) {
            if (han >= 13) return 'ÂΩπÊ∫Ä';
            if (han >= 6) return 'Ë∑≥Ê∫Ä‰ª•‰∏ä';
            if (han >= 3) return 'Ê∫ÄË≤´ÂÄôË£ú';
            if (han >= 2) return '‰∏≠ÂΩπ';
            return 'Âü∫Êú¨ÂΩπ';
        }

        // Á¨¶Ë®àÁÆóÔºàË©≥Á¥∞ÁâàÔºâ
        function calculateDetailedFu(hand, yaku, isRon = false, winTile = null) {
            if (!yaku || yaku.length === 0) return { total: 0, breakdown: [] };
            
            const breakdown = [];
            
            // ‰∏ÉÂØæÂ≠ê„ÅØ25Á¨¶Âõ∫ÂÆö
            if (yaku.some(y => y.name === '‰∏ÉÂØæÂ≠ê')) {
                breakdown.push({ source: '‰∏ÉÂØæÂ≠ê', fu: 25 });
                return { total: 25, breakdown };
            }
            
            // „Éî„É≥„Éï„ÅÆÂ†¥Âêà
            if (yaku.some(y => y.name === '„Éî„É≥„Éï')) {
                const fuValue = isRon ? 30 : 20;
                breakdown.push({ source: `„Éî„É≥„Éï(${isRon ? '„É≠„É≥' : '„ÉÑ„É¢'})`, fu: fuValue });
                return { total: fuValue, breakdown };
            }
            
            let fu = 20; // Âü∫Êú¨Á¨¶
            breakdown.push({ source: 'Âü∫Êú¨Á¨¶', fu: 20 });
            
            // ÂâØÈú≤„Éö„Éä„É´„ÉÜ„Ç£ÔºàÈñÄÂâç„Åß„Å™„ÅÑÂ†¥ÂêàÔºâ
            if (melds.length > 0) {
                fu = 30;
                breakdown[0] = { source: 'Âü∫Êú¨Á¨¶(ÂâØÈú≤)', fu: 30 };
            }
            
            // Âíå‰∫ÜÊñπÊ≥ï„Å´„Çà„ÇãÁ¨¶
            if (!isRon) {
                fu += 2;
                breakdown.push({ source: '„ÉÑ„É¢Âíå‰∫Ü', fu: 2 });
            }
            
            // ÈõÄÈ†≠„Å´„Çà„ÇãÁ¨¶
            const counts = getTileCounts(hand);
            
            // ÂâØÈú≤„Åã„Çâ„ÇÇ„Ç´„Ç¶„É≥„ÉàËøΩÂä†
            melds.forEach(meld => {
                if (meld.type === 'pon' || meld.type === 'kan' || meld.type === 'ankan') {
                    const key = meld.tiles[0];
                    counts[key] = (counts[key] || 0) + meld.tiles.length;
                }
            });
            
            // ÂΩπÁâåÈõÄÈ†≠
            for (const [key, count] of Object.entries(counts)) {
                if (count === 2) {
                    if (key === `honors_${gameSettings.gameWind}`) {
                        fu += 2;
                        breakdown.push({ source: 'Â†¥È¢®ÈõÄÈ†≠', fu: 2 });
                    }
                    if (key === `honors_${gameSettings.playerWind}`) {
                        fu += 2;
                        breakdown.push({ source: 'Ëá™È¢®ÈõÄÈ†≠', fu: 2 });
                    }
                    if (['honors_haku', 'honors_hatsu', 'honors_chun'].includes(key)) {
                        fu += 2;
                        const [suit, rank] = key.split('_');
                        const tileName = getTileDisplayName({ suit, type: rank });
                        breakdown.push({ source: `ÂΩπÁâåÈõÄÈ†≠(${tileName})`, fu: 2 });
                    }
                }
            }
            
            // ÊâãÁâå„ÅÆÈù¢Â≠ê„Å´„Çà„ÇãÁ¨¶
            for (const [key, count] of Object.entries(getTileCounts(hand))) {
                if (count >= 3) {
                    const [suit, rank] = key.split('_');
                    const isTerminal = (suit !== 'honors' && (rank === '1' || rank === '9')) || suit === 'honors';
                    const fuValue = isTerminal ? 8 : 4;
                    
                    let tileObj;
                    if (suit === 'honors') {
                        tileObj = { suit, type: rank };
                    } else {
                        tileObj = { suit, rank: parseInt(rank) };
                    }
                    const tileName = getTileDisplayName(tileObj);
                    
                    fu += fuValue;
                    breakdown.push({ 
                        source: `ÊöóÂàª(${tileName})`, 
                        fu: fuValue 
                    });
                }
            }
            
            // ÂâØÈú≤„ÅÆÈù¢Â≠ê„Å´„Çà„ÇãÁ¨¶
            melds.forEach(meld => {
                const [suit, rank] = meld.tiles[0].split('_');
                const isTerminal = (suit !== 'honors' && (rank === '1' || rank === '9')) || suit === 'honors';
                
                let tileObj;
                if (suit === 'honors') {
                    tileObj = { suit, type: rank };
                } else {
                    tileObj = { suit, rank: parseInt(rank) };
                }
                const tileName = getTileDisplayName(tileObj);
                
                if (meld.type === 'pon') {
                    const fuValue = isTerminal ? 4 : 2;
                    fu += fuValue;
                    breakdown.push({ source: `ÊòéÂàª(${tileName})`, fu: fuValue });
                } else if (meld.type === 'kan') {
                    const fuValue = isTerminal ? 16 : 8;
                    fu += fuValue;
                    breakdown.push({ source: `ÊòéÊßì(${tileName})`, fu: fuValue });
                } else if (meld.type === 'ankan') {
                    const fuValue = isTerminal ? 32 : 16;
                    fu += fuValue;
                    breakdown.push({ source: `ÊöóÊßì(${tileName})`, fu: fuValue });
                }
            });
            
            // ÂæÖ„Å°„Å´„Çà„ÇãÁ¨¶
            if (winTile) {
                const waitType = analyzeWaitPattern(hand, winTile);
                if (waitType.fu > 0) {
                    fu += waitType.fu;
                    breakdown.push({ source: waitType.name, fu: waitType.fu });
                }
            }
            
            // Á¨¶„ÅØ10„ÅÆ‰Ωç„ÅßÂàá„Çä‰∏ä„Åí
            const roundedFu = Math.ceil(fu / 10) * 10;
            if (roundedFu > fu) {
                breakdown.push({ source: 'Âàá„Çä‰∏ä„Åí', fu: roundedFu - fu });
            }
            
            return { total: roundedFu, breakdown };
        }

        // ÂæÖ„Å°„Éë„Çø„Éº„É≥ÂàÜÊûê
        function analyzeWaitPattern(hand, winTile) {
            // Á∞°ÊòìÁöÑ„Å™ÂæÖ„Å°„Éë„Çø„Éº„É≥Âà§ÂÆö
            // „Çà„ÇäË©≥Á¥∞„Å™ÂÆüË£Ö„ÅåÂøÖË¶Å„Å†„Åå„ÄÅÂü∫Êú¨ÁöÑ„Å™„Éë„Çø„Éº„É≥„ÇíÂà§ÂÆö
            
            const counts = getTileCounts(hand);
            const winKey = getTileKey(winTile);
            
            // ÈõÄÈ†≠ÂÆåÊàêÔºàÂçòÈ®éÂæÖ„Å°Ôºâ„ÅÆÂèØËÉΩÊÄß„Çí„ÉÅ„Çß„ÉÉ„ÇØ
            if (counts[winKey] === 2) {
                // ‰ªñ„ÅÆÈÉ®ÂàÜ„ÅåÂÖ®„Å¶Èù¢Â≠ê„Å´„Å™„Å£„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                const tempCounts = { ...counts };
                tempCounts[winKey] -= 2; // ÈõÄÈ†≠„ÇíÈô§Âéª
                
                if (isAllMelds(tempCounts)) {
                    return { name: 'ÂçòÈ®éÂæÖ„Å°', fu: 2 };
                }
            }
            
            // ÂµåÂºµ„ÉªËæ∫Âºµ„ÅÆÂà§ÂÆöÔºàÁ∞°ÊòìÁâàÔºâ
            const [suit, rank] = winKey.split('_');
            if (suit !== 'honors') {
                const rankNum = parseInt(rank);
                
                // ÂµåÂºµÔºàÁúü„Çì‰∏≠„ÅÆÁâå„ÅßÂÆåÊàêÔºâ
                if (rankNum >= 2 && rankNum <= 8) {
                    const before = `${suit}_${rankNum - 1}`;
                    const after = `${suit}_${rankNum + 1}`;
                    if (counts[before] >= 1 && counts[after] >= 1) {
                        return { name: 'ÂµåÂºµÂæÖ„Å°', fu: 2 };
                    }
                }
                
                // Ëæ∫ÂºµÔºà1-2„ÅÆ3ÂæÖ„Å°„ÄÅ8-9„ÅÆ7ÂæÖ„Å°Ôºâ
                if (rankNum === 3 && counts[`${suit}_1`] >= 1 && counts[`${suit}_2`] >= 1) {
                    return { name: 'Ëæ∫ÂºµÂæÖ„Å°', fu: 2 };
                }
                if (rankNum === 7 && counts[`${suit}_8`] >= 1 && counts[`${suit}_9`] >= 1) {
                    return { name: 'Ëæ∫ÂºµÂæÖ„Å°', fu: 2 };
                }
            }
            
            return { name: '‰∏°Èù¢ÂæÖ„Å°', fu: 0 };
        }

        // ÂÖ®„Å¶Èù¢Â≠ê„Åã„ÉÅ„Çß„ÉÉ„ÇØÔºàÁ∞°ÊòìÁâàÔºâ
        function isAllMelds(counts) {
            const entries = Object.entries(counts).filter(([_, count]) => count > 0);
            if (entries.length === 0) return true;
            
            for (const [key, count] of entries) {
                if (count >= 3) {
                    const newCounts = { ...counts };
                    newCounts[key] -= 3;
                    if (isAllMelds(newCounts)) return true;
                }
                
                const [suit, rank] = key.split('_');
                if (suit !== 'honors' && parseInt(rank) <= 7) {
                    const key1 = key;
                    const key2 = `${suit}_${parseInt(rank) + 1}`;
                    const key3 = `${suit}_${parseInt(rank) + 2}`;
                    
                    if (counts[key1] >= 1 && counts[key2] >= 1 && counts[key3] >= 1) {
                        const newCounts = { ...counts };
                        newCounts[key1] -= 1;
                        newCounts[key2] -= 1;
                        newCounts[key3] -= 1;
                        if (isAllMelds(newCounts)) return true;
                    }
                }
                
                break;
            }
            
            return false;
        }

        // Á¨¶Ë®àÁÆóÔºà‰∫íÊèõÊÄß„ÅÆ„Åü„ÇÅÔºâ
        function calculateFu(hand, yaku, isRon = false, winTile = null) {
            if (!yaku || yaku.length === 0) return 0;
            
            // ‰∏ÉÂØæÂ≠ê„ÅØ25Á¨¶Âõ∫ÂÆö
            if (yaku.some(y => y.name === '‰∏ÉÂØæÂ≠ê')) {
                return 25;
            }
            
            // „Éî„É≥„Éï„ÅÆÂ†¥Âêà
            if (yaku.some(y => y.name === '„Éî„É≥„Éï')) {
                return isRon ? 30 : 20; // „É≠„É≥„Å™„Çâ30Á¨¶„ÄÅ„ÉÑ„É¢„Å™„Çâ20Á¨¶
            }
            
            let fu = 20; // Âü∫Êú¨Á¨¶
            
            // ÂâØÈú≤„Éö„Éä„É´„ÉÜ„Ç£ÔºàÈñÄÂâç„Åß„Å™„ÅÑÂ†¥ÂêàÔºâ
            if (melds.length > 0) {
                fu = 30; // ÂâØÈú≤„ÅÇ„Çä„ÅØ30Á¨¶Âü∫Êú¨
            }
            
            // Âíå‰∫ÜÊñπÊ≥ï„Å´„Çà„ÇãÁ¨¶
            if (!isRon) {
                fu += 2; // „ÉÑ„É¢Âíå‰∫Ü
            }
            
            // ÈõÄÈ†≠„Å´„Çà„ÇãÁ¨¶
            const counts = getTileCounts(hand);
            
            // ÂâØÈú≤„Åã„Çâ„ÇÇ„Ç´„Ç¶„É≥„ÉàËøΩÂä†
            melds.forEach(meld => {
                if (meld.type === 'pon' || meld.type === 'kan' || meld.type === 'ankan') {
                    const key = meld.tiles[0];
                    counts[key] = (counts[key] || 0) + meld.tiles.length;
                }
            });
            
            // ÂΩπÁâåÈõÄÈ†≠
            for (const [key, count] of Object.entries(counts)) {
                if (count === 2) {
                    if (key === `honors_${gameSettings.gameWind}`) fu += 2; // Â†¥È¢®ÈõÄÈ†≠
                    if (key === `honors_${gameSettings.playerWind}`) fu += 2; // Ëá™È¢®ÈõÄÈ†≠
                    if (['honors_haku', 'honors_hatsu', 'honors_chun'].includes(key)) fu += 2; // ‰∏âÂÖÉÁâåÈõÄÈ†≠
                }
            }
            
            // Èù¢Â≠ê„Å´„Çà„ÇãÁ¨¶
            // ÊâãÁâå„ÅÆÂàªÂ≠ê
            for (const [key, count] of Object.entries(getTileCounts(hand))) {
                if (count >= 3) {
                    const [suit, rank] = key.split('_');
                    const isTerminal = (suit !== 'honors' && (rank === '1' || rank === '9')) || suit === 'honors';
                    fu += isTerminal ? 8 : 4; // Âπ∫‰πùÁâåÂàªÂ≠ê8Á¨¶„ÄÅ‰∏≠ÂºµÁâåÂàªÂ≠ê4Á¨¶
                }
            }
            
            // ÂâØÈú≤„ÅÆÈù¢Â≠ê
            melds.forEach(meld => {
                if (meld.type === 'pon') {
                    const [suit, rank] = meld.tiles[0].split('_');
                    const isTerminal = (suit !== 'honors' && (rank === '1' || rank === '9')) || suit === 'honors';
                    fu += isTerminal ? 4 : 2; // ÂâØÈú≤ÂàªÂ≠ê„ÅØÂçäÂàÜ
                } else if (meld.type === 'kan') {
                    const [suit, rank] = meld.tiles[0].split('_');
                    const isTerminal = (suit !== 'honors' && (rank === '1' || rank === '9')) || suit === 'honors';
                    fu += isTerminal ? 16 : 8; // ÊòéÊßì
                } else if (meld.type === 'ankan') {
                    const [suit, rank] = meld.tiles[0].split('_');
                    const isTerminal = (suit !== 'honors' && (rank === '1' || rank === '9')) || suit === 'honors';
                    fu += isTerminal ? 32 : 16; // ÊöóÊßì
                }
            });
            
            // ÂæÖ„Å°„Å´„Çà„ÇãÁ¨¶ÔºàÁ∞°ÊòìÁâàÔºâ
            if (winTile) {
                // ÂçòÈ®éÂæÖ„Å°„ÄÅÂµåÂºµÂæÖ„Å°„ÄÅËæ∫ÂºµÂæÖ„Å°„ÅÆÂ†¥Âêà+2Á¨¶
                // „Åì„Åì„Åß„ÅØÁ∞°ÊòìÁöÑ„Å´ÂÆüË£Ö
            }
            
            // Á¨¶„ÅØ10„ÅÆ‰Ωç„ÅßÂàá„Çä‰∏ä„Åí
            return Math.ceil(fu / 10) * 10;
        }

        // ÁÇπÊï∞Ë®àÁÆóÔºàË©≥Á¥∞ÁâàÔºâ
        function calculateDetailedPoints(han, fu, isParent = false) {
            if (han >= 13) {
                // ÂΩπÊ∫Ä
                return {
                    fu: fu,
                    han: han,
                    basePoints: isParent ? 48000 : 32000,
                    ronPoints: isParent ? 48000 : 32000,
                    tsumoPoints: isParent ? '16000„Ç™„Éº„É´' : '16000/8000',
                    category: 'ÂΩπÊ∫Ä'
                };
            }
            
            if (han >= 11) {
                // ‰∏âÂÄçÊ∫Ä
                return {
                    fu: fu,
                    han: han,
                    basePoints: isParent ? 36000 : 24000,
                    ronPoints: isParent ? 36000 : 24000,
                    tsumoPoints: isParent ? '12000„Ç™„Éº„É´' : '12000/6000',
                    category: '‰∏âÂÄçÊ∫Ä'
                };
            }
            
            if (han >= 8) {
                // ÂÄçÊ∫Ä
                return {
                    fu: fu,
                    han: han,
                    basePoints: isParent ? 24000 : 16000,
                    ronPoints: isParent ? 24000 : 16000,
                    tsumoPoints: isParent ? '8000„Ç™„Éº„É´' : '8000/4000',
                    category: 'ÂÄçÊ∫Ä'
                };
            }
            
            if (han >= 6) {
                // Ë∑≥Ê∫Ä
                return {
                    fu: fu,
                    han: han,
                    basePoints: isParent ? 18000 : 12000,
                    ronPoints: isParent ? 18000 : 12000,
                    tsumoPoints: isParent ? '6000„Ç™„Éº„É´' : '6000/3000',
                    category: 'Ë∑≥Ê∫Ä'
                };
            }
            
            if (han >= 5) {
                // Ê∫ÄË≤´
                return {
                    fu: fu,
                    han: han,
                    basePoints: isParent ? 12000 : 8000,
                    ronPoints: isParent ? 12000 : 8000,
                    tsumoPoints: isParent ? '4000„Ç™„Éº„É´' : '4000/2000',
                    category: 'Ê∫ÄË≤´'
                };
            }
            
            // ÈÄöÂ∏∏Ë®àÁÆó
            let basePoints = fu * Math.pow(2, han + 2);
            if (isParent) {
                basePoints = Math.ceil(basePoints * 1.5 / 100) * 100;
            } else {
                basePoints = Math.ceil(basePoints / 100) * 100;
            }
            
            const ronPoints = isParent ? basePoints * 6 : basePoints * 4;
            const tsumoChild = Math.ceil(basePoints / 100) * 100;
            const tsumoParent = Math.ceil(basePoints * 2 / 100) * 100;
            
            return {
                fu: fu,
                han: han,
                basePoints: basePoints,
                ronPoints: ronPoints,
                tsumoPoints: isParent ? `${tsumoChild}„Ç™„Éº„É´` : `${tsumoParent}/${tsumoChild}`,
                category: `${fu}Á¨¶${han}Áøª`
            };
        }

        // ÁÇπÊï∞Ë®àÁÆóÔºàÁ∞°ÊòìÁâà„ÉªÂæåÊñπ‰∫íÊèõÔºâ
        function calculatePoints(han) {
            if (han >= 13) return '8000ÁÇπÔºàÂΩπÊ∫ÄÔºâ';
            if (han >= 11) return '6000ÁÇπÔºà‰∏âÂÄçÊ∫ÄÔºâ';
            if (han >= 8) return '4000ÁÇπÔºàÂÄçÊ∫ÄÔºâ';
            if (han >= 6) return '3000ÁÇπÔºàË∑≥Ê∫ÄÔºâ';
            if (han >= 5) return '2000ÁÇπÔºàÊ∫ÄË≤´Ôºâ';
            if (han >= 1) return `${Math.min(2000, 30 * Math.pow(2, han + 2))}ÁÇπ`;
            return '0ÁÇπÔºàÂΩπ„Å™„ÅóÔºâ';
        }

        // ÊâãÁâåÊßãÊàêÂàÜÊûê
        function analyzeHandComposition(hand) {
            const suitCounts = { man: 0, pin: 0, sou: 0, honors: 0 };
            const rankDistribution = {};
            
            hand.forEach(tile => {
                suitCounts[tile.suit]++;
                
                if (tile.suit !== 'honors') {
                    const key = `${tile.suit}_${tile.rank}`;
                    rankDistribution[key] = (rankDistribution[key] || 0) + 1;
                } else {
                    const key = `honors_${tile.type}`;
                    rankDistribution[key] = (rankDistribution[key] || 0) + 1;
                }
            });
            
            return {
                „Çπ„Éº„ÉàÂàÜÂ∏É: suitCounts,
                ÁâπÂæ¥: getHandFeatures(hand),
                ÂΩ¢Áä∂: getHandShape(hand)
            };
        }

        // ÊâãÁâå„ÅÆÁâπÂæ¥„ÇíÂèñÂæó
        function getHandFeatures(hand) {
            const features = [];
            
            if (checkChiitoi(hand)) features.push('‰∏ÉÂØæÂ≠êÂΩ¢');
            if (checkKokushi(hand)) features.push('ÂõΩÂ£´ÁÑ°ÂèåÂΩ¢');
            if (checkTanyao(hand)) features.push('„Çø„É≥„É§„Ç™ÂΩ¢');
            if (hand.every(tile => tile.suit !== 'honors')) features.push('Êï∞Áâå„ÅÆ„Åø');
            if (hand.some(tile => tile.suit === 'honors')) features.push('Â≠óÁâåÂê´„Åø');
            
            const suits = new Set(hand.map(tile => tile.suit));
            if (suits.size === 1) features.push('‰∏ÄËâ≤');
            if (suits.size === 2 && suits.has('honors')) features.push('Ê∑∑‰∏ÄËâ≤ÂÄôË£ú');
            
            return features.length > 0 ? features : ['ÈÄöÂ∏∏ÂΩ¢'];
        }

        // ÊâãÁâåÂΩ¢Áä∂„ÇíÂèñÂæó
        function getHandShape(hand) {
            if (hand.length !== 14) return '‰∏çÂÆåÂÖ®';
            
            const counts = getTileCounts(hand);
            const values = Object.values(counts);
            
            const pairs = values.filter(count => count === 2).length;
            const triplets = values.filter(count => count === 3).length;
            const quads = values.filter(count => count === 4).length;
            
            if (pairs === 7) return '‰∏ÉÂØæÂ≠ê';
            if (quads > 0) return `ÊßìÂ≠ê${quads}ÂÄãÂê´„Åø`;
            
            // Ë©≥Á¥∞„Å™ÊßãÈÄ†ÂàÜÊûê
            const structure = analyzeHandStructure(hand);
            if (structure && structure.isComplete) {
                const sequenceCount = structure.sequences.length;
                const tripletCount = structure.triplets.length;
                
                if (sequenceCount === 4 && tripletCount === 0) {
                    return 'ÂõõÈ†ÜÂ≠ê‰∏ÄÈõÄÈ†≠';
                } else if (sequenceCount === 0 && tripletCount === 4) {
                    return 'ÂõõÂàªÂ≠ê‰∏ÄÈõÄÈ†≠';
                } else if (sequenceCount + tripletCount === 4) {
                    return `${sequenceCount}È†ÜÂ≠ê${tripletCount}ÂàªÂ≠ê‰∏ÄÈõÄÈ†≠`;
                }
            }
            
            if (triplets === 4 && pairs === 1) return 'ÂõõÈù¢Â≠ê‰∏ÄÈõÄÈ†≠';
            
            return 'ÊßãÈÄ†ÂàÜÊûê‰∏≠';
        }

        // „É≠„Ç∞Âá∫Âäõ
        function logDebug(message) {
            console.log(`[DEBUG] ${new Date().toLocaleTimeString()}: ${message}`);
        }

        // Ëá™ÂãïÂÆåÊàêÔºà„ÉÜ„Çπ„ÉàÁî®Ôºâ
        function autoComplete() {
            if (currentHand.length === 0) {
                dealNewHand();
            }

            // „ÉÜ„É≥„Éë„Ç§„Åæ„ÅßËá™ÂãïË™øÊï¥
            let attempts = 0;
            while (attempts < 100) {
                const handState = analyzeHandState(currentHand);
                if (handState.shanten <= 0) break;

                // „É©„É≥„ÉÄ„É†„Å´Áâå„Çí‰∫§Êèõ
                if (currentHand.length > 0) {
                    const randomIndex = Math.floor(Math.random() * currentHand.length);
                    currentHand.splice(randomIndex, 1);
                }

                const randomTile = allTileTypes[Math.floor(Math.random() * allTileTypes.length)];
                currentHand.push({ ...randomTile });
                attempts++;
            }

            updateHandDisplay();
            calculateStatus();
            logDebug(`Ëá™ÂãïÂÆåÊàêÂÆüË°å: ${attempts}ÂõûË©¶Ë°å`);
        }

        // ===== CPUÈ∫ªÈõÄ„Ç¢„É´„Ç¥„É™„Ç∫„É†ÈñãÁô∫Áî®Èñ¢Êï∞ =====

        // ÊúÄÈÅ©ÊâìÁâå„Ç∑„Éü„É•„É¨„Éº„Éà
        function simulateOptimalPlay() {
            if (currentHand.length === 0) {
                dealNewHand();
            }

            const originalHand = [...currentHand];
            logDebug('=== ÊúÄÈÅ©ÊâìÁâå„Ç∑„Éü„É•„É¨„Éº„ÉàÈñãÂßã ===');

            // ÁèæÂú®„ÅÆÊâãÁâå„Çí14Êûö„Å´„Åô„Çã
            while (currentHand.length < 14) {
                drawTile();
            }

            // ÂêÑÁâå„ÇíÊç®„Å¶„ÅüÂ†¥Âêà„ÅÆÂêëËÅ¥Êï∞Â§âÂåñ„ÇíÂàÜÊûê
            const discardAnalysis = [];
            
            for (let i = 0; i < currentHand.length; i++) {
                const testHand = [...currentHand];
                const discardedTile = testHand.splice(i, 1)[0];
                
                const handState = analyzeHandState(testHand);
                const improvement = calculateHandImprovement(testHand);
                
                discardAnalysis.push({
                    discardTile: discardedTile,
                    shanten: handState.shanten,
                    waitingTiles: handState.waitingTiles?.length || 0,
                    improvement: improvement,
                    efficiency: calculateEfficiency(testHand)
                });
            }

            // ÊúÄÈÅ©„Å™Êç®„Å¶Áâå„ÇíÊ±∫ÂÆö
            const bestDiscard = findBestDiscard(discardAnalysis);
            
            // ÁµêÊûú„ÇíË°®Á§∫
            displayDiscardAnalysis(discardAnalysis, bestDiscard);
            
            logDebug(`ÊúÄÈÅ©Êç®„Å¶Áâå: ${getTileDisplayName(bestDiscard.discardTile)}`);
        }

        // ÊúÄÈÅ©Êç®„Å¶ÁâåÂàÜÊûê
        function analyzeBestDiscard() {
            if (currentHand.length !== 14) {
                alert('ÊâãÁâå„Çí14Êûö„Å´„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
                return;
            }

            const analysis = performDetailedDiscardAnalysis(currentHand);
            displayDetailedAnalysis(analysis);
        }

        // Ë©≥Á¥∞„Å™Êç®„Å¶ÁâåÂàÜÊûê
        function performDetailedDiscardAnalysis(hand) {
            const analysis = {
                totalTiles: hand.length,
                uniqueTiles: new Set(hand.map(getTileKey)).size,
                suitDistribution: getSuitDistribution(hand),
                discardOptions: []
            };

            // ÂêÑÁâå„ÇíÊç®„Å¶„ÅüÂ†¥Âêà„ÅÆË©≥Á¥∞ÂàÜÊûê
            for (let i = 0; i < hand.length; i++) {
                const testHand = [...hand];
                const discardTile = testHand.splice(i, 1)[0];
                
                const option = {
                    tile: discardTile,
                    resultingShanten: calculateShanten(testHand),
                    waitingTiles: getWaitingTiles(testHand),
                    futureProspects: calculateFutureProspects(testHand),
                    riskAssessment: assessDiscardRisk(discardTile),
                    score: 0 // Á∑èÂêà„Çπ„Ç≥„Ç¢
                };

                // Á∑èÂêà„Çπ„Ç≥„Ç¢Ë®àÁÆó
                option.score = calculateDiscardScore(option);
                analysis.discardOptions.push(option);
            }

            // „Çπ„Ç≥„Ç¢È†Ü„Å´„ÇΩ„Éº„Éà
            analysis.discardOptions.sort((a, b) => b.score - a.score);
            
            return analysis;
        }

        // ÊâãÁâåÊîπÂñÑÂ∫¶Ë®àÁÆó
        function calculateHandImprovement(hand) {
            const shanten = calculateShanten(hand);
            const waitingCount = getWaitingTiles(hand).length;
            
            // ÂêëËÅ¥Êï∞„Åå‰Ωé„ÅÑ„Åª„Å©„ÄÅÂæÖ„Å°Áâå„ÅåÂ§ö„ÅÑ„Åª„Å©ËâØ„ÅÑ
            return (8 - shanten) * 10 + waitingCount;
        }

        // ÂäπÁéáÊÄßË®àÁÆó
        function calculateEfficiency(hand) {
            const counts = getTileCounts(hand);
            let efficiency = 0;

            // ÂØæÂ≠ê„ÅÆ‰æ°ÂÄ§
            Object.values(counts).forEach(count => {
                if (count === 2) efficiency += 2; // ÂØæÂ≠ê
                if (count >= 3) efficiency += 5; // ÂàªÂ≠ê
            });

            // È†ÜÂ≠ê„ÅÆÂèØËÉΩÊÄß
            ['man', 'pin', 'sou'].forEach(suit => {
                for (let rank = 1; rank <= 7; rank++) {
                    const key1 = `${suit}_${rank}`;
                    const key2 = `${suit}_${rank + 1}`;
                    const key3 = `${suit}_${rank + 2}`;
                    
                    if (counts[key1] && counts[key2] && counts[key3]) {
                        efficiency += 3; // ÂÆåÊàê„Åó„ÅüÈ†ÜÂ≠ê
                    } else if ((counts[key1] && counts[key2]) || 
                              (counts[key2] && counts[key3]) || 
                              (counts[key1] && counts[key3])) {
                        efficiency += 1; // È†ÜÂ≠ê„ÅÆÂèØËÉΩÊÄß
                    }
                }
            });

            return efficiency;
        }

        // È≥¥„ÅçÂà§ÂÆöÂàÜÊûê
        function analyzeMeldPossibilities(hand) {
            const counts = getTileCounts(hand);
            const analysis = {
                pon: [],
                chi: [],
                kan: [],
                ankan: []
            };

            // „Éù„É≥Âà§ÂÆö (Âêå„ÅòÁâå„Åå2Êûö‰ª•‰∏ä)
            for (const [tileKey, count] of Object.entries(counts)) {
                if (count >= 2) {
                    const [suit, rank] = tileKey.split('_');
                    let tileObj;
                    if (suit === 'honors') {
                        tileObj = { suit, type: rank };
                    } else {
                        tileObj = { suit, rank: parseInt(rank) };
                    }
                    const tileName = getTileDisplayName(tileObj);
                    analysis.pon.push({
                        tile: tileName,
                        count: count,
                        key: tileKey
                    });
                }
            }

            // „ÉÅ„ÉºÂà§ÂÆö (È†ÜÂ≠ê„ÅÆÂèØËÉΩÊÄß)
            ['man', 'pin', 'sou'].forEach(suit => {
                for (let rank = 1; rank <= 7; rank++) {
                    const patterns = [
                        // AB_„Éë„Çø„Éº„É≥ (C„ÇíÂèñ„Çã)
                        { keys: [`${suit}_${rank}`, `${suit}_${rank + 1}`], need: `${suit}_${rank + 2}` },
                        // A_C„Éë„Çø„Éº„É≥ (B„ÇíÂèñ„Çã)  
                        { keys: [`${suit}_${rank}`, `${suit}_${rank + 2}`], need: `${suit}_${rank + 1}` },
                        // _BC„Éë„Çø„Éº„É≥ (A„ÇíÂèñ„Çã)
                        { keys: [`${suit}_${rank + 1}`, `${suit}_${rank + 2}`], need: `${suit}_${rank}` }
                    ];

                    patterns.forEach(pattern => {
                        if (pattern.keys.every(key => counts[key] >= 1)) {
                            const [needSuit, needRank] = pattern.need.split('_');
                            const needTile = getTileDisplayName({
                                suit: needSuit,
                                rank: parseInt(needRank)
                            });
                            const haveTiles = pattern.keys.map(key => {
                                const [s, r] = key.split('_');
                                return getTileDisplayName({ suit: s, rank: parseInt(r) });
                            }).join('');
                            
                            analysis.chi.push({
                                sequence: `${haveTiles}+${needTile}`,
                                have: haveTiles,
                                need: needTile,
                                needKey: pattern.need
                            });
                        }
                    });
                }
            });

            // „Ç´„É≥Âà§ÂÆö (Âêå„ÅòÁâå„Åå3Êûö)
            for (const [tileKey, count] of Object.entries(counts)) {
                if (count >= 3) {
                    const [suit, rank] = tileKey.split('_');
                    let tileObj;
                    if (suit === 'honors') {
                        tileObj = { suit, type: rank };
                    } else {
                        tileObj = { suit, rank: parseInt(rank) };
                    }
                    const tileName = getTileDisplayName(tileObj);
                    analysis.kan.push({
                        tile: tileName,
                        count: count,
                        key: tileKey
                    });
                }
            }

            // „Ç¢„É≥„Ç´„É≥Âà§ÂÆö (Âêå„ÅòÁâå„Åå4Êûö)
            for (const [tileKey, count] of Object.entries(counts)) {
                if (count >= 4) {
                    const [suit, rank] = tileKey.split('_');
                    let tileObj;
                    if (suit === 'honors') {
                        tileObj = { suit, type: rank };
                    } else {
                        tileObj = { suit, rank: parseInt(rank) };
                    }
                    const tileName = getTileDisplayName(tileObj);
                    analysis.ankan.push({
                        tile: tileName,
                        count: count,
                        key: tileKey
                    });
                }
            }

            return analysis;
        }

        // È≥¥„ÅçÂà§ÂÆöË°®Á§∫Êõ¥Êñ∞
        function updateMeldAnalysis() {
            const analysis = analyzeMeldPossibilities(currentHand);
            const container = document.getElementById('meldAnalysis');
            
            let html = '';
            
            // „Éù„É≥
            html += '<div class="meld-option pon"><strong>„Éù„É≥ÂèØËÉΩ:</strong><br>';
            if (analysis.pon.length > 0) {
                analysis.pon.forEach(p => {
                    html += `${p.tile} (${p.count}Êûö)<br>`;
                });
            } else {
                html += '„Å™„Åó<br>';
            }
            html += '</div>';

            // „ÉÅ„Éº  
            html += '<div class="meld-option chi"><strong>„ÉÅ„ÉºÂèØËÉΩ:</strong><br>';
            if (analysis.chi.length > 0) {
                analysis.chi.forEach(c => {
                    html += `${c.have} + ${c.need}<br>`;
                });
            } else {
                html += '„Å™„Åó<br>';
            }
            html += '</div>';

            // „Ç´„É≥
            html += '<div class="meld-option kan"><strong>„Ç´„É≥ÂèØËÉΩ:</strong><br>';
            if (analysis.kan.length > 0) {
                analysis.kan.forEach(k => {
                    html += `${k.tile} (${k.count}Êûö)<br>`;
                });
            } else {
                html += '„Å™„Åó<br>';
            }
            html += '</div>';

            // „Ç¢„É≥„Ç´„É≥
            html += '<div class="meld-option ankan"><strong>„Ç¢„É≥„Ç´„É≥ÂèØËÉΩ:</strong><br>';
            if (analysis.ankan.length > 0) {
                analysis.ankan.forEach(a => {
                    html += `${a.tile} (${a.count}Êûö)<br>`;
                });
            } else {
                html += '„Å™„Åó<br>';
            }
            html += '</div>';

            container.innerHTML = html;
        }

        // ÂΩì„Åü„ÇäÁâåÂàÜÊûêÊõ¥Êñ∞
        function updateWinningTilesAnalysis() {
            const container = document.getElementById('winningTilesAnalysis');
            
            // ÂâØÈú≤„ÇíËÄÉÊÖÆ„Åó„ÅüÂÆüË≥™ÊâãÁâåÊûöÊï∞„Çí„ÉÅ„Çß„ÉÉ„ÇØ
            const totalTiles = currentHand.length + melds.reduce((sum, meld) => sum + meld.tiles.length, 0);
            const expectedTiles = totalTiles === 13 ? 13 : (totalTiles === 14 ? 14 : 0);
            
            if (expectedTiles === 0) {
                container.innerHTML = '<div style="color: #999;">ÊâãÁâå+ÂâØÈú≤=13Êûö„Åæ„Åü„ÅØ14Êûö„Åß„ÉÜ„É≥„Éë„Ç§Âà§ÂÆö</div>';
                return;
            }
            
            // „ÉÜ„É≥„Éë„Ç§Âà§ÂÆöÔºö13ÊûöÁõ∏ÂΩì„ÅÆÂ†¥Âêà
            let waitingTiles = [];
            if (expectedTiles === 13) {
                waitingTiles = getCustomWaitingTiles(currentHand);
            } else if (expectedTiles === 14) {
                // 14Êûö„ÅÆÂ†¥Âêà„ÄÅ1ÊûöÊç®„Å¶„Å¶„ÉÜ„É≥„Éë„Ç§„Å´„Å™„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                for (let i = 0; i < currentHand.length; i++) {
                    const testHand = [...currentHand];
                    testHand.splice(i, 1);
                    const testWaiting = getCustomWaitingTiles(testHand);
                    waitingTiles.push(...testWaiting);
                }
                // ÈáçË§áÈô§Âéª
                waitingTiles = waitingTiles.filter((tile, index, self) => 
                    index === self.findIndex(t => getTileKey(t) === getTileKey(tile))
                );
            }
            
            if (waitingTiles.length === 0) {
                container.innerHTML = '<div style="color: #999;">„ÉÜ„É≥„Éë„Ç§„Åó„Å¶„ÅÑ„Åæ„Åõ„Çì</div>';
                return;
            }
            
            let html = '<div class="winning-tile-header">üéØ ÂΩì„Åü„ÇäÁâåÂàÜÊûê</div>';
            
            // ÂêÑÂΩì„Åü„ÇäÁâå„Å´„Å§„ÅÑ„Å¶Ë©≥Á¥∞ÂàÜÊûê
            waitingTiles.forEach(tile => {
                const testHand = [...currentHand, tile];
                const yaku = calculateYaku(testHand);
                const totalHan = yaku.reduce((sum, y) => sum + y.han, 0);
                
                if (totalHan > 0) {
                    // „É≠„É≥„Å®„ÉÑ„É¢„ÅÆ‰∏°Êñπ„ÇíË®àÁÆó
                    const ronFuDetails = calculateDetailedFu(testHand, yaku, true, tile);
                    const tsumoFuDetails = calculateDetailedFu(testHand, yaku, false, tile);
                    
                    const ronPoints = calculateDetailedPoints(totalHan, ronFuDetails.total, gameSettings.playerWind === 'east');
                    const tsumoPoints = calculateDetailedPoints(totalHan, tsumoFuDetails.total, gameSettings.playerWind === 'east');
                    
                    const waitType = analyzeWaitPattern(currentHand, tile);
                    
                    html += `
                        <div class="winning-tile-item">
                            <div class="winning-tile-header">
                                ${getTileDisplayName(tile)} (${waitType.name})
                            </div>
                            <div class="winning-tile-details">
                                <div>ÂΩπ: ${yaku.map(y => y.name).join(', ')} (${totalHan}Áøª)</div>
                                <div>„É≠„É≥: ${ronFuDetails.total}Á¨¶ ‚Üí ${ronPoints.ronPoints}ÁÇπ</div>
                                <div>„ÉÑ„É¢: ${tsumoFuDetails.total}Á¨¶ ‚Üí ${tsumoPoints.tsumoPoints}</div>
                            </div>
                        </div>
                    `;
                } else {
                    // ÂΩπ„Å™„Åó„ÅÆÂ†¥Âêà
                    html += `
                        <div class="winning-tile-item" style="border-left-color: #e74c3c;">
                            <div class="winning-tile-header">
                                ${getTileDisplayName(tile)} (ÂΩπ„Å™„Åó)
                            </div>
                            <div class="winning-tile-details">
                                <div style="color: #e74c3c;">‰∏ä„Åå„Çå„Åæ„Åõ„ÇìÔºàÂΩπ„Å™„ÅóÔºâ</div>
                            </div>
                        </div>
                    `;
                }
            });
            
            // ÂΩì„Åü„ÇäÁâåÁµ±Ë®à
            const validWins = waitingTiles.filter(tile => {
                const testHand = [...currentHand, tile];
                const yaku = calculateYaku(testHand);
                return yaku.reduce((sum, y) => sum + y.han, 0) > 0;
            });
            
            html += `
                <div class="winning-tile-item" style="border-left-color: #3498db;">
                    <div class="winning-tile-header">üìä Áµ±Ë®à</div>
                    <div class="winning-tile-details">
                        <div>ÂæÖ„Å°: ${waitingTiles.length}Á®ÆÈ°û</div>
                        <div>ÊúâÂäπ: ${validWins.length}Á®ÆÈ°û</div>
                        <div>ÁÑ°Âäπ: ${waitingTiles.length - validWins.length}Á®ÆÈ°û</div>
                    </div>
                </div>
            `;
            
            container.innerHTML = html;
        }

        // ÂâØÈú≤„ÇíËÄÉÊÖÆ„Åó„ÅüÂæÖ„Å°ÁâåË®àÁÆó
        function getCustomWaitingTiles(hand) {
            if (!hand || hand.length === 0) return [];
            
            const waitingTiles = [];
            
            for (const testTile of allTileTypes) {
                const testHand = [...hand, testTile];
                if (isCustomWinningShape(testHand)) {
                    waitingTiles.push(testTile);
                }
            }
            
            return waitingTiles;
        }

        // ÂâØÈú≤„ÇíËÄÉÊÖÆ„Åó„ÅüÂíå‰∫ÜÂΩ¢Âà§ÂÆö
        function isCustomWinningShape(hand) {
            if (!hand || hand.length === 0) return false;
            
            // ÂâØÈú≤„ÇíËÄÉÊÖÆ„Åó„ÅüÁ∑èÁâåÊï∞„ÉÅ„Çß„ÉÉ„ÇØ
            const totalTiles = hand.length + melds.reduce((sum, meld) => sum + meld.tiles.length, 0);
            if (totalTiles !== 14) return false;
            
            // ÊâãÁâå„ÅÆÂíå‰∫ÜÂΩ¢„ÉÅ„Çß„ÉÉ„ÇØ
            const counts = getTileCounts(hand);
            
            // ÂâØÈú≤„ÅÆÈù¢Â≠ê„ÅØÊó¢„Å´ÂÆåÊàê„Åó„Å¶„ÅÑ„Çã„Å®„Åó„Å¶Èô§Â§ñ„Åó„ÄÅÊâãÁâå„ÅÆ„Åø„ÅßÊÆã„Çä„ÅÆÈù¢Â≠ê+ÈõÄÈ†≠„Çí‰Ωú„Çå„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
            const requiredMelds = 4 - melds.length; // ÂøÖË¶Å„Å™Èù¢Â≠êÊï∞
            const requiredPairs = 1; // ÈõÄÈ†≠„ÅØÂ∏∏„Å´1„Å§
            
            return checkCustomMeldsRecursive(counts, 0, requiredMelds, requiredPairs);
        }

        // ÂâØÈú≤„ÇíËÄÉÊÖÆ„Åó„ÅüÈù¢Â≠êÂà§ÂÆöÔºàÂÜçÂ∏∞Ôºâ
        function checkCustomMeldsRecursive(counts, pairCount, requiredMelds, requiredPairs) {
            const entries = Object.entries(counts).filter(([_, count]) => count > 0);
            
            if (entries.length === 0) {
                return pairCount === requiredPairs && requiredMelds === 0;
            }
            
            for (const [tileKey, count] of entries) {
                // ÈõÄÈ†≠„Çí‰Ωú„Çã
                if (count >= 2 && pairCount < requiredPairs) {
                    const newCounts = { ...counts };
                    newCounts[tileKey] -= 2;
                    if (checkCustomMeldsRecursive(newCounts, pairCount + 1, requiredMelds, requiredPairs)) {
                        return true;
                    }
                }
                
                // ÂàªÂ≠ê„Çí‰Ωú„Çã
                if (count >= 3 && requiredMelds > 0) {
                    const newCounts = { ...counts };
                    newCounts[tileKey] -= 3;
                    if (checkCustomMeldsRecursive(newCounts, pairCount, requiredMelds - 1, requiredPairs)) {
                        return true;
                    }
                }
                
                // È†ÜÂ≠ê„Çí‰Ωú„Çã
                const [suit, rank] = tileKey.split('_');
                if (suit !== 'honors' && parseInt(rank) <= 7 && requiredMelds > 0) {
                    const key1 = `${suit}_${parseInt(rank)}`;
                    const key2 = `${suit}_${parseInt(rank) + 1}`;
                    const key3 = `${suit}_${parseInt(rank) + 2}`;
                    
                    if (counts[key1] >= 1 && counts[key2] >= 1 && counts[key3] >= 1) {
                        const newCounts = { ...counts };
                        newCounts[key1] -= 1;
                        newCounts[key2] -= 1;
                        newCounts[key3] -= 1;
                        if (checkCustomMeldsRecursive(newCounts, pairCount, requiredMelds - 1, requiredPairs)) {
                            return true;
                        }
                    }
                }
                
                break; // ÊúÄÂàù„ÅÆÁâå„ÅÆ„ÅøË©¶Ë°å„Åó„Å¶ÂäπÁéáÂåñ
            }
            
            return false;
        }

        // ÂâØÈú≤„Éá„Éº„ÇøÁÆ°ÁêÜ
        let melds = []; // Êôí„Åó„ÅüÈù¢Â≠ê„Çí‰øùÂ≠ò
        
        // ‰∏ä„Åå„ÇäÁâåÁÆ°ÁêÜ
        let winTile = null; // ‰∏ä„Åå„ÇäÁâå
        let isRon = false; // „É≠„É≥Âíå‰∫Ü„Åã„Å©„ÅÜ„Åã

        // ‰∏ä„Åå„ÇäÁâåÈÅ∏Êäû
        function selectWinTile() {
            if (currentHand.length === 0) {
                alert('ÊâãÁâå„Åå„ÅÇ„Çä„Åæ„Åõ„Çì');
                return;
            }

            const tiles = [...currentHand];
            const options = tiles.map((tile, index) => `${index + 1}: ${getTileDisplayName(tile)}`).join('\n');
            const input = prompt(`‰∏ä„Åå„ÇäÁâå„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ:\n${options}\n\nÁï™Âè∑„ÇíÂÖ•Âäõ:`);
            
            if (input) {
                const index = parseInt(input) - 1;
                if (index >= 0 && index < tiles.length) {
                    winTile = tiles[index];
                    
                    // „É≠„É≥/„ÉÑ„É¢„ÅÆÈÅ∏Êäû
                    const ronChoice = confirm('„É≠„É≥Âíå‰∫Ü„Åß„Åô„ÅãÔºü\nOK: „É≠„É≥, „Ç≠„É£„É≥„Çª„É´: „ÉÑ„É¢');
                    isRon = ronChoice;
                    
                    updateWinTileDisplay();
                    calculateStatus();
                } else {
                    alert('ÁÑ°Âäπ„Å™ÈÅ∏Êäû„Åß„Åô');
                }
            }
        }

        // ‰∏ä„Åå„ÇäÁâå„ÇØ„É™„Ç¢
        function clearWinTile() {
            winTile = null;
            isRon = false;
            updateWinTileDisplay();
            calculateStatus();
        }

        // ‰∏ä„Åå„ÇäÁâåË°®Á§∫Êõ¥Êñ∞
        function updateWinTileDisplay() {
            const display = document.getElementById('winTileDisplay');
            if (winTile) {
                const method = isRon ? '„É≠„É≥' : '„ÉÑ„É¢';
                display.textContent = `‰∏ä„Åå„ÇäÁâå: ${getTileDisplayName(winTile)} (${method})`;
            } else {
                display.textContent = '‰∏ä„Åå„ÇäÁâå: „Å™„Åó';
            }
        }

        // È≥¥„ÅçÂÆüË°åÈñ¢Êï∞
        function executePon() {
            const analysis = analyzeMeldPossibilities(currentHand);
            if (analysis.pon.length === 0) {
                alert('„Éù„É≥„Åß„Åç„ÇãÁâå„Åå„ÅÇ„Çä„Åæ„Åõ„Çì');
                return;
            }

            // ÈÅ∏ÊäûËÇ¢„ÇíË°®Á§∫
            let choice = '';
            if (analysis.pon.length === 1) {
                choice = analysis.pon[0].tile;
            } else {
                const options = analysis.pon.map((p, i) => `${i + 1}: ${p.tile} (${p.count}Êûö)`).join('\n');
                const input = prompt(`„Éù„É≥„Åô„ÇãÁâå„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ:\n${options}\n\nÁï™Âè∑„ÇíÂÖ•Âäõ:`);
                const index = parseInt(input) - 1;
                if (index >= 0 && index < analysis.pon.length) {
                    choice = analysis.pon[index].tile;
                } else {
                    alert('ÁÑ°Âäπ„Å™ÈÅ∏Êäû„Åß„Åô');
                    return;
                }
            }

            // „Éù„É≥ÂÆüË°å
            if (choice) {
                executeMeld('pon', choice, analysis.pon.find(p => p.tile === choice));
            }
        }

        function executeChi() {
            const analysis = analyzeMeldPossibilities(currentHand);
            if (analysis.chi.length === 0) {
                alert('„ÉÅ„Éº„Åß„Åç„ÇãÁµÑ„ÅøÂêà„Çè„Åõ„Åå„ÅÇ„Çä„Åæ„Åõ„Çì');
                return;
            }

            // ÈÅ∏ÊäûËÇ¢„ÇíË°®Á§∫
            let choice = null;
            if (analysis.chi.length === 1) {
                choice = analysis.chi[0];
            } else {
                const options = analysis.chi.map((c, i) => `${i + 1}: ${c.sequence}`).join('\n');
                const input = prompt(`„ÉÅ„Éº„Åô„ÇãÁµÑ„ÅøÂêà„Çè„Åõ„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ:\n${options}\n\nÁï™Âè∑„ÇíÂÖ•Âäõ:`);
                const index = parseInt(input) - 1;
                if (index >= 0 && index < analysis.chi.length) {
                    choice = analysis.chi[index];
                } else {
                    alert('ÁÑ°Âäπ„Å™ÈÅ∏Êäû„Åß„Åô');
                    return;
                }
            }

            // „ÉÅ„ÉºÂÆüË°å
            if (choice) {
                executeMeld('chi', choice.sequence, choice);
            }
        }

        function executeKan() {
            const analysis = analyzeMeldPossibilities(currentHand);
            if (analysis.kan.length === 0) {
                alert('„Ç´„É≥„Åß„Åç„ÇãÁâå„Åå„ÅÇ„Çä„Åæ„Åõ„Çì');
                return;
            }

            // ÈÅ∏ÊäûËÇ¢„ÇíË°®Á§∫
            let choice = '';
            if (analysis.kan.length === 1) {
                choice = analysis.kan[0].tile;
            } else {
                const options = analysis.kan.map((k, i) => `${i + 1}: ${k.tile} (${k.count}Êûö)`).join('\n');
                const input = prompt(`„Ç´„É≥„Åô„ÇãÁâå„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ:\n${options}\n\nÁï™Âè∑„ÇíÂÖ•Âäõ:`);
                const index = parseInt(input) - 1;
                if (index >= 0 && index < analysis.kan.length) {
                    choice = analysis.kan[index].tile;
                } else {
                    alert('ÁÑ°Âäπ„Å™ÈÅ∏Êäû„Åß„Åô');
                    return;
                }
            }

            // „Ç´„É≥ÂÆüË°å
            if (choice) {
                executeMeld('kan', choice, analysis.kan.find(k => k.tile === choice));
            }
        }

        function executeAnkan() {
            const analysis = analyzeMeldPossibilities(currentHand);
            if (analysis.ankan.length === 0) {
                alert('„Ç¢„É≥„Ç´„É≥„Åß„Åç„ÇãÁâå„Åå„ÅÇ„Çä„Åæ„Åõ„Çì');
                return;
            }

            // ÈÅ∏ÊäûËÇ¢„ÇíË°®Á§∫
            let choice = '';
            if (analysis.ankan.length === 1) {
                choice = analysis.ankan[0].tile;
            } else {
                const options = analysis.ankan.map((a, i) => `${i + 1}: ${a.tile} (${a.count}Êûö)`).join('\n');
                const input = prompt(`„Ç¢„É≥„Ç´„É≥„Åô„ÇãÁâå„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ:\n${options}\n\nÁï™Âè∑„ÇíÂÖ•Âäõ:`);
                const index = parseInt(input) - 1;
                if (index >= 0 && index < analysis.ankan.length) {
                    choice = analysis.ankan[index].tile;
                } else {
                    alert('ÁÑ°Âäπ„Å™ÈÅ∏Êäû„Åß„Åô');
                    return;
                }
            }

            // „Ç¢„É≥„Ç´„É≥ÂÆüË°å
            if (choice) {
                executeMeld('ankan', choice, analysis.ankan.find(a => a.tile === choice));
            }
        }

        // È≥¥„ÅçÂÆüË°åÂá¶ÁêÜ
        function executeMeld(type, displayName, data) {
            const counts = getTileCounts(currentHand);
            
            switch (type) {
                case 'pon':
                    // „Éù„É≥: Âêå„ÅòÁâå3Êûö„ÇíÊâãÁâå„Åã„ÇâÂâäÈô§
                    removeTilesFromHand(data.key, 3);
                    melds.push({
                        type: 'pon',
                        tiles: [data.key, data.key, data.key],
                        display: displayName + displayName + displayName
                    });
                    break;
                    
                case 'chi':
                    // „ÉÅ„Éº: È†ÜÂ≠ê3Êûö„ÇíÊâãÁâå„Åã„ÇâÂâäÈô§
                    // data.needKey„Åã„ÇâÈ†ÜÂ≠ê„ÅÆ3Êûö„ÅÆ„Ç≠„Éº„ÇíË®àÁÆó
                    const [needSuit, needRank] = data.needKey.split('_');
                    const needRankNum = parseInt(needRank);
                    
                    // È†ÜÂ≠ê„ÅÆ„Éë„Çø„Éº„É≥„ÇíÁâπÂÆö
                    let chiKeys = [];
                    if (counts[`${needSuit}_${needRankNum - 2}`] && counts[`${needSuit}_${needRankNum - 1}`]) {
                        // ABC „ÅÆ C „ÇíÂèñ„ÇãÂ†¥Âêà
                        chiKeys = [`${needSuit}_${needRankNum - 2}`, `${needSuit}_${needRankNum - 1}`, data.needKey];
                    } else if (counts[`${needSuit}_${needRankNum - 1}`] && counts[`${needSuit}_${needRankNum + 1}`]) {
                        // ABC „ÅÆ B „ÇíÂèñ„ÇãÂ†¥Âêà
                        chiKeys = [`${needSuit}_${needRankNum - 1}`, data.needKey, `${needSuit}_${needRankNum + 1}`];
                    } else if (counts[`${needSuit}_${needRankNum + 1}`] && counts[`${needSuit}_${needRankNum + 2}`]) {
                        // ABC „ÅÆ A „ÇíÂèñ„ÇãÂ†¥Âêà
                        chiKeys = [data.needKey, `${needSuit}_${needRankNum + 1}`, `${needSuit}_${needRankNum + 2}`];
                    }
                    
                    // ÊâãÁâå„Åã„ÇâÂâäÈô§ÔºàÂèñÂæóÁâå‰ª•Â§ñ„ÅÆ2ÊûöÔºâ
                    chiKeys.forEach(key => {
                        if (key !== data.needKey) {
                            removeTilesFromHand(key, 1);
                        }
                    });
                    
                    melds.push({
                        type: 'chi',
                        tiles: chiKeys,
                        display: chiKeys.map(key => {
                            const [suit, rank] = key.split('_');
                            return getTileDisplayName({suit, rank: parseInt(rank)});
                        }).join('')
                    });
                    break;
                    
                case 'kan':
                    // „Ç´„É≥: Âêå„ÅòÁâå4Êûö„ÇíÊâãÁâå„Åã„ÇâÂâäÈô§
                    removeTilesFromHand(data.key, 4);
                    melds.push({
                        type: 'kan',
                        tiles: [data.key, data.key, data.key, data.key],
                        display: displayName + displayName + displayName + displayName
                    });
                    break;
                    
                case 'ankan':
                    // „Ç¢„É≥„Ç´„É≥: Âêå„ÅòÁâå4Êûö„ÇíÊâãÁâå„Åã„ÇâÂâäÈô§
                    removeTilesFromHand(data.key, 4);
                    melds.push({
                        type: 'ankan',
                        tiles: [data.key, data.key, data.key, data.key],
                        display: displayName + displayName + displayName + displayName
                    });
                    break;
            }
            
            // ÊâãÁâåË°®Á§∫Êõ¥Êñ∞
            updateHandDisplay();
            calculateStatus();
            updateMeldsDisplay();
            
            alert(`${type.toUpperCase()}„ÇíÂÆüË°å„Åó„Åæ„Åó„Åü: ${displayName}`);
        }

        // ÊâãÁâå„Åã„ÇâÊåáÂÆöÁâå„ÇíÂâäÈô§
        function removeTilesFromHand(tileKey, count) {
            const [suit, rank] = tileKey.split('_');
            
            let removed = 0;
            const newHand = [];
            
            for (const tile of currentHand) {
                if (removed < count && getTileKey(tile) === tileKey) {
                    removed++;
                    // „Åì„ÅÆÁâå„ÅØÂâäÈô§ÔºànewHand„Å´ËøΩÂä†„Åó„Å™„ÅÑÔºâ
                } else {
                    newHand.push(tile);
                }
            }
            
            currentHand = newHand;
            console.log(`ÂâäÈô§: ${tileKey} x${removed}, ÊÆã„ÇäÊâãÁâåÊï∞: ${currentHand.length}`);
        }

        // ÂâØÈú≤Ë°®Á§∫Êõ¥Êñ∞
        function updateMeldsDisplay() {
            const container = document.getElementById('meldsDisplay');
            if (!container) return;
            
            if (melds.length === 0) {
                container.innerHTML = '<div style="color: #999;">ÂâØÈú≤„Å™„Åó</div>';
                return;
            }
            
            let html = '';
            melds.forEach((meld, index) => {
                const typeColor = {
                    'pon': '#e74c3c',
                    'chi': '#f39c12', 
                    'kan': '#9b59b6',
                    'ankan': '#27ae60'
                };
                
                html += `
                    <div class="meld-item" style="
                        margin-bottom: 8px;
                        padding: 6px 10px;
                        background: rgba(255,255,255,0.1);
                        border-radius: 4px;
                        border-left: 3px solid ${typeColor[meld.type]};
                    ">
                        <strong>${meld.type.toUpperCase()}:</strong> ${meld.display}
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        // ÊúÄÈÅ©„Å™Êç®„Å¶Áâå„ÇíË¶ã„Å§„Åë„Çã
        function findBestDiscard(analysis) {
            return analysis.reduce((best, current) => {
                const bestScore = (8 - best.shanten) * 100 + best.waitingTiles * 10 + best.efficiency;
                const currentScore = (8 - current.shanten) * 100 + current.waitingTiles * 10 + current.efficiency;
                
                return currentScore > bestScore ? current : best;
            }, analysis[0]);
        }

        // „Çπ„Éº„ÉàÂàÜÂ∏ÉÂèñÂæó
        function getSuitDistribution(hand) {
            const distribution = { man: 0, pin: 0, sou: 0, honors: 0 };
            hand.forEach(tile => {
                distribution[tile.suit]++;
            });
            return distribution;
        }

        // Â∞ÜÊù•ÊÄßË®àÁÆó
        function calculateFutureProspects(hand) {
            const shanten = calculateShanten(hand);
            const waitingTiles = getWaitingTiles(hand);
            
            // ÂêëËÅ¥Êï∞„ÅåÂ∞ë„Å™„Åè„ÄÅÂæÖ„Å°Áâå„ÅåÂ§ö„ÅÑ„Åª„Å©Â∞ÜÊù•ÊÄß„ÅåÈ´ò„ÅÑ
            return Math.max(0, (6 - shanten) * 20 + waitingTiles.length * 5);
        }

        // Êç®„Å¶Áâå„É™„Çπ„ÇØË©ï‰æ°
        function assessDiscardRisk(tile) {
            // Á∞°ÊòìÂÆüË£ÖÔºö‰∏≠ÂºµÁâå„ÅØÂÆâÂÖ®„ÄÅÁ´ØÁâå„Å®Â≠óÁâå„ÅØ„É™„Çπ„ÇØ„ÅåÈ´ò„ÅÑ
            if (tile.suit === 'honors') return 30; // Â≠óÁâå„ÅØ„É™„Çπ„ÇØ‰∏≠
            if (tile.rank === 1 || tile.rank === 9) return 50; // Á´ØÁâå„ÅØ„É™„Çπ„ÇØÈ´ò
            if (tile.rank >= 4 && tile.rank <= 6) return 10; // ‰∏≠ÂºµÁâå„ÅØÂÆâÂÖ®
            return 25; // „Åù„ÅÆ‰ªñ
        }

        // Êç®„Å¶ÁâåÁ∑èÂêà„Çπ„Ç≥„Ç¢Ë®àÁÆó
        function calculateDiscardScore(option) {
            let score = 0;
            
            // ÂêëËÅ¥Êï∞„ÅåÊîπÂñÑ„Åô„Çã„Åª„Å©È´òÂæóÁÇπ
            score += (8 - option.resultingShanten) * 100;
            
            // ÂæÖ„Å°Áâå„ÅåÂ§ö„ÅÑ„Åª„Å©È´òÂæóÁÇπ
            score += option.waitingTiles.length * 20;
            
            // Â∞ÜÊù•ÊÄß„ÅåÈ´ò„ÅÑ„Åª„Å©È´òÂæóÁÇπ
            score += option.futureProspects;
            
            // „É™„Çπ„ÇØ„Åå‰Ωé„ÅÑ„Åª„Å©È´òÂæóÁÇπ
            score -= option.riskAssessment;
            
            return score;
        }

        // „ÉÜ„Çπ„Éà„Ç±„Éº„ÇπÁîüÊàê
        function generateTestCases() {
            const testCases = [
                // Âü∫Êú¨ÁöÑ„Å™„ÉÜ„Çπ„Éà„Ç±„Éº„Çπ
                generateBasicTestCase(),
                generateTenpaiTestCase(),
                generateIishantenTestCase(),
                generateComplexTestCase()
            ];

            testCases.forEach((testCase, index) => {
                logDebug(`=== „ÉÜ„Çπ„Éà„Ç±„Éº„Çπ ${index + 1}: ${testCase.name} ===`);
                logDebug(`ÊâãÁâå: ${testCase.hand.map(getTileDisplayName).join(' ')}`);
                logDebug(`ÊúüÂæÖ„Åï„Çå„ÇãÁä∂ÊÖã: ${testCase.expectedState}`);
                
                // „ÉÜ„Çπ„Éà„Ç±„Éº„Çπ„ÇíÂÆüÈöõ„ÅÆÊâãÁâå„Å´„Çª„ÉÉ„Éà
                if (index === 0) {
                    currentHand = [...testCase.hand];
                    updateHandDisplay();
                    calculateStatus();
                }
            });
        }

        // Âü∫Êú¨„ÉÜ„Çπ„Éà„Ç±„Éº„ÇπÁîüÊàê
        function generateBasicTestCase() {
            return {
                name: 'Âü∫Êú¨ÂΩ¢„ÉÜ„Çπ„Éà',
                hand: [
                    {suit: 'man', rank: 1}, {suit: 'man', rank: 2}, {suit: 'man', rank: 3},
                    {suit: 'pin', rank: 4}, {suit: 'pin', rank: 5}, {suit: 'pin', rank: 6},
                    {suit: 'sou', rank: 7}, {suit: 'sou', rank: 8}, {suit: 'sou', rank: 9},
                    {suit: 'honors', type: 'east'}, {suit: 'honors', type: 'east'}, {suit: 'honors', type: 'east'},
                    {suit: 'man', rank: 5}, {suit: 'man', rank: 5}
                ],
                expectedState: 'Âíå‰∫ÜÂΩ¢'
            };
        }

        // „ÉÜ„É≥„Éë„Ç§„ÉÜ„Çπ„Éà„Ç±„Éº„Çπ
        function generateTenpaiTestCase() {
            return {
                name: '„ÉÜ„É≥„Éë„Ç§„ÉÜ„Çπ„Éà',
                hand: [
                    {suit: 'man', rank: 1}, {suit: 'man', rank: 2}, {suit: 'man', rank: 3},
                    {suit: 'pin', rank: 4}, {suit: 'pin', rank: 5}, {suit: 'pin', rank: 6},
                    {suit: 'sou', rank: 7}, {suit: 'sou', rank: 8}, {suit: 'sou', rank: 9},
                    {suit: 'honors', type: 'east'}, {suit: 'honors', type: 'east'}, {suit: 'honors', type: 'east'},
                    {suit: 'man', rank: 5}
                ],
                expectedState: '„ÉÜ„É≥„Éë„Ç§'
            };
        }

        // „Ç§„Éº„Ç∑„É£„É≥„ÉÜ„É≥„ÉÜ„Çπ„Éà„Ç±„Éº„Çπ
        function generateIishantenTestCase() {
            return {
                name: '„Ç§„Éº„Ç∑„É£„É≥„ÉÜ„É≥„ÉÜ„Çπ„Éà',
                hand: [
                    {suit: 'man', rank: 1}, {suit: 'man', rank: 2}, {suit: 'man', rank: 4},
                    {suit: 'pin', rank: 4}, {suit: 'pin', rank: 5}, {suit: 'pin', rank: 6},
                    {suit: 'sou', rank: 7}, {suit: 'sou', rank: 8}, {suit: 'sou', rank: 9},
                    {suit: 'honors', type: 'east'}, {suit: 'honors', type: 'east'}, {suit: 'honors', type: 'east'},
                    {suit: 'man', rank: 5}, {suit: 'man', rank: 8}
                ],
                expectedState: '„Ç§„Éº„Ç∑„É£„É≥„ÉÜ„É≥'
            };
        }

        // Ë§áÈõë„ÉÜ„Çπ„Éà„Ç±„Éº„Çπ
        function generateComplexTestCase() {
            return {
                name: 'Ë§áÈõëÂΩ¢„ÉÜ„Çπ„Éà',
                hand: [
                    {suit: 'man', rank: 1}, {suit: 'man', rank: 1}, {suit: 'pin', rank: 2},
                    {suit: 'pin', rank: 2}, {suit: 'sou', rank: 3}, {suit: 'sou', rank: 3},
                    {suit: 'honors', type: 'east'}, {suit: 'honors', type: 'east'}, {suit: 'honors', type: 'south'},
                    {suit: 'honors', type: 'south'}, {suit: 'honors', type: 'west'}, {suit: 'honors', type: 'west'},
                    {suit: 'honors', type: 'north'}, {suit: 'honors', type: 'north'}
                ],
                expectedState: '‰∏ÉÂØæÂ≠êÂΩ¢'
            };
        }

        // ÂàÜÊûêÁµêÊûúË°®Á§∫
        function displayDiscardAnalysis(analysis, bestDiscard) {
            const debugInfo = {
                ÂàÜÊûêÂØæË±°: `${analysis.length}Êûö`,
                ÊúÄÈÅ©Êç®„Å¶Áâå: getTileDisplayName(bestDiscard.discardTile),
                ÁµêÊûúÂêëËÅ¥Êï∞: bestDiscard.shanten,
                ÂæÖ„Å°ÁâåÊï∞: bestDiscard.waitingTiles,
                ÂäπÁéáÂÄ§: bestDiscard.efficiency,
                ÂÖ®ÈÅ∏ÊäûËÇ¢: analysis.map(a => ({
                    Áâå: getTileDisplayName(a.discardTile),
                    ÂêëËÅ¥: a.shanten,
                    ÂæÖ„Å°: a.waitingTiles,
                    ÂäπÁéá: a.efficiency
                }))
            };
            
            document.getElementById('debugInfo').textContent = JSON.stringify(debugInfo, null, 2);
        }

        // Ë©≥Á¥∞ÂàÜÊûêË°®Á§∫
        function displayDetailedAnalysis(analysis) {
            const debugInfo = {
                ÊâãÁâåÁµ±Ë®à: {
                    Á∑èÊûöÊï∞: analysis.totalTiles,
                    Á®ÆÈ°ûÊï∞: analysis.uniqueTiles,
                    „Çπ„Éº„ÉàÂàÜÂ∏É: analysis.suitDistribution
                },
                Êé®Â•®ÊâìÁâåÈ†Ü: analysis.discardOptions.slice(0, 5).map((option, index) => ({
                    È†Ü‰Ωç: index + 1,
                    Áâå: getTileDisplayName(option.tile),
                    ÂêëËÅ¥Êï∞: option.resultingShanten,
                    ÂæÖ„Å°ÁâåÊï∞: option.waitingTiles.length,
                    Â∞ÜÊù•ÊÄß: option.futureProspects,
                    „É™„Çπ„ÇØ: option.riskAssessment,
                    Á∑èÂêà„Çπ„Ç≥„Ç¢: Math.round(option.score)
                }))
            };
            
            document.getElementById('debugInfo').textContent = JSON.stringify(debugInfo, null, 2);
        }

        // ===== È´òÂ∫¶„Å™CPUÈ∫ªÈõÄ„Ç¢„É´„Ç¥„É™„Ç∫„É† =====

        // CPUÊÄùËÄÉ„Ç¢„É´„Ç¥„É™„Ç∫„É†ÂÆüË°å
        function runCpuAlgorithm() {
            if (currentHand.length !== 14) {
                alert('ÊâãÁâå„Çí14Êûö„Å´„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
                return;
            }

            logDebug('=== CPUÊÄùËÄÉ„Ç¢„É´„Ç¥„É™„Ç∫„É†ÈñãÂßã ===');
            
            const cpuAnalysis = performAdvancedCpuAnalysis(currentHand);
            displayCpuThinking(cpuAnalysis);
            
            // ÊúÄÈÅ©Ëß£„Çí„Éè„Ç§„É©„Ç§„Éà
            highlightRecommendedDiscard(cpuAnalysis.bestChoice);
        }

        // È´òÂ∫¶„Å™CPUÂàÜÊûê
        function performAdvancedCpuAnalysis(hand) {
            const analysis = {
                currentState: analyzeCurrentGameState(hand),
                discardOptions: [],
                strategicGoals: determineStrategicGoals(hand),
                riskAssessment: assessOverallRisk(hand),
                timeFactors: calculateTimeFactors(hand),
                bestChoice: null
            };

            // ÂêÑÊç®„Å¶ÁâåÈÅ∏ÊäûËÇ¢„ÇíÂ§öËßíÁöÑ„Å´Ë©ï‰æ°
            for (let i = 0; i < hand.length; i++) {
                const testHand = [...hand];
                const discardTile = testHand.splice(i, 1)[0];
                
                const option = evaluateDiscardOption(testHand, discardTile, analysis.strategicGoals);
                analysis.discardOptions.push(option);
            }

            // ÊúÄÈÅ©Ëß£„ÇíÊ±∫ÂÆö
            analysis.bestChoice = selectBestOption(analysis.discardOptions, analysis.strategicGoals);
            
            return analysis;
        }

        // ÁèæÂú®„ÅÆ„Ç≤„Éº„É†Áä∂ÊÖãÂàÜÊûê
        function analyzeCurrentGameState(hand) {
            const handState = analyzeHandState(hand);
            
            return {
                shanten: handState.shanten,
                tenpai: handState.shanten === 0,
                complete: handState.isComplete,
                yakuPotential: assessYakuPotential(hand),
                handType: determineHandType(hand),
                efficiency: calculateHandEfficiency(hand),
                flexibility: calculateHandFlexibility(hand)
            };
        }

        // Êà¶Áï•ÁõÆÊ®ôÊ±∫ÂÆö
        function determineStrategicGoals(hand) {
            const handState = analyzeHandState(hand);
            const yakuPotential = assessYakuPotential(hand);
            
            const goals = {
                primary: 'speed',  // speed, yaku, safety
                yakuTarget: null,
                acceptableRisk: 'medium',
                timeUrgency: 'normal'
            };

            // ÊâãÁâåÁä∂Ê≥Å„Å´Âøú„Åò„ÅüÊà¶Áï•Ê±∫ÂÆö
            if (handState.shanten <= 1) {
                goals.primary = 'speed';
                goals.timeUrgency = 'high';
            } else if (yakuPotential.highValueYaku.length > 0) {
                goals.primary = 'yaku';
                goals.yakuTarget = yakuPotential.highValueYaku[0];
            } else if (handState.shanten >= 4) {
                goals.primary = 'safety';
                goals.acceptableRisk = 'low';
            }

            return goals;
        }

        // Êç®„Å¶ÁâåÈÅ∏ÊäûËÇ¢Ë©ï‰æ°
        function evaluateDiscardOption(resultHand, discardTile, goals) {
            const evaluation = {
                tile: discardTile,
                resultingHand: resultHand,
                scores: {
                    speed: calculateSpeedScore(resultHand),
                    yaku: calculateYakuScore(resultHand),
                    safety: calculateSafetyScore(discardTile),
                    flexibility: calculateFlexibilityScore(resultHand),
                    efficiency: calculateEfficiencyScore(resultHand)
                },
                totalScore: 0,
                reasoning: []
            };

            // Êà¶Áï•„Å´Âü∫„Å•„ÅèÈáç„Åø‰ªò„Åë„Çπ„Ç≥„Ç¢Ë®àÁÆó
            evaluation.totalScore = calculateWeightedScore(evaluation.scores, goals);
            evaluation.reasoning = generateReasoning(evaluation, goals);

            return evaluation;
        }

        // „Çπ„Éî„Éº„Éâ„Çπ„Ç≥„Ç¢Ë®àÁÆó
        function calculateSpeedScore(hand) {
            const shanten = calculateShanten(hand);
            const waitingTiles = getWaitingTiles(hand);
            const waitingCount = waitingTiles.length;
            
            // ÂêëËÅ¥Êï∞„ÅåÂ∞ë„Å™„Åè„ÄÅÂæÖ„Å°Áâå„ÅåÂ§ö„ÅÑ„Åª„Å©È´ò„Çπ„Ç≥„Ç¢
            let score = (8 - shanten) * 20;
            score += waitingCount * 5;
            
            // „ÉÜ„É≥„Éë„Ç§„Éú„Éº„Éä„Çπ
            if (shanten === 0) score += 50;
            
            return Math.max(0, score);
        }

        // ÂΩπ„Çπ„Ç≥„Ç¢Ë®àÁÆó
        function calculateYakuScore(hand) {
            const yaku = calculateYaku(hand);
            const yakuPotential = assessYakuPotential(hand);
            
            let score = 0;
            
            // Á¢∫ÂÆöÂΩπ„ÅÆ„Çπ„Ç≥„Ç¢
            yaku.forEach(y => {
                if (y.han >= 13) score += 200; // ÂΩπÊ∫Ä
                else if (y.han >= 6) score += 100; // Ë∑≥Ê∫Ä‰ª•‰∏ä
                else if (y.han >= 3) score += 50;  // Ê∫ÄË≤´ÂÄôË£ú
                else score += y.han * 10;
            });
            
            // ÊΩúÂú®ÂΩπ„ÅÆ„Çπ„Ç≥„Ç¢
            yakuPotential.possibleYaku.forEach(yaku => {
                score += yaku.probability * yaku.value * 5;
            });
            
            return score;
        }

        // ÂÆâÂÖ®ÊÄß„Çπ„Ç≥„Ç¢Ë®àÁÆó
        function calculateSafetyScore(discardTile) {
            // Âç±Èô∫Â∫¶„ÅÆÈÄÜÊï∞„Åå„Çπ„Ç≥„Ç¢
            const dangerLevel = assessTileDanger(discardTile);
            return Math.max(0, 100 - dangerLevel);
        }

        // Áâå„ÅÆÂç±Èô∫Â∫¶Ë©ï‰æ°
        function assessTileDanger(tile) {
            let danger = 0;
            
            if (tile.suit === 'honors') {
                danger += 30; // Â≠óÁâå„ÅØ‰∏≠Á®ãÂ∫¶„ÅÆÂç±Èô∫
            } else {
                if (tile.rank === 1 || tile.rank === 9) {
                    danger += 50; // Á´ØÁâå„ÅØÂç±Èô∫
                } else if (tile.rank >= 4 && tile.rank <= 6) {
                    danger += 10; // ‰∏≠ÂºµÁâå„ÅØÂÆâÂÖ®
                } else {
                    danger += 25; // „Åù„ÅÆ‰ªñ
                }
            }
            
            return danger;
        }

        // ÊüîËªüÊÄß„Çπ„Ç≥„Ç¢Ë®àÁÆó
        function calculateFlexibilityScore(hand) {
            let score = 0;
            
            // ÂØæÂ≠ê„ÅÆÊï∞ÔºàÈõÄÈ†≠ÂÄôË£úÔºâ
            const counts = getTileCounts(hand);
            const pairs = Object.values(counts).filter(count => count === 2).length;
            score += pairs * 10;
            
            // È†ÜÂ≠ê„ÅÆÂèØËÉΩÊÄß
            ['man', 'pin', 'sou'].forEach(suit => {
                for (let rank = 1; rank <= 7; rank++) {
                    const key1 = `${suit}_${rank}`;
                    const key2 = `${suit}_${rank + 1}`;
                    const key3 = `${suit}_${rank + 2}`;
                    
                    let sequenceScore = 0;
                    if (counts[key1] && counts[key2] && counts[key3]) {
                        sequenceScore = 15; // ÂÆåÂÖ®„Å™È†ÜÂ≠ê
                    } else if ((counts[key1] && counts[key2]) || 
                              (counts[key2] && counts[key3]) || 
                              (counts[key1] && counts[key3])) {
                        sequenceScore = 5; // È†ÜÂ≠ê„ÅÆÂèØËÉΩÊÄß
                    }
                    score += sequenceScore;
                }
            });
            
            return score;
        }

        // ÂäπÁéáÊÄß„Çπ„Ç≥„Ç¢Ë®àÁÆó
        function calculateEfficiencyScore(hand) {
            return calculateEfficiency(hand); // Êó¢Â≠ò„ÅÆÈñ¢Êï∞„ÇíÂÜçÂà©Áî®
        }

        // Èáç„Åø‰ªò„Åç„Çπ„Ç≥„Ç¢Ë®àÁÆó
        function calculateWeightedScore(scores, goals) {
            const weights = getWeights(goals);
            
            return (scores.speed * weights.speed) +
                   (scores.yaku * weights.yaku) +
                   (scores.safety * weights.safety) +
                   (scores.flexibility * weights.flexibility) +
                   (scores.efficiency * weights.efficiency);
        }

        // Êà¶Áï•„Å´Âøú„Åò„ÅüÈáç„ÅøÂèñÂæó
        function getWeights(goals) {
            const baseWeights = {
                speed: 0.3,
                yaku: 0.25,
                safety: 0.2,
                flexibility: 0.15,
                efficiency: 0.1
            };

            if (goals.primary === 'speed') {
                baseWeights.speed = 0.5;
                baseWeights.yaku = 0.15;
            } else if (goals.primary === 'yaku') {
                baseWeights.yaku = 0.4;
                baseWeights.speed = 0.25;
            } else if (goals.primary === 'safety') {
                baseWeights.safety = 0.4;
                baseWeights.speed = 0.2;
            }

            return baseWeights;
        }

        // ÊúÄÈÅ©ÈÅ∏ÊäûËÇ¢Ê±∫ÂÆö
        function selectBestOption(options, goals) {
            // „Çπ„Ç≥„Ç¢È†Ü„Å´„ÇΩ„Éº„Éà
            options.sort((a, b) => b.totalScore - a.totalScore);
            
            const bestOption = options[0];
            bestOption.confidence = calculateConfidence(options);
            
            return bestOption;
        }

        // Âà§Êñ≠„ÅÆ‰ø°È†ºÂ∫¶Ë®àÁÆó
        function calculateConfidence(options) {
            if (options.length < 2) return 100;
            
            const best = options[0].totalScore;
            const second = options[1].totalScore;
            
            if (best === 0) return 0;
            
            const gap = (best - second) / best;
            return Math.min(100, Math.max(0, gap * 100));
        }

        // ÂΩπ„Éù„ÉÜ„É≥„Ç∑„É£„É´Ë©ï‰æ°
        function assessYakuPotential(hand) {
            const potential = {
                possibleYaku: [],
                highValueYaku: [],
                completionDistance: {}
            };

            // ÂêÑÂΩπ„Å∏„ÅÆËøë„Åï„ÇíË©ï‰æ°
            const yakuChecks = [
                { name: '„Çø„É≥„É§„Ç™', check: checkTanyao, value: 1 },
                { name: '„Éî„É≥„Éï', check: checkPinfu, value: 1 },
                { name: '‰∏ÉÂØæÂ≠ê', check: checkChiitoi, value: 2 },
                { name: 'ÂØæ„ÄÖÂíå', check: checkToitoi, value: 2 },
                { name: '‰∏âËâ≤ÂêåÈ†Ü', check: checkSanshoku, value: 2 },
                { name: '‰∏ÄÊ∞óÈÄöË≤´', check: checkIttsu, value: 2 },
                { name: 'Ê∑∑‰∏ÄËâ≤', check: checkHonitsu, value: 3 },
                { name: 'Ê∏Ö‰∏ÄËâ≤', check: checkChinitsu, value: 6 }
            ];

            yakuChecks.forEach(({ name, check, value }) => {
                const probability = estimateYakuProbability(hand, check);
                if (probability > 0.1) {
                    potential.possibleYaku.push({ name, probability, value });
                    if (value >= 3) {
                        potential.highValueYaku.push(name);
                    }
                }
            });

            return potential;
        }

        // ÂΩπÂÆåÊàêÁ¢∫ÁéáÊé®ÂÆö
        function estimateYakuProbability(hand, yakuCheck) {
            if (yakuCheck(hand)) return 1.0; // Êó¢„Å´ÂÆåÊàê
            
            // Á∞°ÊòìÁ¢∫ÁéáË®àÁÆóÔºàÂÆüÈöõ„ÅØ„Çà„ÇäË§áÈõë„Å™Ë®àÁÆó„ÅåÂøÖË¶ÅÔºâ
            const handFeatures = getHandFeatures(hand);
            
            // ÁâπÂæ¥„Å´Âü∫„Å•„ÅèÁ∞°ÊòìÁ¢∫Áéá
            if (handFeatures.includes('„Çø„É≥„É§„Ç™ÂΩ¢')) return 0.8;
            if (handFeatures.includes('‰∏ÄËâ≤')) return 0.9;
            if (handFeatures.includes('Â≠óÁâåÂê´„Åø')) return 0.3;
            
            return 0.2; // „Éá„Éï„Ç©„É´„ÉàÁ¢∫Áéá
        }

        // Êé®Ë´ñÁêÜÁî±ÁîüÊàê
        function generateReasoning(evaluation, goals) {
            const reasoning = [];
            
            if (evaluation.scores.speed > 80) {
                reasoning.push('È´òÈÄüÈÄ≤Ë°å„ÅåÊúüÂæÖ„Åß„Åç„Çã');
            }
            if (evaluation.scores.yaku > 50) {
                reasoning.push('ÂΩπ„ÅÆÂÆåÊàêÂèØËÉΩÊÄß„ÅåÈ´ò„ÅÑ');
            }
            if (evaluation.scores.safety > 70) {
                reasoning.push('ÂÆâÂÖ®„Å™Êç®„Å¶Áâå');
            }
            if (evaluation.scores.flexibility > 60) {
                reasoning.push('ÊâãÁâå„ÅÆÊüîËªüÊÄß„Çí‰øùÊåÅ');
            }
            
            if (goals.primary === 'speed' && evaluation.scores.speed < 30) {
                reasoning.push('„Çπ„Éî„Éº„ÉâÈáçË¶ñÊà¶Áï•„Å´‰∏çÈÅ©Âêà');
            }
            
            return reasoning;
        }

        // CPUÊÄùËÄÉÁµêÊûúË°®Á§∫
        function displayCpuThinking(analysis) {
            const debugInfo = {
                "CPUÊÄùËÄÉÂàÜÊûê": {
                    "ÁèæÂú®„ÅÆÁä∂ÊÖã": analysis.currentState,
                    "Êà¶Áï•ÁõÆÊ®ô": analysis.strategicGoals,
                    "„É™„Çπ„ÇØË©ï‰æ°": analysis.riskAssessment
                },
                "ÊúÄÈÅ©Ëß£": {
                    "Êé®Â•®Êç®„Å¶Áâå": getTileDisplayName(analysis.bestChoice.tile),
                    "‰ø°È†ºÂ∫¶": `${Math.round(analysis.bestChoice.confidence)}%`,
                    "Á∑èÂêà„Çπ„Ç≥„Ç¢": Math.round(analysis.bestChoice.totalScore),
                    "ÁêÜÁî±": analysis.bestChoice.reasoning
                },
                "„Çπ„Ç≥„Ç¢Ë©≥Á¥∞": {
                    "„Çπ„Éî„Éº„Éâ": Math.round(analysis.bestChoice.scores.speed),
                    "ÂΩπ‰æ°ÂÄ§": Math.round(analysis.bestChoice.scores.yaku),
                    "ÂÆâÂÖ®ÊÄß": Math.round(analysis.bestChoice.scores.safety),
                    "ÊüîËªüÊÄß": Math.round(analysis.bestChoice.scores.flexibility),
                    "ÂäπÁéáÊÄß": Math.round(analysis.bestChoice.scores.efficiency)
                },
                "ÂÖ®ÈÅ∏ÊäûËÇ¢": analysis.discardOptions.slice(0, 5).map((option, index) => ({
                    "È†Ü‰Ωç": index + 1,
                    "Áâå": getTileDisplayName(option.tile),
                    "„Çπ„Ç≥„Ç¢": Math.round(option.totalScore),
                    "ÁâπÂæ¥": option.reasoning.slice(0, 2)
                }))
            };
            
            document.getElementById('debugInfo').textContent = JSON.stringify(debugInfo, null, 2);
        }

        // Êé®Â•®Êç®„Å¶Áâå„Çí„Éè„Ç§„É©„Ç§„Éà
        function highlightRecommendedDiscard(bestChoice) {
            // Êó¢Â≠ò„ÅÆ„Éè„Ç§„É©„Ç§„Éà„ÇíÂâäÈô§
            document.querySelectorAll('.tile.recommended').forEach(tile => {
                tile.classList.remove('recommended');
            });
            
            // Êé®Â•®Áâå„Çí„Éè„Ç§„É©„Ç§„Éà
            const handTiles = document.querySelectorAll('#handTiles .tile');
            const recommendedTile = bestChoice.tile;
            
            handTiles.forEach((tileElement, index) => {
                if (index < currentHand.length) {
                    const handTile = currentHand[index];
                    if (getTileKey(handTile) === getTileKey(recommendedTile)) {
                        tileElement.classList.add('recommended');
                        tileElement.style.border = '3px solid #FFD700';
                        tileElement.style.boxShadow = '0 0 10px rgba(255, 215, 0, 0.6)';
                    }
                }
            });
        }

        // ÂÖ®ÈÅ∏ÊäûËÇ¢ÊØîËºÉ
        function compareDiscardOptions() {
            if (currentHand.length !== 14) {
                alert('ÊâãÁâå„Çí14Êûö„Å´„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
                return;
            }

            const comparison = [];
            
            for (let i = 0; i < currentHand.length; i++) {
                const testHand = [...currentHand];
                const discardTile = testHand.splice(i, 1)[0];
                const analysis = evaluateDiscardOption(testHand, discardTile, { primary: 'speed' });
                
                comparison.push({
                    tile: getTileDisplayName(discardTile),
                    shanten: calculateShanten(testHand),
                    waiting: getWaitingTiles(testHand).length,
                    score: Math.round(analysis.totalScore),
                    safety: Math.round(analysis.scores.safety),
                    recommendation: analysis.totalScore > 100 ? 'Êé®Â•®' : analysis.totalScore > 50 ? 'ÊôÆÈÄö' : 'ÈùûÊé®Â•®'
                });
            }
            
            comparison.sort((a, b) => b.score - a.score);
            
            const debugInfo = {
                "ÂÖ®Êç®„Å¶ÁâåÈÅ∏ÊäûËÇ¢ÊØîËºÉ": comparison
            };
            
            document.getElementById('debugInfo').textContent = JSON.stringify(debugInfo, null, 2);
        }

        // „Ç≤„Éº„É†ÈÄ≤Ë°å„Ç∑„Éü„É•„É¨„Éº„Éà
        function simulateGameProgress() {
            if (currentHand.length !== 14) {
                alert('ÊâãÁâå„Çí14Êûö„Å´„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
                return;
            }

            logDebug('=== „Ç≤„Éº„É†ÈÄ≤Ë°å„Ç∑„Éü„É•„É¨„Éº„ÉàÈñãÂßã ===');
            
            const simulation = {
                turns: [],
                finalState: null,
                strategy: 'optimal'
            };
            
            let simulationHand = [...currentHand];
            let turnCount = 0;
            
            while (turnCount < 10 && calculateShanten(simulationHand.slice(0, 13)) > 0) {
                turnCount++;
                
                // CPUÊÄùËÄÉ„ÅßÊúÄÈÅ©„Å™Êç®„Å¶Áâå„ÇíÊ±∫ÂÆö
                const cpuAnalysis = performAdvancedCpuAnalysis(simulationHand);
                const bestDiscard = cpuAnalysis.bestChoice;
                
                // Êç®„Å¶ÁâåÂÆüË°å
                const discardIndex = simulationHand.findIndex(tile => 
                    getTileKey(tile) === getTileKey(bestDiscard.tile)
                );
                
                if (discardIndex >= 0) {
                    const discarded = simulationHand.splice(discardIndex, 1)[0];
                    
                    // Êñ∞„Åó„ÅÑÁâå„Çí„ÉÑ„É¢Ôºà„É©„É≥„ÉÄ„É†Ôºâ
                    const newTile = allTileTypes[Math.floor(Math.random() * allTileTypes.length)];
                    simulationHand.push(newTile);
                    
                    simulation.turns.push({
                        turn: turnCount,
                        discarded: getTileDisplayName(discarded),
                        drawn: getTileDisplayName(newTile),
                        shanten: calculateShanten(simulationHand.slice(0, 13)),
                        reasoning: bestDiscard.reasoning[0] || 'ÊúÄÈÅ©ÂåñÂà§Êñ≠'
                    });
                }
                
                if (simulationHand.length > 14) {
                    simulationHand = simulationHand.slice(0, 14);
                }
            }
            
            simulation.finalState = analyzeHandState(simulationHand.slice(0, 13));
            
            const debugInfo = {
                "„Ç≤„Éº„É†ÈÄ≤Ë°å„Ç∑„Éü„É•„É¨„Éº„ÉàÁµêÊûú": {
                    "Á∑è„Çø„Éº„É≥Êï∞": turnCount,
                    "ÊúÄÁµÇÁä∂ÊÖã": simulation.finalState.message,
                    "ÊúÄÁµÇÂêëËÅ¥Êï∞": simulation.finalState.shanten,
                    "„Çø„Éº„É≥Ë©≥Á¥∞": simulation.turns
                }
            };
            
            document.getElementById('debugInfo').textContent = JSON.stringify(debugInfo, null, 2);
        }

        // „É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£Èñ¢Êï∞
        function calculateHandEfficiency(hand) {
            return calculateEfficiency(hand);
        }

        function calculateHandFlexibility(hand) {
            return calculateFlexibilityScore(hand);
        }

        function determineHandType(hand) {
            if (checkChiitoi(hand)) return 'chiitoi';
            if (checkKokushi(hand)) return 'kokushi';
            return 'normal';
        }

        function assessOverallRisk(hand) {
            // ÂÖ®‰ΩìÁöÑ„Å™„É™„Çπ„ÇØË©ï‰æ°ÔºàÁ∞°ÊòìÁâàÔºâ
            const honorCount = hand.filter(tile => tile.suit === 'honors').length;
            const terminalCount = hand.filter(tile => 
                tile.suit !== 'honors' && (tile.rank === 1 || tile.rank === 9)
            ).length;
            
            const riskLevel = (honorCount + terminalCount) / hand.length;
            
            if (riskLevel > 0.5) return 'high';
            if (riskLevel > 0.3) return 'medium';
            return 'low';
        }

        function calculateTimeFactors(hand) {
            const shanten = calculateShanten(hand);
            return {
                urgency: shanten <= 1 ? 'high' : shanten <= 3 ? 'medium' : 'low',
                patience: shanten >= 4 ? 'high' : 'medium'
            };
        }
    </script>
</body>
</html>