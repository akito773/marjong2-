<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ€„ ä¸€äººç”¨éº»é›€ãƒ‡ãƒãƒƒã‚°ãƒ„ãƒ¼ãƒ«</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700;900&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Sans JP', sans-serif;
            background: linear-gradient(135deg, #0f4c75, #3282b8, #bbe1fa);
            min-height: 100vh;
            color: white;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 32px;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .header p {
            font-size: 16px;
            opacity: 0.8;
        }

        .game-area {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
            margin-bottom: 20px;
        }

        .main-area {
            background: rgba(0,0,0,0.3);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .info-panel {
            background: rgba(0,0,0,0.4);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
        }

        .hand-area {
            margin-bottom: 30px;
        }

        .hand-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #FFD700;
        }

        .hand-tiles {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            min-height: 100px;
            padding: 15px;
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
            border: 2px dashed rgba(255,255,255,0.3);
        }

        .tile {
            width: 50px;
            height: 70px;
            background: linear-gradient(145deg, #ffffff, #f0f2f5);
            border: 2px solid #2c3e50;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 6px rgba(0,0,0,0.2);
            position: relative;
        }

        .tile:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.3);
        }

        .tile.selected {
            background: linear-gradient(145deg, #FFD700, #FFA500);
            transform: translateY(-8px);
            box-shadow: 0 8px 16px rgba(255,215,0,0.4);
        }

        .tile.man { border-color: #e74c3c; }
        .tile.pin { border-color: #3498db; }
        .tile.sou { border-color: #27ae60; }
        .tile.honors { border-color: #9b59b6; }

        .tile-symbol {
            font-size: 24px;
            font-weight: bold;
            color: #2c3e50;
        }

        .tile.man .tile-symbol { color: #e74c3c; }
        .tile.pin .tile-symbol { color: #3498db; }
        .tile.sou .tile-symbol { color: #27ae60; }
        .tile.honors .tile-symbol { color: #9b59b6; }

        .tile-suit {
            font-size: 10px;
            color: #7f8c8d;
            margin-top: 2px;
        }

        .available-tiles {
            margin-bottom: 30px;
        }

        .tile-selector {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(45px, 1fr));
            gap: 5px;
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
        }

        .available-tile {
            width: 40px;
            height: 55px;
            background: linear-gradient(145deg, #ffffff, #f0f2f5);
            border: 1px solid #2c3e50;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 18px;
        }

        .available-tile:hover {
            background: linear-gradient(145deg, #e8f4f8, #d1ecf1);
            transform: scale(1.1);
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
            text-align: center;
        }

        .btn-primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(45deg, #f093fb, #f5576c);
            color: white;
            box-shadow: 0 4px 8px rgba(240, 147, 251, 0.3);
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(240, 147, 251, 0.4);
        }

        .info-section {
            margin-bottom: 25px;
        }

        .info-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #FFD700;
            border-bottom: 1px solid rgba(255,215,0,0.3);
            padding-bottom: 5px;
        }

        .status-display {
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #3498db;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .status-item:last-child {
            margin-bottom: 0;
        }

        .waiting-tiles {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
        }

        .waiting-tile {
            background: rgba(255,215,0,0.2);
            border: 1px solid #FFD700;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 18px;
        }

        .yaku-list {
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #e74c3c;
            max-height: 200px;
            overflow-y: auto;
        }

        .yaku-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .yaku-item:last-child {
            border-bottom: none;
        }

        .debug-info {
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 10px;
            font-family: monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
        }

        .meld-analysis {
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
            line-height: 1.4;
        }

        .meld-option {
            margin-bottom: 8px;
            padding: 4px 8px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            border-left: 3px solid #3498db;
        }

        .meld-option.pon { border-left-color: #e74c3c; }
        .meld-option.chi { border-left-color: #f39c12; }
        .meld-option.kan { border-left-color: #9b59b6; }
        .meld-option.ankan { border-left-color: #27ae60; }

        .melds-display {
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
            max-height: 150px;
            overflow-y: auto;
            line-height: 1.4;
        }

        .winning-tiles-analysis {
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
            line-height: 1.4;
        }

        .winning-tile-item {
            margin-bottom: 8px;
            padding: 6px 10px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            border-left: 3px solid #27ae60;
        }

        .winning-tile-header {
            font-weight: bold;
            color: #FFD700;
            margin-bottom: 4px;
        }

        .winning-tile-details {
            font-size: 11px;
            color: #CCC;
            line-height: 1.3;
        }

        @media (max-width: 768px) {
            .game-area {
                grid-template-columns: 1fr;
            }
            
            .tile {
                width: 40px;
                height: 60px;
            }
            
            .tile-symbol {
                font-size: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ€„ ä¸€äººç”¨éº»é›€ãƒ‡ãƒãƒƒã‚°ãƒ„ãƒ¼ãƒ«</h1>
            <p>CPUæ¨ã¦ç‰Œã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ é–‹ç™ºãƒ»ãƒ†ã‚¹ãƒˆç”¨</p>
        </div>

        <div class="game-area">
            <div class="main-area">
                <div class="hand-area">
                    <div class="hand-title">æ‰‹ç‰Œ (14æš)</div>
                    <div class="hand-tiles" id="handTiles"></div>
                </div>

                <div class="wind-settings" style="margin-bottom: 20px; padding: 15px; background: rgba(0,0,0,0.2); border-radius: 10px;">
                    <div class="wind-title" style="font-size: 16px; font-weight: bold; margin-bottom: 10px; color: #FFD700;">ğŸŒªï¸ é¢¨è¨­å®š</div>
                    <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-size: 14px;">å ´é¢¨:</label>
                            <select id="gameWind" onchange="updateWindSettings()" style="padding: 5px; border-radius: 5px; background: #fff; color: #000;">
                                <option value="east">æ±å ´</option>
                                <option value="south">å—å ´</option>
                            </select>
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-size: 14px;">è‡ªé¢¨:</label>
                            <select id="playerWind" onchange="updateWindSettings()" style="padding: 5px; border-radius: 5px; background: #fff; color: #000;">
                                <option value="east">æ±å®¶</option>
                                <option value="south">å—å®¶</option>
                                <option value="west">è¥¿å®¶</option>
                                <option value="north">åŒ—å®¶</option>
                            </select>
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-size: 14px;">å±€:</label>
                            <input type="number" id="roundNumber" value="1" min="1" max="4" onchange="updateWindSettings()" style="width: 60px; padding: 5px; border-radius: 5px; background: #fff; color: #000;">
                        </div>
                        <div style="display: flex; align-items: end;">
                            <button class="btn btn-secondary" onclick="resetWindSettings()" style="padding: 8px 16px; font-size: 12px;">ãƒªã‚»ãƒƒãƒˆ</button>
                        </div>
                    </div>
                </div>

                <div class="controls">
                    <button class="btn btn-primary" onclick="dealNewHand()">æ–°ã—ã„é…ç‰Œ</button>
                    <button class="btn btn-secondary" onclick="drawTile()">ãƒ„ãƒ¢</button>
                    <button class="btn btn-primary" onclick="calculateStatus()">çŠ¶æ…‹æ›´æ–°</button>
                    <button class="btn btn-secondary" onclick="autoComplete()">è‡ªå‹•å®Œæˆ</button>
                    <button class="btn btn-primary" onclick="manualSort()">æ‰‹å‹•ã‚½ãƒ¼ãƒˆ</button>
                </div>

                <div class="controls">
                    <button class="btn btn-primary" onclick="simulateOptimalPlay()">æœ€é©æ‰“ç‰Œã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ</button>
                    <button class="btn btn-secondary" onclick="analyzeBestDiscard()">æœ€é©æ¨ã¦ç‰Œåˆ†æ</button>
                    <button class="btn btn-primary" onclick="generateTestCases()">ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ç”Ÿæˆ</button>
                </div>

                <div class="controls">
                    <button class="btn btn-primary" onclick="runCpuAlgorithm()">ğŸ¤– CPUæ€è€ƒã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ </button>
                    <button class="btn btn-secondary" onclick="compareDiscardOptions()">ğŸ“Š å…¨é¸æŠè‚¢æ¯”è¼ƒ</button>
                    <button class="btn btn-primary" onclick="simulateGameProgress()">âš¡ ã‚²ãƒ¼ãƒ é€²è¡Œã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ</button>
                </div>

                <div class="controls">
                    <button class="btn btn-primary" onclick="executePon()">ãƒãƒ³</button>
                    <button class="btn btn-secondary" onclick="executeChi()">ãƒãƒ¼</button>
                    <button class="btn btn-primary" onclick="executeKan()">ã‚«ãƒ³</button>
                    <button class="btn btn-secondary" onclick="executeAnkan()">ã‚¢ãƒ³ã‚«ãƒ³</button>
                </div>

                <div class="controls">
                    <button class="btn btn-primary" onclick="selectWinTile()">ä¸ŠãŒã‚Šç‰ŒæŒ‡å®š</button>
                    <button class="btn btn-secondary" onclick="clearWinTile()">ä¸ŠãŒã‚Šç‰Œã‚¯ãƒªã‚¢</button>
                    <span id="winTileDisplay" style="color: #FFD700; margin-left: 10px;">ä¸ŠãŒã‚Šç‰Œ: ãªã—</span>
                </div>

                <div class="available-tiles">
                    <div class="hand-title">ä½¿ç”¨å¯èƒ½ãªç‰Œ (ã‚¯ãƒªãƒƒã‚¯ã§æ‰‹ç‰Œã«è¿½åŠ )</div>
                    <div class="tile-selector" id="availableTiles"></div>
                </div>
            </div>

            <div class="info-panel">
                <div class="info-section">
                    <div class="info-title">ğŸ¯ æ‰‹ç‰ŒçŠ¶æ…‹</div>
                    <div class="status-display" id="handStatus">
                        <div class="status-item">
                            <span>çŠ¶æ…‹:</span>
                            <span id="handState">æœªåˆ¤å®š</span>
                        </div>
                        <div class="status-item">
                            <span>å‘è´æ•°:</span>
                            <span id="shantenCount">-</span>
                        </div>
                        <div class="status-item">
                            <span>æšæ•°:</span>
                            <span id="tileCount">0/14</span>
                        </div>
                    </div>
                    <div class="waiting-tiles" id="waitingTiles"></div>
                </div>

                <div class="info-section">
                    <div class="info-title">ğŸ€„ å½¹æƒ…å ±</div>
                    <div class="yaku-list" id="yakuList">
                        <div class="yaku-item">
                            <span>å½¹ãªã—</span>
                            <span>0ç¿»</span>
                        </div>
                    </div>
                </div>

                <div class="info-section">
                    <div class="info-title">ğŸ€„ é³´ãåˆ¤å®š</div>
                    <div class="meld-analysis" id="meldAnalysis">
                        é³´ãåˆ¤å®šãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™...
                    </div>
                </div>

                <div class="info-section">
                    <div class="info-title">ğŸ¯ å½“ãŸã‚Šç‰Œåˆ†æ</div>
                    <div class="winning-tiles-analysis" id="winningTilesAnalysis">
                        å½“ãŸã‚Šç‰Œåˆ†æãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™...
                    </div>
                </div>

                <div class="info-section">
                    <div class="info-title">ğŸ”“ å‰¯éœ²(æ™’ã—)</div>
                    <div class="melds-display" id="meldsDisplay">
                        å‰¯éœ²ãªã—
                    </div>
                </div>

                <div class="info-section">
                    <div class="info-title">ğŸ”§ ãƒ‡ãƒãƒƒã‚°æƒ…å ±</div>
                    <div class="debug-info" id="debugInfo">
                        ãƒ‡ãƒãƒƒã‚°æƒ…å ±ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™...
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
        let currentHand = [];
        let selectedTileIndex = -1;
        let gameSettings = {
            gameWind: 'east',    // å ´é¢¨ (east/south/west/north)
            playerWind: 'east',  // è‡ªé¢¨ (east/south/west/north) 
            round: 1             // å±€æ•°
        };
        let gameStats = {
            handsPlayed: 0,
            completedHands: 0,
            averageShanten: 0
        };

        // å…¨ç‰Œã‚¿ã‚¤ãƒ—å®šç¾©
        const allTileTypes = [];

        // æ•°ç‰Œç”Ÿæˆ
        ['man', 'pin', 'sou'].forEach(suit => {
            for (let rank = 1; rank <= 9; rank++) {
                allTileTypes.push({ suit, rank });
            }
        });

        // å­—ç‰Œç”Ÿæˆ
        ['east', 'south', 'west', 'north', 'haku', 'hatsu', 'chun'].forEach(type => {
            allTileTypes.push({ suit: 'honors', type });
        });

        // åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', function() {
            generateAvailableTiles();
            dealNewHand();
            calculateStatus();
            updateMeldsDisplay();
        });

        // åˆ©ç”¨å¯èƒ½ãªç‰Œã‚’ç”Ÿæˆ
        function generateAvailableTiles() {
            const container = document.getElementById('availableTiles');
            container.innerHTML = '';

            allTileTypes.forEach(tile => {
                const tileElement = createAvailableTile(tile);
                container.appendChild(tileElement);
            });
        }

        // åˆ©ç”¨å¯èƒ½ãªç‰Œè¦ç´ ä½œæˆ
        function createAvailableTile(tile) {
            const div = document.createElement('div');
            div.className = `available-tile ${tile.suit}`;
            div.textContent = getTileSymbol(tile);
            
            div.addEventListener('click', function() {
                addTileToHand(tile);
            });
            
            return div;
        }

        // æ‰‹ç‰Œã«ç‰Œã‚’è¿½åŠ 
        function addTileToHand(tile) {
            if (currentHand.length >= 14) {
                alert('æ‰‹ç‰Œã¯æœ€å¤§14æšã§ã™');
                return;
            }
            
            currentHand.push({ ...tile });
            sortHand(); // è‡ªå‹•ã‚½ãƒ¼ãƒˆ
            updateHandDisplay();
            calculateStatus();
            logDebug(`ç‰Œè¿½åŠ : ${getTileDisplayName(tile)}, æ‰‹ç‰Œæšæ•°: ${currentHand.length}`);
        }

        // é¢¨è¨­å®šæ›´æ–°
        function updateWindSettings() {
            gameSettings.gameWind = document.getElementById('gameWind').value;
            gameSettings.playerWind = document.getElementById('playerWind').value;
            gameSettings.round = parseInt(document.getElementById('roundNumber').value);
            
            // å½¹ç‰Œåˆ¤å®šã«å½±éŸ¿ã™ã‚‹ãŸã‚çŠ¶æ…‹ã‚’å†è¨ˆç®—
            calculateStatus();
            
            logDebug(`é¢¨è¨­å®šæ›´æ–°: å ´é¢¨=${gameSettings.gameWind}, è‡ªé¢¨=${gameSettings.playerWind}, ${gameSettings.round}å±€`);
        }

        // é¢¨è¨­å®šãƒªã‚»ãƒƒãƒˆ
        function resetWindSettings() {
            gameSettings.gameWind = 'east';
            gameSettings.playerWind = 'east';
            gameSettings.round = 1;
            
            document.getElementById('gameWind').value = 'east';
            document.getElementById('playerWind').value = 'east';
            document.getElementById('roundNumber').value = 1;
            
            calculateStatus();
            logDebug('é¢¨è¨­å®šã‚’ãƒªã‚»ãƒƒãƒˆ');
        }

        // æ–°ã—ã„é…ç‰Œ
        function dealNewHand() {
            currentHand = [];
            
            // ãƒ©ãƒ³ãƒ€ãƒ ã«13æšé…ç‰Œ
            for (let i = 0; i < 13; i++) {
                const randomTile = allTileTypes[Math.floor(Math.random() * allTileTypes.length)];
                currentHand.push({ ...randomTile });
            }
            
            // é…ç‰Œã‚’è‡ªå‹•ã‚½ãƒ¼ãƒˆ
            sortHand();
            
            gameStats.handsPlayed++;
            updateHandDisplay();
            calculateStatus();
            logDebug(`æ–°ã—ã„é…ç‰Œç”Ÿæˆ: ${currentHand.length}æšï¼ˆã‚½ãƒ¼ãƒˆæ¸ˆã¿ï¼‰`);
        }

        // æ‰‹ç‰Œã‚½ãƒ¼ãƒˆ
        function sortHand() {
            currentHand.sort((a, b) => {
                // ã‚¹ãƒ¼ãƒˆé †: man, pin, sou, honors
                const suitOrder = { man: 0, pin: 1, sou: 2, honors: 3 };
                
                if (suitOrder[a.suit] !== suitOrder[b.suit]) {
                    return suitOrder[a.suit] - suitOrder[b.suit];
                }
                
                // åŒã˜ã‚¹ãƒ¼ãƒˆå†…ã§ã®ã‚½ãƒ¼ãƒˆ
                if (a.suit === 'honors') {
                    const honorOrder = { east: 0, south: 1, west: 2, north: 3, haku: 4, hatsu: 5, chun: 6 };
                    return honorOrder[a.type] - honorOrder[b.type];
                } else {
                    return a.rank - b.rank;
                }
            });
        }

        // æ‰‹å‹•ã‚½ãƒ¼ãƒˆ
        function manualSort() {
            sortHand();
            updateHandDisplay();
            logDebug('æ‰‹ç‰Œã‚’æ‰‹å‹•ã‚½ãƒ¼ãƒˆã—ã¾ã—ãŸ');
        }

        // ãƒ„ãƒ¢
        function drawTile() {
            if (currentHand.length >= 14) {
                alert('æ‰‹ç‰Œã¯æœ€å¤§14æšã§ã™');
                return;
            }
            
            const randomTile = allTileTypes[Math.floor(Math.random() * allTileTypes.length)];
            currentHand.push({ ...randomTile });
            sortHand(); // è‡ªå‹•ã‚½ãƒ¼ãƒˆ
            updateHandDisplay();
            calculateStatus();
            logDebug(`ãƒ„ãƒ¢: ${getTileDisplayName(randomTile)}`);
        }

        // æ‰‹ç‰Œè¡¨ç¤ºæ›´æ–°
        function updateHandDisplay() {
            const container = document.getElementById('handTiles');
            container.innerHTML = '';

            currentHand.forEach((tile, index) => {
                const tileElement = createHandTile(tile, index);
                container.appendChild(tileElement);
            });

            const meldTileCount = melds.reduce((total, meld) => total + meld.tiles.length, 0);
            const totalTiles = currentHand.length + meldTileCount;
            document.getElementById('tileCount').textContent = `${currentHand.length}+${meldTileCount}=${totalTiles}`;
        }

        // æ‰‹ç‰Œã‚¿ã‚¤ãƒ«è¦ç´ ä½œæˆ
        function createHandTile(tile, index) {
            const div = document.createElement('div');
            div.className = `tile ${tile.suit}`;
            if (selectedTileIndex === index) {
                div.classList.add('selected');
            }

            const symbol = getTileSymbol(tile);
            const suitName = getSuitName(tile.suit);

            div.innerHTML = `
                <div class="tile-symbol">${symbol}</div>
                <div class="tile-suit">${suitName}</div>
            `;

            div.addEventListener('click', function() {
                if (selectedTileIndex === index) {
                    // é¸æŠè§£é™¤
                    selectedTileIndex = -1;
                } else if (selectedTileIndex >= 0) {
                    // ç‰Œã‚’å‰Šé™¤
                    currentHand.splice(selectedTileIndex, 1);
                    selectedTileIndex = -1;
                    logDebug(`ç‰Œå‰Šé™¤: æ‰‹ç‰Œæšæ•°: ${currentHand.length}`);
                } else {
                    // ç‰Œã‚’é¸æŠ
                    selectedTileIndex = index;
                }
                updateHandDisplay();
                calculateStatus();
            });

            return div;
        }

        // ç‰Œã‚·ãƒ³ãƒœãƒ«å–å¾—
        function getTileSymbol(tile) {
            if (tile.suit === 'honors') {
                const honorMap = {
                    east: 'æ±', south: 'å—', west: 'è¥¿', north: 'åŒ—',
                    haku: 'ç™½', hatsu: 'ç™¼', chun: 'ä¸­'
                };
                return honorMap[tile.type] || tile.type;
            } else {
                return tile.rank.toString();
            }
        }

        // ã‚¹ãƒ¼ãƒˆåå–å¾—
        function getSuitName(suit) {
            const suitMap = {
                man: 'è¬', pin: 'ç­’', sou: 'ç´¢', honors: 'å­—'
            };
            return suitMap[suit] || suit;
        }

        // ç‰Œè¡¨ç¤ºåå–å¾—
        function getTileDisplayName(tile) {
            if (tile.suit === 'honors') {
                return getTileSymbol(tile);
            } else {
                return `${tile.rank}${getSuitName(tile.suit)}`;
            }
        }

        // çŠ¶æ…‹è¨ˆç®—
        function calculateStatus() {
            const handState = analyzeHandState(currentHand);
            
            // çŠ¶æ…‹è¡¨ç¤ºæ›´æ–°
            document.getElementById('handState').textContent = handState.message;
            document.getElementById('shantenCount').textContent = handState.shanten >= 0 ? `${handState.shanten}ã‚·ãƒ£ãƒ³ãƒ†ãƒ³` : '-';
            
            // å¾…ã¡ç‰Œè¡¨ç¤º
            updateWaitingTiles(handState.waitingTiles || [], handState);
            
            // å½¹æƒ…å ±è¡¨ç¤º
            updateYakuDisplay(handState.yaku || []);
            
            // ãƒ‡ãƒãƒƒã‚°æƒ…å ±æ›´æ–°
            updateDebugInfo(handState);
            
            // é³´ãåˆ¤å®šæ›´æ–°
            updateMeldAnalysis();
            
            // å½“ãŸã‚Šç‰Œåˆ†ææ›´æ–°
            updateWinningTilesAnalysis();
        }

        // æ‰‹ç‰ŒçŠ¶æ…‹åˆ†æ
        function analyzeHandState(hand) {
            if (!hand || hand.length === 0) {
                return {
                    message: 'æ‰‹ç‰Œãªã—',
                    shanten: -1,
                    waitingTiles: [],
                    yaku: [],
                    discardToTenpai: null
                };
            }

            // å’Œäº†å½¢ãƒã‚§ãƒƒã‚¯
            if (hand.length === 14 && isWinningShape(hand)) {
                const yaku = calculateYaku(hand);
                return {
                    message: 'å’Œäº†å½¢',
                    shanten: -1,
                    waitingTiles: [],
                    yaku: yaku,
                    isComplete: true,
                    discardToTenpai: null
                };
            }

            // 14æšã®å ´åˆï¼šæ¨ã¦ç‰Œå¾Œãƒ†ãƒ³ãƒ‘ã‚¤åˆ†æ
            if (hand.length === 14) {
                const discardAnalysis = analyzeDiscardToTenpai(hand);
                const baseShanten = calculateShanten(hand.slice(0, 13)); // ä»®ã®13æšã§ã®å‘è´æ•°
                
                if (discardAnalysis.canReachTenpai) {
                    return {
                        message: `${baseShanten}ã‚·ãƒ£ãƒ³ãƒ†ãƒ³ï¼ˆæ¨ã¦ç‰Œã§ãƒ†ãƒ³ãƒ‘ã‚¤å¯èƒ½ï¼‰`,
                        shanten: baseShanten,
                        waitingTiles: [],
                        yaku: [],
                        discardToTenpai: discardAnalysis
                    };
                } else {
                    return {
                        message: `${baseShanten}ã‚·ãƒ£ãƒ³ãƒ†ãƒ³`,
                        shanten: baseShanten,
                        waitingTiles: [],
                        yaku: [],
                        discardToTenpai: null
                    };
                }
            }

            // ãƒ†ãƒ³ãƒ‘ã‚¤ãƒã‚§ãƒƒã‚¯ï¼ˆ13æšï¼‰
            if (hand.length === 13) {
                const waitingTiles = getWaitingTiles(hand);
                const yaku = calculateYaku(hand); // 13æšã§ã‚‚å½¹åˆ¤å®šã‚’å®Ÿè¡Œ
                if (waitingTiles.length > 0) {
                    return {
                        message: 'ãƒ†ãƒ³ãƒ‘ã‚¤',
                        shanten: 0,
                        waitingTiles: waitingTiles,
                        yaku: yaku,
                        discardToTenpai: null
                    };
                }
            }

            // å‘è´æ•°è¨ˆç®—
            const shanten = calculateShanten(hand);
            const yaku = calculateYaku(hand); // å‘è´æ•°è¨ˆç®—æ™‚ã‚‚å½¹åˆ¤å®šã‚’å®Ÿè¡Œ
            return {
                message: shanten === 1 ? 'ã‚¤ãƒ¼ã‚·ãƒ£ãƒ³ãƒ†ãƒ³' : `${shanten}ã‚·ãƒ£ãƒ³ãƒ†ãƒ³`,
                shanten: shanten,
                waitingTiles: [],
                yaku: yaku,
                discardToTenpai: null
            };
        }

        // æ¨ã¦ç‰Œå¾Œãƒ†ãƒ³ãƒ‘ã‚¤åˆ†æ
        function analyzeDiscardToTenpai(hand) {
            if (hand.length !== 14) {
                return { canReachTenpai: false, tenpaiOptions: [] };
            }

            const tenpaiOptions = [];

            // å„ç‰Œã‚’æ¨ã¦ãŸå ´åˆã®ãƒ†ãƒ³ãƒ‘ã‚¤ãƒã‚§ãƒƒã‚¯
            for (let i = 0; i < hand.length; i++) {
                const testHand = [...hand];
                const discardTile = testHand.splice(i, 1)[0];
                
                // 13æšã§ãƒ†ãƒ³ãƒ‘ã‚¤ãƒã‚§ãƒƒã‚¯
                const waitingTiles = getWaitingTiles(testHand);
                if (waitingTiles.length > 0) {
                    tenpaiOptions.push({
                        discardTile: discardTile,
                        waitingTiles: waitingTiles,
                        waitCount: waitingTiles.length,
                        totalWaitingTiles: waitingTiles.length * 4 // ç°¡æ˜“è¨ˆç®—
                    });
                }
            }

            return {
                canReachTenpai: tenpaiOptions.length > 0,
                tenpaiOptions: tenpaiOptions,
                bestOption: tenpaiOptions.length > 0 ? 
                    tenpaiOptions.reduce((best, current) => 
                        current.waitCount > best.waitCount ? current : best
                    ) : null
            };
        }

        // å’Œäº†å½¢åˆ¤å®š
        function isWinningShape(tiles) {
            if (tiles.length !== 14) return false;

            // ä¸ƒå¯¾å­ãƒã‚§ãƒƒã‚¯
            if (checkSevenPairs(tiles)) return true;

            // å›½å£«ç„¡åŒãƒã‚§ãƒƒã‚¯  
            if (checkThirteenOrphans(tiles)) return true;

            // é€šå¸¸å½¢ãƒã‚§ãƒƒã‚¯
            return checkNormalWinning(tiles);
        }

        // ä¸ƒå¯¾å­åˆ¤å®š
        function checkSevenPairs(tiles) {
            const counts = getTileCounts(tiles);
            const values = Object.values(counts);
            return values.length === 7 && values.every(count => count === 2);
        }

        // å›½å£«ç„¡åŒåˆ¤å®š
        function checkThirteenOrphans(tiles) {
            const required = [
                'man_1', 'man_9', 'pin_1', 'pin_9', 'sou_1', 'sou_9',
                'honors_east', 'honors_south', 'honors_west', 'honors_north',
                'honors_haku', 'honors_hatsu', 'honors_chun'
            ];
            
            const counts = {};
            tiles.forEach(tile => {
                const key = getTileKey(tile);
                counts[key] = (counts[key] || 0) + 1;
            });
            
            return required.every(req => counts[req] >= 1) && 
                   required.some(req => counts[req] === 2);
        }

        // é€šå¸¸å½¢åˆ¤å®š
        function checkNormalWinning(tiles) {
            const counts = getTileCounts(tiles);
            return checkMeldsRecursive(counts, 0);
        }

        // å¾…ã¡ç‰Œè¨ˆç®—
        function getWaitingTiles(tiles) {
            if (tiles.length !== 13) return [];

            const waitingTiles = [];

            for (const testTile of allTileTypes) {
                const testHand = [...tiles, testTile];
                if (isWinningShape(testHand)) {
                    waitingTiles.push(testTile);
                }
            }

            return waitingTiles;
        }

        // å‘è´æ•°è¨ˆç®—
        function calculateShanten(tiles) {
            if (tiles.length === 0) return 8;
            
            const counts = getTileCounts(tiles);
            const uniqueTiles = Object.keys(counts).length;
            
            // ç°¡æ˜“å®Ÿè£…
            if (uniqueTiles <= 7) return 1;
            if (uniqueTiles <= 10) return 2;
            if (uniqueTiles <= 12) return 3;
            return Math.min(6, uniqueTiles - 8);
        }

        // å½¹è¨ˆç®—ï¼ˆå¼·åŒ–ç‰ˆï¼‰
        function calculateYaku(hand) {
            const yaku = [];
            
            // å½¹æº€å„ªå…ˆåˆ¤å®š
            if (checkKokushi(hand)) {
                yaku.push({ name: 'å›½å£«ç„¡åŒ', han: 13 });
                return yaku; // å½¹æº€ã¯ä»–ã®å½¹ã¨è¤‡åˆã—ãªã„
            }
            if (checkSuuankou(hand)) {
                yaku.push({ name: 'å››æš—åˆ»', han: 13 });
                return yaku;
            }
            if (checkDaisangen(hand)) {
                yaku.push({ name: 'å¤§ä¸‰å…ƒ', han: 13 });
                return yaku;
            }
            if (checkTsuuiisou(hand)) {
                yaku.push({ name: 'å­—ä¸€è‰²', han: 13 });
                return yaku;
            }
            if (checkChinroutou(hand)) {
                yaku.push({ name: 'æ¸…è€é ­', han: 13 });
                return yaku;
            }
            if (checkRyuuiisou(hand)) {
                yaku.push({ name: 'ç·‘ä¸€è‰²', han: 13 });
                return yaku;
            }
            if (checkChuuren(hand)) {
                yaku.push({ name: 'ä¹è“®å®ç‡ˆ', han: 13 });
                return yaku;
            }
            if (checkSuukantsu(hand)) {
                yaku.push({ name: 'å››æ§“å­', han: 13 });
                return yaku;
            }

            // ç‰¹æ®Šå½¢åˆ¤å®š
            if (checkChiitoi(hand)) {
                yaku.push({ name: 'ä¸ƒå¯¾å­', han: 2 });
                // ä¸ƒå¯¾å­ã¯ä»–ã®å½¹ã¨è¤‡åˆå¯èƒ½ãªå ´åˆãŒã‚ã‚‹ãŒã€åŸºæœ¬çš„ã«ã¯å˜ç‹¬
                if (checkTanyao(hand)) yaku.push({ name: 'ã‚¿ãƒ³ãƒ¤ã‚ª', han: 1 });
                if (checkChinitsu(hand)) yaku.push({ name: 'æ¸…ä¸€è‰²', han: 6 });
                if (checkHonitsu(hand)) yaku.push({ name: 'æ··ä¸€è‰²', han: 3 });
                return yaku;
            }

            // é€šå¸¸å½¹åˆ¤å®šï¼ˆé †åºé‡è¦ï¼‰
            if (checkTanyao(hand)) yaku.push({ name: 'ã‚¿ãƒ³ãƒ¤ã‚ª', han: 1 });
            
            // ä¸€ç›ƒå£ãƒ»äºŒç›ƒå£ãƒã‚§ãƒƒã‚¯ï¼ˆãƒ”ãƒ³ãƒ•ã‚ˆã‚Šå…ˆï¼‰
            if (checkRyanpeikou(hand)) {
                yaku.push({ name: 'äºŒç›ƒå£', han: 3 });
            } else if (checkIipeikou(hand)) {
                yaku.push({ name: 'ä¸€ç›ƒå£', han: 1 });
            }
            
            // ãƒ”ãƒ³ãƒ•ãƒã‚§ãƒƒã‚¯ï¼ˆä¸€ç›ƒå£ãŒã‚ã£ã¦ã‚‚ãƒ”ãƒ³ãƒ•ã¯æˆç«‹å¯èƒ½ï¼‰
            if (checkPinfu(hand)) {
                yaku.push({ name: 'ãƒ”ãƒ³ãƒ•', han: 1 });
            }
            
            // è©³ç´°å½¹ç‰Œåˆ¤å®š
            const yakuhaiDetails = getYakuhaiDetails(hand);
            console.log('å½¹ç‰Œåˆ¤å®šçµæœ:', yakuhaiDetails);
            console.log('ç¾åœ¨ã®å‰¯éœ²:', melds);
            console.log('å½¹ç‰Œè©³ç´°:', JSON.stringify(yakuhaiDetails, null, 2));
            yakuhaiDetails.forEach(yakuhai => {
                console.log('å½¹ã‚’è¿½åŠ :', yakuhai);
                yaku.push(yakuhai);
            });
            
            if (checkToitoi(hand)) yaku.push({ name: 'å¯¾ã€…å’Œ', han: 2 });
            if (checkSanankou(hand)) yaku.push({ name: 'ä¸‰æš—åˆ»', han: 2 });
            if (checkSanshoku(hand)) yaku.push({ name: 'ä¸‰è‰²åŒé †', han: 2 });
            if (checkIttsu(hand)) yaku.push({ name: 'ä¸€æ°—é€šè²«', han: 2 });
            if (checkChanta(hand)) yaku.push({ name: 'æ··å…¨å¸¯ä¹ˆä¹', han: 2 });
            if (checkJunchan(hand)) yaku.push({ name: 'ç´”å…¨å¸¯ä¹ˆä¹', han: 3 });
            if (checkHonroutou(hand)) yaku.push({ name: 'æ··è€é ­', han: 2 });
            if (checkShousangen(hand)) yaku.push({ name: 'å°ä¸‰å…ƒ', han: 2 });
            if (checkHonitsu(hand)) yaku.push({ name: 'æ··ä¸€è‰²', han: 3 });
            if (checkChinitsu(hand)) yaku.push({ name: 'æ¸…ä¸€è‰²', han: 6 });

            // å‰¯éœ²ãŒã‚ã‚‹å ´åˆã¯å½¹ãªã—ã§ã‚‚è¡¨ç¤ºï¼ˆå®Ÿéš›ã®å’Œäº†æ™‚ã®ã¿ãƒ„ãƒ¢ç­‰ã‚’åˆ¤å®šï¼‰
            console.log('æœ€çµ‚å½¹çµæœ:', yaku);
            
            return yaku;
        }

        // å½¹åˆ¤å®šé–¢æ•°ç¾¤
        function checkTanyao(hand) {
            return hand.every(tile => {
                if (tile.suit === 'honors') return false;
                return tile.rank >= 2 && tile.rank <= 8;
            });
        }

        function checkPinfu(hand) {
            if (checkChiitoi(hand)) return false;
            
            const structure = analyzeHandStructure(hand);
            if (!structure || !structure.isComplete) return false;
            
            // 4ã¤ã®é †å­ã¨1ã¤ã®é›€é ­
            if (structure.sequences.length !== 4) return false;
            if (structure.triplets.length > 0 || structure.quads.length > 0) return false;
            if (structure.pairs.length !== 1) return false;
            
            // é›€é ­ãŒå½¹ç‰Œã§ãªã„ã“ã¨
            const pairKey = structure.pairs[0];
            if (Array.isArray(pairKey)) {
                const suit = pairKey[0];
                const rankOrType = pairKey[1];
                
                // å­—ç‰Œã¯å½¹ç‰Œ
                if (suit === 'honors') return false;
                
                // å ´é¢¨ãƒ»è‡ªé¢¨ãƒã‚§ãƒƒã‚¯
                if (suit === 'honors') {
                    if (rankOrType === gameSettings.gameWind) return false;
                    if (rankOrType === gameSettings.playerWind) return false;
                }
            } else {
                // æ–‡å­—åˆ—ã®å ´åˆã®å‡¦ç†
                if (typeof pairKey === 'string' && pairKey.startsWith('honors')) return false;
            }
            
            return true;
        }

        function checkChiitoi(hand) {
            const counts = getTileCounts(hand);
            const values = Object.values(counts);
            return values.length === 7 && values.every(count => count === 2);
        }

        function checkKokushi(hand) {
            return checkThirteenOrphans(hand);
        }

        function checkSuuankou(hand) {
            const counts = getTileCounts(hand);
            const triplets = Object.values(counts).filter(count => count >= 3).length;
            const pairs = Object.values(counts).filter(count => count === 2).length;
            return triplets === 4 && pairs === 1;
        }

        function checkDaisangen(hand) {
            const dragons = ['honors_haku', 'honors_hatsu', 'honors_chun'];
            const counts = getTileCounts(hand);
            return dragons.every(dragon => counts[dragon] >= 3);
        }

        function checkTsuuiisou(hand) {
            return hand.every(tile => tile.suit === 'honors');
        }

        function checkChinroutou(hand) {
            return hand.every(tile => {
                if (tile.suit === 'honors') return false;
                return tile.rank === 1 || tile.rank === 9;
            });
        }

        function checkRyuuiisou(hand) {
            const greenTiles = ['sou_2', 'sou_3', 'sou_4', 'sou_6', 'sou_8', 'honors_hatsu'];
            return hand.every(tile => {
                const key = getTileKey(tile);
                return greenTiles.includes(key);
            });
        }

        function checkChuuren(hand) {
            const suits = ['man', 'pin', 'sou'];
            return suits.some(suit => {
                const suitTiles = hand.filter(tile => tile.suit === suit);
                if (suitTiles.length !== 14) return false;
                
                const counts = {};
                suitTiles.forEach(tile => {
                    counts[tile.rank] = (counts[tile.rank] || 0) + 1;
                });
                
                return counts[1] >= 3 && counts[9] >= 3 && 
                       [2,3,4,5,6,7,8].every(rank => counts[rank] >= 1);
            });
        }

        function checkSuukantsu(hand) {
            const counts = getTileCounts(hand);
            const quads = Object.values(counts).filter(count => count === 4).length;
            return quads === 4;
        }

        function checkIipeikou(hand) {
            if (checkChiitoi(hand)) return false;
            
            const structure = analyzeHandStructure(hand);
            if (!structure || !structure.isComplete) return false;
            if (structure.sequences.length < 2) return false;
            
            // é †å­ã‚’æ­£è¦åŒ–ã—ã¦æ¯”è¼ƒ
            const sequencePatterns = structure.sequences.map(seq => {
                return seq.sort().join(',');
            });
            
            const patternCounts = {};
            sequencePatterns.forEach(pattern => {
                patternCounts[pattern] = (patternCounts[pattern] || 0) + 1;
            });
            
            // åŒã˜é †å­ãŒ2ã¤ä»¥ä¸Šã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            return Object.values(patternCounts).some(count => count >= 2);
        }

        function checkRyanpeikou(hand) {
            if (checkChiitoi(hand)) return false;
            
            const groups = analyzeHandStructure(hand);
            if (!groups) return false;
            
            const sequences = groups.sequences.map(seq => seq.sort().join(''));
            const counts = {};
            
            sequences.forEach(seq => {
                counts[seq] = (counts[seq] || 0) + 1;
            });
            
            const pairs = Object.values(counts).filter(count => count >= 2);
            return pairs.length >= 2;
        }

        function checkYakuhai(hand) {
            const counts = getTileCounts(hand);
            
            // å‰¯éœ²ã‹ã‚‰ã‚‚ã‚«ã‚¦ãƒ³ãƒˆè¿½åŠ 
            melds.forEach(meld => {
                if (meld.type === 'pon' || meld.type === 'kan' || meld.type === 'ankan') {
                    const key = meld.tiles[0];
                    counts[key] = (counts[key] || 0) + meld.tiles.length;
                }
            });
            
            let yakuhaiCount = 0;
            
            // ä¸‰å…ƒç‰Œãƒã‚§ãƒƒã‚¯ï¼ˆå¸¸ã«å½¹ç‰Œï¼‰
            const dragons = ['honors_haku', 'honors_hatsu', 'honors_chun'];
            dragons.forEach(dragon => {
                if (counts[dragon] >= 3) {
                    yakuhaiCount++;
                }
            });
            
            // å ´é¢¨ãƒã‚§ãƒƒã‚¯
            const gameWindKey = `honors_${gameSettings.gameWind}`;
            if (counts[gameWindKey] >= 3) {
                yakuhaiCount++;
            }
            
            // è‡ªé¢¨ãƒã‚§ãƒƒã‚¯ï¼ˆå ´é¢¨ã¨é‡è¤‡ã™ã‚‹å ´åˆã‚‚ã‚«ã‚¦ãƒ³ãƒˆï¼‰
            const playerWindKey = `honors_${gameSettings.playerWind}`;
            if (counts[playerWindKey] >= 3) {
                yakuhaiCount++;
            }
            
            return yakuhaiCount > 0;
        }

        // è©³ç´°å½¹ç‰Œæƒ…å ±å–å¾—ï¼ˆæ‰‹ç‰Œ+å‰¯éœ²ï¼‰
        function getYakuhaiDetails(hand) {
            const counts = getTileCounts(hand);
            const yakuhaiList = [];
            
            // å‰¯éœ²ã‹ã‚‰ã‚‚ã‚«ã‚¦ãƒ³ãƒˆè¿½åŠ 
            melds.forEach(meld => {
                if (meld.type === 'pon' || meld.type === 'kan' || meld.type === 'ankan') {
                    // åˆ»å­/æ§“å­ã®å ´åˆã¯3æšã¾ãŸã¯4æšã¨ã¿ãªã™
                    const key = meld.tiles[0]; // åŒã˜ç‰Œãªã®ã§æœ€åˆã®è¦ç´ ã§OK
                    counts[key] = (counts[key] || 0) + meld.tiles.length;
                }
            });
            
            // ä¸‰å…ƒç‰Œãƒã‚§ãƒƒã‚¯
            const dragonNames = { haku: 'ç™½', hatsu: 'ç™¼', chun: 'ä¸­' };
            Object.entries(dragonNames).forEach(([type, name]) => {
                const key = `honors_${type}`;
                if (counts[key] >= 3) {
                    yakuhaiList.push({ name: `å½¹ç‰Œ(${name})`, han: 1, type: 'dragon' });
                }
            });
            
            // å ´é¢¨ãƒã‚§ãƒƒã‚¯
            const gameWindKey = `honors_${gameSettings.gameWind}`;
            if (counts[gameWindKey] >= 3) {
                const windNames = { east: 'æ±', south: 'å—', west: 'è¥¿', north: 'åŒ—' };
                yakuhaiList.push({ 
                    name: `å ´é¢¨(${windNames[gameSettings.gameWind]})`, 
                    han: 1, 
                    type: 'gameWind' 
                });
            }
            
            // è‡ªé¢¨ãƒã‚§ãƒƒã‚¯
            const playerWindKey = `honors_${gameSettings.playerWind}`;
            if (counts[playerWindKey] >= 3) {
                const windNames = { east: 'æ±', south: 'å—', west: 'è¥¿', north: 'åŒ—' };
                yakuhaiList.push({ 
                    name: `è‡ªé¢¨(${windNames[gameSettings.playerWind]})`, 
                    han: 1, 
                    type: 'playerWind' 
                });
            }
            
            return yakuhaiList;
        }

        function checkToitoi(hand) {
            if (checkChiitoi(hand)) return false;
            
            const counts = getTileCounts(hand);
            const triplets = Object.values(counts).filter(count => count >= 3).length;
            const pairs = Object.values(counts).filter(count => count === 2).length;
            return triplets === 4 && pairs === 1;
        }

        function checkSanankou(hand) {
            const counts = getTileCounts(hand);
            const triplets = Object.values(counts).filter(count => count >= 3).length;
            return triplets >= 3;
        }

        function checkSanshoku(hand) {
            if (checkChiitoi(hand)) return false;
            
            // ä¸‰è‰²åŒé †ã®åˆ¤å®šï¼š3ã¤ã®è‰²ã§åŒã˜é †å­
            for (let rank = 1; rank <= 7; rank++) {
                const manSeq = [`man_${rank}`, `man_${rank+1}`, `man_${rank+2}`];
                const pinSeq = [`pin_${rank}`, `pin_${rank+1}`, `pin_${rank+2}`];
                const souSeq = [`sou_${rank}`, `sou_${rank+1}`, `sou_${rank+2}`];
                
                const counts = getTileCounts(hand);
                
                if (manSeq.every(tile => counts[tile] >= 1) &&
                    pinSeq.every(tile => counts[tile] >= 1) &&
                    souSeq.every(tile => counts[tile] >= 1)) {
                    return true;
                }
            }
            return false;
        }

        function checkIttsu(hand) {
            // ä¸€æ°—é€šè²«ï¼šåŒä¸€è‰²ã§1-9ã®é †å­
            const suits = ['man', 'pin', 'sou'];
            return suits.some(suit => {
                const seq1 = [`${suit}_1`, `${suit}_2`, `${suit}_3`];
                const seq2 = [`${suit}_4`, `${suit}_5`, `${suit}_6`];
                const seq3 = [`${suit}_7`, `${suit}_8`, `${suit}_9`];
                
                const counts = getTileCounts(hand);
                
                return seq1.every(tile => counts[tile] >= 1) &&
                       seq2.every(tile => counts[tile] >= 1) &&
                       seq3.every(tile => counts[tile] >= 1);
            });
        }

        function checkChanta(hand) {
            if (checkChiitoi(hand)) return false;
            
            // æ··å…¨å¸¯ä¹ˆä¹ï¼šå„ãƒ¡ãƒ³ãƒ„ã«ç«¯ç‰Œã‹å­—ç‰ŒãŒå«ã¾ã‚Œã‚‹
            return hand.every(tile => {
                if (tile.suit === 'honors') return true;
                return tile.rank === 1 || tile.rank === 9;
            });
        }

        function checkJunchan(hand) {
            if (checkChiitoi(hand)) return false;
            
            // ç´”å…¨å¸¯ä¹ˆä¹ï¼šå„ãƒ¡ãƒ³ãƒ„ã«ç«¯ç‰Œï¼ˆ1,9ï¼‰ãŒå«ã¾ã‚Œã€å­—ç‰Œãªã—
            const hasHonors = hand.some(tile => tile.suit === 'honors');
            if (hasHonors) return false;
            
            return hand.every(tile => tile.rank === 1 || tile.rank === 9);
        }

        function checkHonroutou(hand) {
            // æ··è€é ­ï¼šç«¯ç‰Œã¨å­—ç‰Œã®ã¿
            return hand.every(tile => {
                if (tile.suit === 'honors') return true;
                return tile.rank === 1 || tile.rank === 9;
            });
        }

        function checkShousangen(hand) {
            const dragons = ['honors_haku', 'honors_hatsu', 'honors_chun'];
            const counts = getTileCounts(hand);
            
            let tripletCount = 0;
            let pairCount = 0;
            
            dragons.forEach(dragon => {
                if (counts[dragon] >= 3) tripletCount++;
                if (counts[dragon] === 2) pairCount++;
            });
            
            return tripletCount === 2 && pairCount === 1;
        }

        function checkHonitsu(hand) {
            // æ··ä¸€è‰²ï¼š1ã¤ã®æ•°ç‰Œã¨å­—ç‰Œã®ã¿
            const suits = new Set(hand.map(tile => tile.suit));
            const hasHonors = suits.has('honors');
            const numberSuits = [...suits].filter(suit => suit !== 'honors');
            
            return hasHonors && numberSuits.length === 1;
        }

        function checkChinitsu(hand) {
            // æ¸…ä¸€è‰²ï¼š1ã¤ã®æ•°ç‰Œã®ã¿
            const suits = new Set(hand.map(tile => tile.suit));
            return suits.size === 1 && !suits.has('honors');
        }

        // æ‰‹ç‰Œæ§‹é€ åˆ†æï¼ˆå¼·åŒ–ç‰ˆï¼‰
        function analyzeHandStructure(hand) {
            if (hand.length !== 14) return null;
            
            // æœ€é©ãªé¢å­æ§‹æˆã‚’æ¢ç´¢
            const bestStructure = findBestMeldStructure(hand);
            return bestStructure;
        }

        // æœ€é©ãªé¢å­æ§‹æˆã‚’æ¢ç´¢
        function findBestMeldStructure(hand) {
            const counts = getTileCounts(hand);
            
            // å¯èƒ½ãªå…¨ã¦ã®é¢å­æ§‹æˆã‚’è©¦è¡Œ
            const possibleStructures = [];
            
            // å„ç‰Œã‚’é›€é ­ã¨ã—ã¦è©¦ã™
            Object.keys(counts).forEach(pairKey => {
                if (counts[pairKey] >= 2) {
                    const testCounts = { ...counts };
                    testCounts[pairKey] -= 2;
                    
                    // å…¨ã¦ã®å¯èƒ½ãªæ§‹é€ ã‚’æ¢ç´¢
                    const structures = findAllMeldStructures(testCounts, [], pairKey);
                    structures.forEach(structure => {
                        if (structure && structure.isComplete) {
                            possibleStructures.push(structure);
                        }
                    });
                }
            });
            
            // æœ€ã‚‚é©åˆ‡ãªæ§‹é€ ã‚’é¸æŠï¼ˆä¸€ç›ƒå£æ¤œå‡ºã®ãŸã‚å…¨æ§‹é€ ã‚’ä¿æŒï¼‰
            if (possibleStructures.length === 0) return null;
            
            // ä¸€ç›ƒå£ãŒæ¤œå‡ºã§ãã‚‹æ§‹é€ ã‚’å„ªå…ˆ
            const iipeikouStructures = possibleStructures.filter(structure => {
                return hasIipeikou(structure);
            });
            
            if (iipeikouStructures.length > 0) {
                return iipeikouStructures[0];
            }
            
            // é€šå¸¸ã¯é †å­å„ªå…ˆã®æ§‹é€ ã‚’é¸æŠ
            return possibleStructures.reduce((best, current) => {
                const bestScore = calculateStructureScore(best);
                const currentScore = calculateStructureScore(current);
                return currentScore > bestScore ? current : best;
            });
        }

        // å…¨ã¦ã®é¢å­æ§‹é€ ã‚’æ¢ç´¢
        function findAllMeldStructures(counts, melds, pairKey) {
            const remainingTiles = Object.values(counts).reduce((sum, count) => sum + count, 0);
            
            if (remainingTiles === 0) {
                return [{
                    isComplete: true,
                    pairs: [pairKey.split('_')],
                    triplets: melds.filter(m => m.type === 'triplet').map(m => m.tiles),
                    quads: melds.filter(m => m.type === 'quad').map(m => m.tiles),
                    sequences: melds.filter(m => m.type === 'sequence').map(m => m.tiles)
                }];
            }
            
            const allStructures = [];
            
            // é †å­ã‚’æ¢ã™
            ['man', 'pin', 'sou'].forEach(suit => {
                for (let rank = 1; rank <= 7; rank++) {
                    const key1 = `${suit}_${rank}`;
                    const key2 = `${suit}_${rank + 1}`;
                    const key3 = `${suit}_${rank + 2}`;
                    
                    if (counts[key1] >= 1 && counts[key2] >= 1 && counts[key3] >= 1) {
                        const newCounts = { ...counts };
                        newCounts[key1] -= 1;
                        newCounts[key2] -= 1;
                        newCounts[key3] -= 1;
                        const newMelds = [...melds, { type: 'sequence', tiles: [key1, key2, key3] }];
                        
                        const structures = findAllMeldStructures(newCounts, newMelds, pairKey);
                        allStructures.push(...structures);
                    }
                }
            });
            
            // åˆ»å­ã‚’æ¢ã™
            for (const [key, count] of Object.entries(counts)) {
                if (count >= 3) {
                    const newCounts = { ...counts };
                    newCounts[key] -= 3;
                    const newMelds = [...melds, { type: 'triplet', tiles: [key, key, key] }];
                    
                    const structures = findAllMeldStructures(newCounts, newMelds, pairKey);
                    allStructures.push(...structures);
                }
            }
            
            return allStructures;
        }

        // ä¸€ç›ƒå£ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ¤œå‡º
        function hasIipeikou(structure) {
            if (!structure || structure.sequences.length < 2) return false;
            
            const sequencePatterns = structure.sequences.map(seq => {
                return seq.sort().join(',');
            });
            
            const patternCounts = {};
            sequencePatterns.forEach(pattern => {
                patternCounts[pattern] = (patternCounts[pattern] || 0) + 1;
            });
            
            return Object.values(patternCounts).some(count => count >= 2);
        }

        // é¢å­ã®å†å¸°çš„æ¢ç´¢ï¼ˆæ”¹è‰¯ç‰ˆï¼‰
        function findMeldsRecursive(counts, melds, pairKey) {
            const remainingTiles = Object.values(counts).reduce((sum, count) => sum + count, 0);
            
            if (remainingTiles === 0) {
                return {
                    isComplete: true,
                    pairs: [pairKey.split('_')],
                    triplets: melds.filter(m => m.type === 'triplet').map(m => m.tiles),
                    quads: melds.filter(m => m.type === 'quad').map(m => m.tiles),
                    sequences: melds.filter(m => m.type === 'sequence').map(m => m.tiles)
                };
            }
            
            // é †å­ã‚’å„ªå…ˆã—ã¦æ¢ã™ï¼ˆä¸€ç›ƒå£ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ­£ã—ãæ¤œå‡ºã™ã‚‹ãŸã‚ï¼‰
            ['man', 'pin', 'sou'].forEach(suit => {
                for (let rank = 1; rank <= 7; rank++) {
                    const key1 = `${suit}_${rank}`;
                    const key2 = `${suit}_${rank + 1}`;
                    const key3 = `${suit}_${rank + 2}`;
                    
                    if (counts[key1] >= 1 && counts[key2] >= 1 && counts[key3] >= 1) {
                        const newCounts = { ...counts };
                        newCounts[key1] -= 1;
                        newCounts[key2] -= 1;
                        newCounts[key3] -= 1;
                        const newMelds = [...melds, { type: 'sequence', tiles: [key1, key2, key3] }];
                        
                        const result = findMeldsRecursive(newCounts, newMelds, pairKey);
                        if (result && result.isComplete) return result;
                    }
                }
            });
            
            // åˆ»å­ã‚’æ¢ã™
            for (const [key, count] of Object.entries(counts)) {
                if (count >= 3) {
                    const newCounts = { ...counts };
                    newCounts[key] -= 3;
                    const newMelds = [...melds, { type: 'triplet', tiles: [key, key, key] }];
                    
                    const result = findMeldsRecursive(newCounts, newMelds, pairKey);
                    if (result && result.isComplete) return result;
                }
            }
            
            return null;
        }

        // æ§‹é€ ã‚¹ã‚³ã‚¢è¨ˆç®—ï¼ˆé †å­ã‚’å„ªå…ˆï¼‰
        function calculateStructureScore(structure) {
            if (!structure) return 0;
            return structure.sequences.length * 2 + structure.triplets.length;
        }

        function isHonorTile(tile) {
            return typeof tile === 'object' ? tile.suit === 'honors' : tile.startsWith('honors');
        }

        // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
        function getTileCounts(tiles) {
            const counts = {};
            tiles.forEach(tile => {
                const key = getTileKey(tile);
                counts[key] = (counts[key] || 0) + 1;
            });
            return counts;
        }

        function getTileKey(tile) {
            return `${tile.suit}_${tile.rank || tile.type}`;
        }

        function checkMeldsRecursive(counts, pairCount) {
            const entries = Object.entries(counts).filter(([_, count]) => count > 0);
            
            if (entries.length === 0) {
                return pairCount === 1;
            }
            
            for (const [tileKey, count] of entries) {
                // é›€é ­ã‚’ä½œã‚‹
                if (count >= 2 && pairCount === 0) {
                    const newCounts = { ...counts };
                    newCounts[tileKey] -= 2;
                    if (checkMeldsRecursive(newCounts, 1)) return true;
                }
                
                // åˆ»å­ã‚’ä½œã‚‹
                if (count >= 3) {
                    const newCounts = { ...counts };
                    newCounts[tileKey] -= 3;
                    if (checkMeldsRecursive(newCounts, pairCount)) return true;
                }
                
                // é †å­ã‚’ä½œã‚‹
                const [suit, rank] = tileKey.split('_');
                if (suit !== 'honors' && parseInt(rank) <= 7) {
                    const key1 = `${suit}_${parseInt(rank)}`;
                    const key2 = `${suit}_${parseInt(rank) + 1}`;
                    const key3 = `${suit}_${parseInt(rank) + 2}`;
                    
                    if (counts[key1] >= 1 && counts[key2] >= 1 && counts[key3] >= 1) {
                        const newCounts = { ...counts };
                        newCounts[key1] -= 1;
                        newCounts[key2] -= 1;
                        newCounts[key3] -= 1;
                        if (checkMeldsRecursive(newCounts, pairCount)) return true;
                    }
                }
                
                break;
            }
            
            return false;
        }

        // é¢å­æ§‹é€ ãƒ‡ãƒãƒƒã‚°åˆ†æ
        function analyzeMeldStructureDebug(hand) {
            const counts = getTileCounts(hand);
            const allStructures = [];
            
            // å…¨ã¦ã®å¯èƒ½ãªé›€é ­ã«ã¤ã„ã¦æ§‹é€ ã‚’æ¢ã™
            for (const [tileKey, count] of Object.entries(counts)) {
                if (count >= 2) {
                    const newCounts = { ...counts };
                    newCounts[tileKey] -= 2;
                    const structures = findAllMeldStructures(newCounts, [], tileKey);
                    if (structures && structures.length > 0) {
                        allStructures.push(...structures);
                    }
                }
            }
            
            return {
                å¯èƒ½æ§‹é€ æ•°: allStructures.length,
                å…¨æ§‹é€ : allStructures.map((structure, index) => ({
                    æ§‹é€ ç•ªå·: index + 1,
                    é›€é ­: structure.pairs.map(pair => {
                        const key = Array.isArray(pair) ? pair.join('_') : pair;
                        const [suit, rank] = key.split('_');
                        return getTileDisplayName({suit, rank: parseInt(rank) || rank});
                    }).join(''),
                    åˆ»å­: structure.triplets.map(triplet => 
                        triplet.map(key => {
                            const [suit, rank] = key.split('_');
                            return getTileDisplayName({suit, rank: parseInt(rank) || rank});
                        }).join('')
                    ).join(', '),
                    é †å­: structure.sequences.map(sequence => 
                        sequence.map(key => {
                            const [suit, rank] = key.split('_');
                            return getTileDisplayName({suit, rank: parseInt(rank) || rank});
                        }).join('')
                    ).join(', '),
                    ä¸€ç›ƒå£åˆ¤å®š: structure.sequences.length >= 2 ? 
                        checkIipeikouInStructure(structure.sequences) : false
                })),
                ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ†æ: {
                    é€£ç¶šãƒ‘ã‚¿ãƒ¼ãƒ³: analyzeConsecutivePatterns(counts),
                    é‡è¤‡åˆ¤å®š: analyzeOverlappingPatterns(counts)
                }
            };
        }

        // æ§‹é€ å†…ã§ã®ä¸€ç›ƒå£ãƒã‚§ãƒƒã‚¯
        function checkIipeikouInStructure(sequences) {
            const sequenceStrings = sequences.map(seq => seq.join(''));
            const uniqueSequences = [...new Set(sequenceStrings)];
            return sequenceStrings.length > uniqueSequences.length;
        }

        // é€£ç¶šãƒ‘ã‚¿ãƒ¼ãƒ³åˆ†æ
        function analyzeConsecutivePatterns(counts) {
            const patterns = [];
            const suits = ['man', 'pin', 'sou'];
            
            suits.forEach(suit => {
                for (let rank = 1; rank <= 7; rank++) {
                    const key1 = `${suit}_${rank}`;
                    const key2 = `${suit}_${rank + 1}`;
                    const key3 = `${suit}_${rank + 2}`;
                    
                    const count1 = counts[key1] || 0;
                    const count2 = counts[key2] || 0;
                    const count3 = counts[key3] || 0;
                    
                    if (count1 > 0 && count2 > 0 && count3 > 0) {
                        patterns.push({
                            ä½ç½®: `${suit}_${rank}-${rank + 2}`,
                            æšæ•°: [count1, count2, count3],
                            æœ€å°: Math.min(count1, count2, count3),
                            ãƒ‘ã‚¿ãƒ¼ãƒ³: count1 === count2 && count2 === count3 ? 'åŒæ•°' : 'ç•°æ•°'
                        });
                    }
                }
            });
            
            return patterns;
        }

        // é‡è¤‡ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ†æ
        function analyzeOverlappingPatterns(counts) {
            const overlaps = [];
            const suits = ['man', 'pin', 'sou'];
            
            suits.forEach(suit => {
                for (let rank = 1; rank <= 9; rank++) {
                    const key = `${suit}_${rank}`;
                    const count = counts[key] || 0;
                    
                    if (count >= 2) {
                        overlaps.push({
                            ç‰Œ: getTileDisplayName({suit, rank}),
                            æšæ•°: count,
                            å¯èƒ½æ€§: count >= 3 ? ['åˆ»å­', 'é›€é ­'] : ['é›€é ­ã®ã¿']
                        });
                    }
                }
            });
            
            return overlaps;
        }

        // å¾…ã¡ç‰Œè¡¨ç¤ºæ›´æ–°
        function updateWaitingTiles(waitingTiles, handState) {
            const container = document.getElementById('waitingTiles');
            container.innerHTML = '';

            // é€šå¸¸ã®å¾…ã¡ç‰Œè¡¨ç¤º
            if (waitingTiles && waitingTiles.length > 0) {
                waitingTiles.forEach(tile => {
                    const tileElement = document.createElement('div');
                    tileElement.className = 'waiting-tile';
                    tileElement.textContent = getTileSymbol(tile);
                    container.appendChild(tileElement);
                });
                return;
            }

            // æ¨ã¦ç‰Œã§ãƒ†ãƒ³ãƒ‘ã‚¤å¯èƒ½ãªå ´åˆã®è¡¨ç¤º
            if (handState && handState.discardToTenpai && handState.discardToTenpai.canReachTenpai) {
                const bestOption = handState.discardToTenpai.bestOption;
                
                const discardInfo = document.createElement('div');
                discardInfo.style.cssText = `
                    color: #FFD700; 
                    font-size: 12px; 
                    margin-bottom: 8px;
                    font-weight: bold;
                `;
                discardInfo.textContent = `${getTileDisplayName(bestOption.discardTile)}ã‚’æ¨ã¦ã‚Œã°ãƒ†ãƒ³ãƒ‘ã‚¤`;
                container.appendChild(discardInfo);

                // æ¨ã¦ç‰Œå¾Œã®å¾…ã¡ç‰Œã‚’è¡¨ç¤º
                bestOption.waitingTiles.forEach(tile => {
                    const tileElement = document.createElement('div');
                    tileElement.className = 'waiting-tile';
                    tileElement.style.cssText += `
                        border: 1px dashed #FFD700;
                        background: rgba(255,215,0,0.1);
                    `;
                    tileElement.textContent = getTileSymbol(tile);
                    container.appendChild(tileElement);
                });

                const countInfo = document.createElement('div');
                countInfo.style.cssText = `
                    color: #AAA; 
                    font-size: 10px; 
                    margin-top: 4px;
                `;
                countInfo.textContent = `${bestOption.waitCount}ç¨®${bestOption.totalWaitingTiles}æšå¾…ã¡`;
                container.appendChild(countInfo);
                
                return;
            }

            // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¡¨ç¤º
            container.innerHTML = '<div style="color: #999; font-size: 14px;">å¾…ã¡ç‰Œãªã—</div>';
        }

        // å½¹è¡¨ç¤ºæ›´æ–°
        function updateYakuDisplay(yaku) {
            const container = document.getElementById('yakuList');
            container.innerHTML = '';

            if (yaku.length === 0) {
                container.innerHTML = '<div class="yaku-item"><span>å½¹ãªã—</span><span>0ç¿»</span></div>';
                return;
            }

            // å½¹ä¸€è¦§è¡¨ç¤º
            yaku.forEach(y => {
                const yakuElement = document.createElement('div');
                yakuElement.className = 'yaku-item';
                yakuElement.innerHTML = `<span>${y.name}</span><span>${y.han}ç¿»</span>`;
                container.appendChild(yakuElement);
            });

            // ç¬¦ã¨ç‚¹æ•°ã®è©³ç´°è¡¨ç¤º
            const totalHan = yaku.reduce((sum, y) => sum + y.han, 0);
            if (totalHan > 0) {
                const fuDetails = calculateDetailedFu(currentHand, yaku, isRon, winTile);
                const detailedPoints = calculateDetailedPoints(totalHan, fuDetails.total, gameSettings.playerWind === 'east');
                
                // ç¬¦ã®è©³ç´°è¡¨ç¤º
                const fuSectionElement = document.createElement('div');
                fuSectionElement.style.borderTop = '1px solid rgba(255,215,0,0.3)';
                fuSectionElement.style.marginTop = '8px';
                fuSectionElement.style.paddingTop = '8px';
                container.appendChild(fuSectionElement);
                
                // ç¬¦è¨ˆç®—è©³ç´°
                fuDetails.breakdown.forEach(item => {
                    const fuItemElement = document.createElement('div');
                    fuItemElement.className = 'yaku-item';
                    fuItemElement.style.fontSize = '12px';
                    fuItemElement.style.color = '#CCC';
                    fuItemElement.innerHTML = `<span>${item.source}</span><span>+${item.fu}ç¬¦</span>`;
                    container.appendChild(fuItemElement);
                });
                
                // ç¬¦åˆè¨ˆ
                const fuTotalElement = document.createElement('div');
                fuTotalElement.className = 'yaku-item';
                fuTotalElement.style.fontWeight = 'bold';
                fuTotalElement.innerHTML = `<span>ç¬¦è¨ˆ</span><span>${fuDetails.total}ç¬¦</span>`;
                container.appendChild(fuTotalElement);
                
                // ç‚¹æ•°è¡¨ç¤º
                const pointElement = document.createElement('div');
                pointElement.className = 'yaku-item';
                pointElement.style.fontWeight = 'bold';
                pointElement.style.color = '#FFD700';
                pointElement.style.marginTop = '4px';
                pointElement.innerHTML = `<span>${detailedPoints.category}</span><span>${detailedPoints.ronPoints}ç‚¹</span>`;
                container.appendChild(pointElement);
                
                // ãƒ„ãƒ¢ç‚¹æ•°è¡¨ç¤º
                const tsumoElement = document.createElement('div');
                tsumoElement.className = 'yaku-item';
                tsumoElement.style.fontSize = '12px';
                tsumoElement.style.color = '#AAA';
                tsumoElement.innerHTML = `<span>ãƒ„ãƒ¢</span><span>${detailedPoints.tsumoPoints}</span>`;
                container.appendChild(tsumoElement);
            }
        }

        // ãƒ‡ãƒãƒƒã‚°æƒ…å ±æ›´æ–°
        function updateDebugInfo(handState) {
            const container = document.getElementById('debugInfo');
            
            // è©³ç´°ãªå½¹æƒ…å ±ã‚’å«ã‚€
            const yakuDetails = (handState.yaku || []).map(yaku => ({
                name: yaku.name,
                han: yaku.han,
                type: getYakuType(yaku.han)
            }));
            
            const totalHan = yakuDetails.reduce((sum, yaku) => sum + yaku.han, 0);
            
            // ç¬¦ã¨ç‚¹æ•°ã®è©³ç´°è¨ˆç®—
            const fuDetails = calculateDetailedFu(currentHand, handState.yaku || [], isRon, winTile);
            const detailedPoints = totalHan > 0 ? calculateDetailedPoints(totalHan, fuDetails.total, gameSettings.playerWind === 'east') : null;
            
            const debugData = {
                ã‚²ãƒ¼ãƒ è¨­å®š: {
                    å ´é¢¨: getWindName(gameSettings.gameWind),
                    è‡ªé¢¨: getWindName(gameSettings.playerWind),
                    å±€æ•°: `${gameSettings.round}å±€`,
                    è¦ªå®¶: gameSettings.playerWind === 'east' ? 'ã¯ã„' : 'ã„ã„ãˆ'
                },
                æ‰‹ç‰Œæƒ…å ±: {
                    æ‰‹ç‰Œ: currentHand.map(getTileDisplayName).join(' '),
                    ã‚½ãƒ¼ãƒˆæ¸ˆã¿: currentHand.map(tile => getTileKey(tile)).join(' '),
                    ç‰Œæ§‹æˆ: getTileCounts(currentHand)
                },
                æ‰‹ç‰Œåˆ†æ: {
                    æšæ•°: currentHand.length,
                    çŠ¶æ…‹: handState.message,
                    å‘è´æ•°: handState.shanten,
                    å®Œæˆ: handState.isComplete || false
                },
                å½¹æƒ…å ±: {
                    å½¹æ•°: yakuDetails.length,
                    ç·ç¿»æ•°: totalHan,
                    å½¹è©³ç´°: yakuDetails,
                    ç¬¦è©³ç´°: fuDetails,
                    ç‚¹æ•°è©³ç´°: detailedPoints,
                    ç°¡æ˜“ç‚¹æ•°: calculatePoints(totalHan)
                },
                ä¸ŠãŒã‚Šè¨­å®š: {
                    ä¸ŠãŒã‚Šç‰Œ: winTile ? getTileDisplayName(winTile) : 'ãªã—',
                    å’Œäº†æ–¹æ³•: winTile ? (isRon ? 'ãƒ­ãƒ³' : 'ãƒ„ãƒ¢') : 'ãªã—'
                },
                å¾…ã¡æƒ…å ±: {
                    å¾…ã¡ç¨®é¡æ•°: (handState.waitingTiles || []).length,
                    å¾…ã¡ç‰Œ: (handState.waitingTiles || []).map(getTileDisplayName)
                },
                ãƒ†ãƒ³ãƒ‘ã‚¤å¯èƒ½æ€§: handState.discardToTenpai ? {
                    æ¨ã¦ç‰Œã§ãƒ†ãƒ³ãƒ‘ã‚¤: handState.discardToTenpai.canReachTenpai,
                    é¸æŠè‚¢æ•°: handState.discardToTenpai.tenpaiOptions.length,
                    æœ€é©è§£: handState.discardToTenpai.bestOption ? {
                        æ¨ã¦ç‰Œ: getTileDisplayName(handState.discardToTenpai.bestOption.discardTile),
                        å¾…ã¡ç¨®é¡: handState.discardToTenpai.bestOption.waitCount,
                        å¾…ã¡ç‰Œ: handState.discardToTenpai.bestOption.waitingTiles.map(getTileDisplayName).join(' ')
                    } : null,
                    å…¨é¸æŠè‚¢: handState.discardToTenpai.tenpaiOptions.map(option => ({
                        æ¨ã¦ç‰Œ: getTileDisplayName(option.discardTile),
                        å¾…ã¡: `${option.waitCount}ç¨®`,
                        å¾…ã¡ç‰Œ: option.waitingTiles.map(getTileDisplayName).join(' ')
                    }))
                } : null,
                æ‰‹ç‰Œæ§‹æˆ: analyzeHandComposition(currentHand),
                é¢å­æ§‹é€ : analyzeMeldStructureDebug(currentHand),
                å‰¯éœ²æƒ…å ±: {
                    å‰¯éœ²æ•°: melds.length,
                    è©³ç´°: melds.map(meld => ({
                        ç¨®é¡: meld.type,
                        ç‰Œ: meld.display,
                        å†…éƒ¨ã‚­ãƒ¼: meld.tiles
                    }))
                },
                çµ±è¨ˆ: gameStats
            };
            
            container.textContent = JSON.stringify(debugData, null, 2);
        }

        // é¢¨ã®åå‰å–å¾—
        function getWindName(wind) {
            const windNames = { east: 'æ±', south: 'å—', west: 'è¥¿', north: 'åŒ—' };
            return windNames[wind] || wind;
        }

        // å½¹ã®ã‚¿ã‚¤ãƒ—ã‚’å–å¾—
        function getYakuType(han) {
            if (han >= 13) return 'å½¹æº€';
            if (han >= 6) return 'è·³æº€ä»¥ä¸Š';
            if (han >= 3) return 'æº€è²«å€™è£œ';
            if (han >= 2) return 'ä¸­å½¹';
            return 'åŸºæœ¬å½¹';
        }

        // ç¬¦è¨ˆç®—ï¼ˆè©³ç´°ç‰ˆï¼‰
        function calculateDetailedFu(hand, yaku, isRon = false, winTile = null) {
            if (!yaku || yaku.length === 0) return { total: 0, breakdown: [] };
            
            const breakdown = [];
            
            // ä¸ƒå¯¾å­ã¯25ç¬¦å›ºå®š
            if (yaku.some(y => y.name === 'ä¸ƒå¯¾å­')) {
                breakdown.push({ source: 'ä¸ƒå¯¾å­', fu: 25 });
                return { total: 25, breakdown };
            }
            
            // ãƒ”ãƒ³ãƒ•ã®å ´åˆ
            if (yaku.some(y => y.name === 'ãƒ”ãƒ³ãƒ•')) {
                const fuValue = isRon ? 30 : 20;
                breakdown.push({ source: `ãƒ”ãƒ³ãƒ•(${isRon ? 'ãƒ­ãƒ³' : 'ãƒ„ãƒ¢'})`, fu: fuValue });
                return { total: fuValue, breakdown };
            }
            
            let fu = 20; // åŸºæœ¬ç¬¦
            breakdown.push({ source: 'åŸºæœ¬ç¬¦', fu: 20 });
            
            // å‰¯éœ²ãƒšãƒŠãƒ«ãƒ†ã‚£ï¼ˆé–€å‰ã§ãªã„å ´åˆï¼‰
            if (melds.length > 0) {
                fu = 30;
                breakdown[0] = { source: 'åŸºæœ¬ç¬¦(å‰¯éœ²)', fu: 30 };
            }
            
            // å’Œäº†æ–¹æ³•ã«ã‚ˆã‚‹ç¬¦
            if (!isRon) {
                fu += 2;
                breakdown.push({ source: 'ãƒ„ãƒ¢å’Œäº†', fu: 2 });
            }
            
            // é›€é ­ã«ã‚ˆã‚‹ç¬¦
            const counts = getTileCounts(hand);
            
            // å‰¯éœ²ã‹ã‚‰ã‚‚ã‚«ã‚¦ãƒ³ãƒˆè¿½åŠ 
            melds.forEach(meld => {
                if (meld.type === 'pon' || meld.type === 'kan' || meld.type === 'ankan') {
                    const key = meld.tiles[0];
                    counts[key] = (counts[key] || 0) + meld.tiles.length;
                }
            });
            
            // å½¹ç‰Œé›€é ­
            for (const [key, count] of Object.entries(counts)) {
                if (count === 2) {
                    if (key === `honors_${gameSettings.gameWind}`) {
                        fu += 2;
                        breakdown.push({ source: 'å ´é¢¨é›€é ­', fu: 2 });
                    }
                    if (key === `honors_${gameSettings.playerWind}`) {
                        fu += 2;
                        breakdown.push({ source: 'è‡ªé¢¨é›€é ­', fu: 2 });
                    }
                    if (['honors_haku', 'honors_hatsu', 'honors_chun'].includes(key)) {
                        fu += 2;
                        const [suit, rank] = key.split('_');
                        const tileName = getTileDisplayName({ suit, type: rank });
                        breakdown.push({ source: `å½¹ç‰Œé›€é ­(${tileName})`, fu: 2 });
                    }
                }
            }
            
            // æ‰‹ç‰Œã®é¢å­ã«ã‚ˆã‚‹ç¬¦
            for (const [key, count] of Object.entries(getTileCounts(hand))) {
                if (count >= 3) {
                    const [suit, rank] = key.split('_');
                    const isTerminal = (suit !== 'honors' && (rank === '1' || rank === '9')) || suit === 'honors';
                    const fuValue = isTerminal ? 8 : 4;
                    
                    let tileObj;
                    if (suit === 'honors') {
                        tileObj = { suit, type: rank };
                    } else {
                        tileObj = { suit, rank: parseInt(rank) };
                    }
                    const tileName = getTileDisplayName(tileObj);
                    
                    fu += fuValue;
                    breakdown.push({ 
                        source: `æš—åˆ»(${tileName})`, 
                        fu: fuValue 
                    });
                }
            }
            
            // å‰¯éœ²ã®é¢å­ã«ã‚ˆã‚‹ç¬¦
            melds.forEach(meld => {
                const [suit, rank] = meld.tiles[0].split('_');
                const isTerminal = (suit !== 'honors' && (rank === '1' || rank === '9')) || suit === 'honors';
                
                let tileObj;
                if (suit === 'honors') {
                    tileObj = { suit, type: rank };
                } else {
                    tileObj = { suit, rank: parseInt(rank) };
                }
                const tileName = getTileDisplayName(tileObj);
                
                if (meld.type === 'pon') {
                    const fuValue = isTerminal ? 4 : 2;
                    fu += fuValue;
                    breakdown.push({ source: `æ˜åˆ»(${tileName})`, fu: fuValue });
                } else if (meld.type === 'kan') {
                    const fuValue = isTerminal ? 16 : 8;
                    fu += fuValue;
                    breakdown.push({ source: `æ˜æ§“(${tileName})`, fu: fuValue });
                } else if (meld.type === 'ankan') {
                    const fuValue = isTerminal ? 32 : 16;
                    fu += fuValue;
                    breakdown.push({ source: `æš—æ§“(${tileName})`, fu: fuValue });
                }
            });
            
            // å¾…ã¡ã«ã‚ˆã‚‹ç¬¦
            if (winTile) {
                const waitType = analyzeWaitPattern(hand, winTile);
                if (waitType.fu > 0) {
                    fu += waitType.fu;
                    breakdown.push({ source: waitType.name, fu: waitType.fu });
                }
            }
            
            // ç¬¦ã¯10ã®ä½ã§åˆ‡ã‚Šä¸Šã’
            const roundedFu = Math.ceil(fu / 10) * 10;
            if (roundedFu > fu) {
                breakdown.push({ source: 'åˆ‡ã‚Šä¸Šã’', fu: roundedFu - fu });
            }
            
            return { total: roundedFu, breakdown };
        }

        // å¾…ã¡ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ†æ
        function analyzeWaitPattern(hand, winTile) {
            // ç°¡æ˜“çš„ãªå¾…ã¡ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ¤å®š
            // ã‚ˆã‚Šè©³ç´°ãªå®Ÿè£…ãŒå¿…è¦ã ãŒã€åŸºæœ¬çš„ãªãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’åˆ¤å®š
            
            const counts = getTileCounts(hand);
            const winKey = getTileKey(winTile);
            
            // é›€é ­å®Œæˆï¼ˆå˜é¨å¾…ã¡ï¼‰ã®å¯èƒ½æ€§ã‚’ãƒã‚§ãƒƒã‚¯
            if (counts[winKey] === 2) {
                // ä»–ã®éƒ¨åˆ†ãŒå…¨ã¦é¢å­ã«ãªã£ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                const tempCounts = { ...counts };
                tempCounts[winKey] -= 2; // é›€é ­ã‚’é™¤å»
                
                if (isAllMelds(tempCounts)) {
                    return { name: 'å˜é¨å¾…ã¡', fu: 2 };
                }
            }
            
            // åµŒå¼µãƒ»è¾ºå¼µã®åˆ¤å®šï¼ˆç°¡æ˜“ç‰ˆï¼‰
            const [suit, rank] = winKey.split('_');
            if (suit !== 'honors') {
                const rankNum = parseInt(rank);
                
                // åµŒå¼µï¼ˆçœŸã‚“ä¸­ã®ç‰Œã§å®Œæˆï¼‰
                if (rankNum >= 2 && rankNum <= 8) {
                    const before = `${suit}_${rankNum - 1}`;
                    const after = `${suit}_${rankNum + 1}`;
                    if (counts[before] >= 1 && counts[after] >= 1) {
                        return { name: 'åµŒå¼µå¾…ã¡', fu: 2 };
                    }
                }
                
                // è¾ºå¼µï¼ˆ1-2ã®3å¾…ã¡ã€8-9ã®7å¾…ã¡ï¼‰
                if (rankNum === 3 && counts[`${suit}_1`] >= 1 && counts[`${suit}_2`] >= 1) {
                    return { name: 'è¾ºå¼µå¾…ã¡', fu: 2 };
                }
                if (rankNum === 7 && counts[`${suit}_8`] >= 1 && counts[`${suit}_9`] >= 1) {
                    return { name: 'è¾ºå¼µå¾…ã¡', fu: 2 };
                }
            }
            
            return { name: 'ä¸¡é¢å¾…ã¡', fu: 0 };
        }

        // å…¨ã¦é¢å­ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆç°¡æ˜“ç‰ˆï¼‰
        function isAllMelds(counts) {
            const entries = Object.entries(counts).filter(([_, count]) => count > 0);
            if (entries.length === 0) return true;
            
            for (const [key, count] of entries) {
                if (count >= 3) {
                    const newCounts = { ...counts };
                    newCounts[key] -= 3;
                    if (isAllMelds(newCounts)) return true;
                }
                
                const [suit, rank] = key.split('_');
                if (suit !== 'honors' && parseInt(rank) <= 7) {
                    const key1 = key;
                    const key2 = `${suit}_${parseInt(rank) + 1}`;
                    const key3 = `${suit}_${parseInt(rank) + 2}`;
                    
                    if (counts[key1] >= 1 && counts[key2] >= 1 && counts[key3] >= 1) {
                        const newCounts = { ...counts };
                        newCounts[key1] -= 1;
                        newCounts[key2] -= 1;
                        newCounts[key3] -= 1;
                        if (isAllMelds(newCounts)) return true;
                    }
                }
                
                break;
            }
            
            return false;
        }

        // ç¬¦è¨ˆç®—ï¼ˆäº’æ›æ€§ã®ãŸã‚ï¼‰
        function calculateFu(hand, yaku, isRon = false, winTile = null) {
            if (!yaku || yaku.length === 0) return 0;
            
            // ä¸ƒå¯¾å­ã¯25ç¬¦å›ºå®š
            if (yaku.some(y => y.name === 'ä¸ƒå¯¾å­')) {
                return 25;
            }
            
            // ãƒ”ãƒ³ãƒ•ã®å ´åˆ
            if (yaku.some(y => y.name === 'ãƒ”ãƒ³ãƒ•')) {
                return isRon ? 30 : 20; // ãƒ­ãƒ³ãªã‚‰30ç¬¦ã€ãƒ„ãƒ¢ãªã‚‰20ç¬¦
            }
            
            let fu = 20; // åŸºæœ¬ç¬¦
            
            // å‰¯éœ²ãƒšãƒŠãƒ«ãƒ†ã‚£ï¼ˆé–€å‰ã§ãªã„å ´åˆï¼‰
            if (melds.length > 0) {
                fu = 30; // å‰¯éœ²ã‚ã‚Šã¯30ç¬¦åŸºæœ¬
            }
            
            // å’Œäº†æ–¹æ³•ã«ã‚ˆã‚‹ç¬¦
            if (!isRon) {
                fu += 2; // ãƒ„ãƒ¢å’Œäº†
            }
            
            // é›€é ­ã«ã‚ˆã‚‹ç¬¦
            const counts = getTileCounts(hand);
            
            // å‰¯éœ²ã‹ã‚‰ã‚‚ã‚«ã‚¦ãƒ³ãƒˆè¿½åŠ 
            melds.forEach(meld => {
                if (meld.type === 'pon' || meld.type === 'kan' || meld.type === 'ankan') {
                    const key = meld.tiles[0];
                    counts[key] = (counts[key] || 0) + meld.tiles.length;
                }
            });
            
            // å½¹ç‰Œé›€é ­
            for (const [key, count] of Object.entries(counts)) {
                if (count === 2) {
                    if (key === `honors_${gameSettings.gameWind}`) fu += 2; // å ´é¢¨é›€é ­
                    if (key === `honors_${gameSettings.playerWind}`) fu += 2; // è‡ªé¢¨é›€é ­
                    if (['honors_haku', 'honors_hatsu', 'honors_chun'].includes(key)) fu += 2; // ä¸‰å…ƒç‰Œé›€é ­
                }
            }
            
            // é¢å­ã«ã‚ˆã‚‹ç¬¦
            // æ‰‹ç‰Œã®åˆ»å­
            for (const [key, count] of Object.entries(getTileCounts(hand))) {
                if (count >= 3) {
                    const [suit, rank] = key.split('_');
                    const isTerminal = (suit !== 'honors' && (rank === '1' || rank === '9')) || suit === 'honors';
                    fu += isTerminal ? 8 : 4; // å¹ºä¹ç‰Œåˆ»å­8ç¬¦ã€ä¸­å¼µç‰Œåˆ»å­4ç¬¦
                }
            }
            
            // å‰¯éœ²ã®é¢å­
            melds.forEach(meld => {
                if (meld.type === 'pon') {
                    const [suit, rank] = meld.tiles[0].split('_');
                    const isTerminal = (suit !== 'honors' && (rank === '1' || rank === '9')) || suit === 'honors';
                    fu += isTerminal ? 4 : 2; // å‰¯éœ²åˆ»å­ã¯åŠåˆ†
                } else if (meld.type === 'kan') {
                    const [suit, rank] = meld.tiles[0].split('_');
                    const isTerminal = (suit !== 'honors' && (rank === '1' || rank === '9')) || suit === 'honors';
                    fu += isTerminal ? 16 : 8; // æ˜æ§“
                } else if (meld.type === 'ankan') {
                    const [suit, rank] = meld.tiles[0].split('_');
                    const isTerminal = (suit !== 'honors' && (rank === '1' || rank === '9')) || suit === 'honors';
                    fu += isTerminal ? 32 : 16; // æš—æ§“
                }
            });
            
            // å¾…ã¡ã«ã‚ˆã‚‹ç¬¦ï¼ˆç°¡æ˜“ç‰ˆï¼‰
            if (winTile) {
                // å˜é¨å¾…ã¡ã€åµŒå¼µå¾…ã¡ã€è¾ºå¼µå¾…ã¡ã®å ´åˆ+2ç¬¦
                // ã“ã“ã§ã¯ç°¡æ˜“çš„ã«å®Ÿè£…
            }
            
            // ç¬¦ã¯10ã®ä½ã§åˆ‡ã‚Šä¸Šã’
            return Math.ceil(fu / 10) * 10;
        }

        // ç‚¹æ•°è¨ˆç®—ï¼ˆè©³ç´°ç‰ˆï¼‰
        function calculateDetailedPoints(han, fu, isParent = false) {
            if (han >= 13) {
                // å½¹æº€
                return {
                    fu: fu,
                    han: han,
                    basePoints: isParent ? 48000 : 32000,
                    ronPoints: isParent ? 48000 : 32000,
                    tsumoPoints: isParent ? '16000ã‚ªãƒ¼ãƒ«' : '16000/8000',
                    category: 'å½¹æº€'
                };
            }
            
            if (han >= 11) {
                // ä¸‰å€æº€
                return {
                    fu: fu,
                    han: han,
                    basePoints: isParent ? 36000 : 24000,
                    ronPoints: isParent ? 36000 : 24000,
                    tsumoPoints: isParent ? '12000ã‚ªãƒ¼ãƒ«' : '12000/6000',
                    category: 'ä¸‰å€æº€'
                };
            }
            
            if (han >= 8) {
                // å€æº€
                return {
                    fu: fu,
                    han: han,
                    basePoints: isParent ? 24000 : 16000,
                    ronPoints: isParent ? 24000 : 16000,
                    tsumoPoints: isParent ? '8000ã‚ªãƒ¼ãƒ«' : '8000/4000',
                    category: 'å€æº€'
                };
            }
            
            if (han >= 6) {
                // è·³æº€
                return {
                    fu: fu,
                    han: han,
                    basePoints: isParent ? 18000 : 12000,
                    ronPoints: isParent ? 18000 : 12000,
                    tsumoPoints: isParent ? '6000ã‚ªãƒ¼ãƒ«' : '6000/3000',
                    category: 'è·³æº€'
                };
            }
            
            if (han >= 5) {
                // æº€è²«
                return {
                    fu: fu,
                    han: han,
                    basePoints: isParent ? 12000 : 8000,
                    ronPoints: isParent ? 12000 : 8000,
                    tsumoPoints: isParent ? '4000ã‚ªãƒ¼ãƒ«' : '4000/2000',
                    category: 'æº€è²«'
                };
            }
            
            // é€šå¸¸è¨ˆç®—
            let basePoints = fu * Math.pow(2, han + 2);
            if (isParent) {
                basePoints = Math.ceil(basePoints * 1.5 / 100) * 100;
            } else {
                basePoints = Math.ceil(basePoints / 100) * 100;
            }
            
            const ronPoints = isParent ? basePoints * 6 : basePoints * 4;
            const tsumoChild = Math.ceil(basePoints / 100) * 100;
            const tsumoParent = Math.ceil(basePoints * 2 / 100) * 100;
            
            return {
                fu: fu,
                han: han,
                basePoints: basePoints,
                ronPoints: ronPoints,
                tsumoPoints: isParent ? `${tsumoChild}ã‚ªãƒ¼ãƒ«` : `${tsumoParent}/${tsumoChild}`,
                category: `${fu}ç¬¦${han}ç¿»`
            };
        }

        // ç‚¹æ•°è¨ˆç®—ï¼ˆç°¡æ˜“ç‰ˆãƒ»å¾Œæ–¹äº’æ›ï¼‰
        function calculatePoints(han) {
            if (han >= 13) return '8000ç‚¹ï¼ˆå½¹æº€ï¼‰';
            if (han >= 11) return '6000ç‚¹ï¼ˆä¸‰å€æº€ï¼‰';
            if (han >= 8) return '4000ç‚¹ï¼ˆå€æº€ï¼‰';
            if (han >= 6) return '3000ç‚¹ï¼ˆè·³æº€ï¼‰';
            if (han >= 5) return '2000ç‚¹ï¼ˆæº€è²«ï¼‰';
            if (han >= 1) return `${Math.min(2000, 30 * Math.pow(2, han + 2))}ç‚¹`;
            return '0ç‚¹ï¼ˆå½¹ãªã—ï¼‰';
        }

        // æ‰‹ç‰Œæ§‹æˆåˆ†æ
        function analyzeHandComposition(hand) {
            const suitCounts = { man: 0, pin: 0, sou: 0, honors: 0 };
            const rankDistribution = {};
            
            hand.forEach(tile => {
                suitCounts[tile.suit]++;
                
                if (tile.suit !== 'honors') {
                    const key = `${tile.suit}_${tile.rank}`;
                    rankDistribution[key] = (rankDistribution[key] || 0) + 1;
                } else {
                    const key = `honors_${tile.type}`;
                    rankDistribution[key] = (rankDistribution[key] || 0) + 1;
                }
            });
            
            return {
                ã‚¹ãƒ¼ãƒˆåˆ†å¸ƒ: suitCounts,
                ç‰¹å¾´: getHandFeatures(hand),
                å½¢çŠ¶: getHandShape(hand)
            };
        }

        // æ‰‹ç‰Œã®ç‰¹å¾´ã‚’å–å¾—
        function getHandFeatures(hand) {
            const features = [];
            
            if (checkChiitoi(hand)) features.push('ä¸ƒå¯¾å­å½¢');
            if (checkKokushi(hand)) features.push('å›½å£«ç„¡åŒå½¢');
            if (checkTanyao(hand)) features.push('ã‚¿ãƒ³ãƒ¤ã‚ªå½¢');
            if (hand.every(tile => tile.suit !== 'honors')) features.push('æ•°ç‰Œã®ã¿');
            if (hand.some(tile => tile.suit === 'honors')) features.push('å­—ç‰Œå«ã¿');
            
            const suits = new Set(hand.map(tile => tile.suit));
            if (suits.size === 1) features.push('ä¸€è‰²');
            if (suits.size === 2 && suits.has('honors')) features.push('æ··ä¸€è‰²å€™è£œ');
            
            return features.length > 0 ? features : ['é€šå¸¸å½¢'];
        }

        // æ‰‹ç‰Œå½¢çŠ¶ã‚’å–å¾—
        function getHandShape(hand) {
            if (hand.length !== 14) return 'ä¸å®Œå…¨';
            
            const counts = getTileCounts(hand);
            const values = Object.values(counts);
            
            const pairs = values.filter(count => count === 2).length;
            const triplets = values.filter(count => count === 3).length;
            const quads = values.filter(count => count === 4).length;
            
            if (pairs === 7) return 'ä¸ƒå¯¾å­';
            if (quads > 0) return `æ§“å­${quads}å€‹å«ã¿`;
            
            // è©³ç´°ãªæ§‹é€ åˆ†æ
            const structure = analyzeHandStructure(hand);
            if (structure && structure.isComplete) {
                const sequenceCount = structure.sequences.length;
                const tripletCount = structure.triplets.length;
                
                if (sequenceCount === 4 && tripletCount === 0) {
                    return 'å››é †å­ä¸€é›€é ­';
                } else if (sequenceCount === 0 && tripletCount === 4) {
                    return 'å››åˆ»å­ä¸€é›€é ­';
                } else if (sequenceCount + tripletCount === 4) {
                    return `${sequenceCount}é †å­${tripletCount}åˆ»å­ä¸€é›€é ­`;
                }
            }
            
            if (triplets === 4 && pairs === 1) return 'å››é¢å­ä¸€é›€é ­';
            
            return 'æ§‹é€ åˆ†æä¸­';
        }

        // ãƒ­ã‚°å‡ºåŠ›
        function logDebug(message) {
            console.log(`[DEBUG] ${new Date().toLocaleTimeString()}: ${message}`);
        }

        // è‡ªå‹•å®Œæˆï¼ˆãƒ†ã‚¹ãƒˆç”¨ï¼‰
        function autoComplete() {
            if (currentHand.length === 0) {
                dealNewHand();
            }

            // ãƒ†ãƒ³ãƒ‘ã‚¤ã¾ã§è‡ªå‹•èª¿æ•´
            let attempts = 0;
            while (attempts < 100) {
                const handState = analyzeHandState(currentHand);
                if (handState.shanten <= 0) break;

                // ãƒ©ãƒ³ãƒ€ãƒ ã«ç‰Œã‚’äº¤æ›
                if (currentHand.length > 0) {
                    const randomIndex = Math.floor(Math.random() * currentHand.length);
                    currentHand.splice(randomIndex, 1);
                }

                const randomTile = allTileTypes[Math.floor(Math.random() * allTileTypes.length)];
                currentHand.push({ ...randomTile });
                attempts++;
            }

            updateHandDisplay();
            calculateStatus();
            logDebug(`è‡ªå‹•å®Œæˆå®Ÿè¡Œ: ${attempts}å›è©¦è¡Œ`);
        }

        // ===== CPUéº»é›€ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ é–‹ç™ºç”¨é–¢æ•° =====

        // æœ€é©æ‰“ç‰Œã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
        function simulateOptimalPlay() {
            if (currentHand.length === 0) {
                dealNewHand();
            }

            const originalHand = [...currentHand];
            logDebug('=== æœ€é©æ‰“ç‰Œã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆé–‹å§‹ ===');

            // ç¾åœ¨ã®æ‰‹ç‰Œã‚’14æšã«ã™ã‚‹
            while (currentHand.length < 14) {
                drawTile();
            }

            // å„ç‰Œã‚’æ¨ã¦ãŸå ´åˆã®å‘è´æ•°å¤‰åŒ–ã‚’åˆ†æ
            const discardAnalysis = [];
            
            for (let i = 0; i < currentHand.length; i++) {
                const testHand = [...currentHand];
                const discardedTile = testHand.splice(i, 1)[0];
                
                const handState = analyzeHandState(testHand);
                const improvement = calculateHandImprovement(testHand);
                
                discardAnalysis.push({
                    discardTile: discardedTile,
                    shanten: handState.shanten,
                    waitingTiles: handState.waitingTiles?.length || 0,
                    improvement: improvement,
                    efficiency: calculateEfficiency(testHand)
                });
            }

            // æœ€é©ãªæ¨ã¦ç‰Œã‚’æ±ºå®š
            const bestDiscard = findBestDiscard(discardAnalysis);
            
            // çµæœã‚’è¡¨ç¤º
            displayDiscardAnalysis(discardAnalysis, bestDiscard);
            
            logDebug(`æœ€é©æ¨ã¦ç‰Œ: ${getTileDisplayName(bestDiscard.discardTile)}`);
        }

        // æœ€é©æ¨ã¦ç‰Œåˆ†æ
        function analyzeBestDiscard() {
            if (currentHand.length !== 14) {
                alert('æ‰‹ç‰Œã‚’14æšã«ã—ã¦ãã ã•ã„');
                return;
            }

            const analysis = performDetailedDiscardAnalysis(currentHand);
            displayDetailedAnalysis(analysis);
        }

        // è©³ç´°ãªæ¨ã¦ç‰Œåˆ†æ
        function performDetailedDiscardAnalysis(hand) {
            const analysis = {
                totalTiles: hand.length,
                uniqueTiles: new Set(hand.map(getTileKey)).size,
                suitDistribution: getSuitDistribution(hand),
                discardOptions: []
            };

            // å„ç‰Œã‚’æ¨ã¦ãŸå ´åˆã®è©³ç´°åˆ†æ
            for (let i = 0; i < hand.length; i++) {
                const testHand = [...hand];
                const discardTile = testHand.splice(i, 1)[0];
                
                const option = {
                    tile: discardTile,
                    resultingShanten: calculateShanten(testHand),
                    waitingTiles: getWaitingTiles(testHand),
                    futureProspects: calculateFutureProspects(testHand),
                    riskAssessment: assessDiscardRisk(discardTile),
                    score: 0 // ç·åˆã‚¹ã‚³ã‚¢
                };

                // ç·åˆã‚¹ã‚³ã‚¢è¨ˆç®—
                option.score = calculateDiscardScore(option);
                analysis.discardOptions.push(option);
            }

            // ã‚¹ã‚³ã‚¢é †ã«ã‚½ãƒ¼ãƒˆ
            analysis.discardOptions.sort((a, b) => b.score - a.score);
            
            return analysis;
        }

        // æ‰‹ç‰Œæ”¹å–„åº¦è¨ˆç®—
        function calculateHandImprovement(hand) {
            const shanten = calculateShanten(hand);
            const waitingCount = getWaitingTiles(hand).length;
            
            // å‘è´æ•°ãŒä½ã„ã»ã©ã€å¾…ã¡ç‰ŒãŒå¤šã„ã»ã©è‰¯ã„
            return (8 - shanten) * 10 + waitingCount;
        }

        // åŠ¹ç‡æ€§è¨ˆç®—
        function calculateEfficiency(hand) {
            const counts = getTileCounts(hand);
            let efficiency = 0;

            // å¯¾å­ã®ä¾¡å€¤
            Object.values(counts).forEach(count => {
                if (count === 2) efficiency += 2; // å¯¾å­
                if (count >= 3) efficiency += 5; // åˆ»å­
            });

            // é †å­ã®å¯èƒ½æ€§
            ['man', 'pin', 'sou'].forEach(suit => {
                for (let rank = 1; rank <= 7; rank++) {
                    const key1 = `${suit}_${rank}`;
                    const key2 = `${suit}_${rank + 1}`;
                    const key3 = `${suit}_${rank + 2}`;
                    
                    if (counts[key1] && counts[key2] && counts[key3]) {
                        efficiency += 3; // å®Œæˆã—ãŸé †å­
                    } else if ((counts[key1] && counts[key2]) || 
                              (counts[key2] && counts[key3]) || 
                              (counts[key1] && counts[key3])) {
                        efficiency += 1; // é †å­ã®å¯èƒ½æ€§
                    }
                }
            });

            return efficiency;
        }

        // é³´ãåˆ¤å®šåˆ†æ
        function analyzeMeldPossibilities(hand) {
            const counts = getTileCounts(hand);
            const analysis = {
                pon: [],
                chi: [],
                kan: [],
                ankan: []
            };

            // ãƒãƒ³åˆ¤å®š (åŒã˜ç‰ŒãŒ2æšä»¥ä¸Š)
            for (const [tileKey, count] of Object.entries(counts)) {
                if (count >= 2) {
                    const [suit, rank] = tileKey.split('_');
                    let tileObj;
                    if (suit === 'honors') {
                        tileObj = { suit, type: rank };
                    } else {
                        tileObj = { suit, rank: parseInt(rank) };
                    }
                    const tileName = getTileDisplayName(tileObj);
                    analysis.pon.push({
                        tile: tileName,
                        count: count,
                        key: tileKey
                    });
                }
            }

            // ãƒãƒ¼åˆ¤å®š (é †å­ã®å¯èƒ½æ€§)
            ['man', 'pin', 'sou'].forEach(suit => {
                for (let rank = 1; rank <= 7; rank++) {
                    const patterns = [
                        // AB_ãƒ‘ã‚¿ãƒ¼ãƒ³ (Cã‚’å–ã‚‹)
                        { keys: [`${suit}_${rank}`, `${suit}_${rank + 1}`], need: `${suit}_${rank + 2}` },
                        // A_Cãƒ‘ã‚¿ãƒ¼ãƒ³ (Bã‚’å–ã‚‹)  
                        { keys: [`${suit}_${rank}`, `${suit}_${rank + 2}`], need: `${suit}_${rank + 1}` },
                        // _BCãƒ‘ã‚¿ãƒ¼ãƒ³ (Aã‚’å–ã‚‹)
                        { keys: [`${suit}_${rank + 1}`, `${suit}_${rank + 2}`], need: `${suit}_${rank}` }
                    ];

                    patterns.forEach(pattern => {
                        if (pattern.keys.every(key => counts[key] >= 1)) {
                            const [needSuit, needRank] = pattern.need.split('_');
                            const needTile = getTileDisplayName({
                                suit: needSuit,
                                rank: parseInt(needRank)
                            });
                            const haveTiles = pattern.keys.map(key => {
                                const [s, r] = key.split('_');
                                return getTileDisplayName({ suit: s, rank: parseInt(r) });
                            }).join('');
                            
                            analysis.chi.push({
                                sequence: `${haveTiles}+${needTile}`,
                                have: haveTiles,
                                need: needTile,
                                needKey: pattern.need
                            });
                        }
                    });
                }
            });

            // ã‚«ãƒ³åˆ¤å®š (åŒã˜ç‰ŒãŒ3æš)
            for (const [tileKey, count] of Object.entries(counts)) {
                if (count >= 3) {
                    const [suit, rank] = tileKey.split('_');
                    let tileObj;
                    if (suit === 'honors') {
                        tileObj = { suit, type: rank };
                    } else {
                        tileObj = { suit, rank: parseInt(rank) };
                    }
                    const tileName = getTileDisplayName(tileObj);
                    analysis.kan.push({
                        tile: tileName,
                        count: count,
                        key: tileKey
                    });
                }
            }

            // ã‚¢ãƒ³ã‚«ãƒ³åˆ¤å®š (åŒã˜ç‰ŒãŒ4æš)
            for (const [tileKey, count] of Object.entries(counts)) {
                if (count >= 4) {
                    const [suit, rank] = tileKey.split('_');
                    let tileObj;
                    if (suit === 'honors') {
                        tileObj = { suit, type: rank };
                    } else {
                        tileObj = { suit, rank: parseInt(rank) };
                    }
                    const tileName = getTileDisplayName(tileObj);
                    analysis.ankan.push({
                        tile: tileName,
                        count: count,
                        key: tileKey
                    });
                }
            }

            return analysis;
        }

        // é³´ãåˆ¤å®šè¡¨ç¤ºæ›´æ–°
        function updateMeldAnalysis() {
            const analysis = analyzeMeldPossibilities(currentHand);
            const container = document.getElementById('meldAnalysis');
            
            let html = '';
            
            // ãƒãƒ³
            html += '<div class="meld-option pon"><strong>ãƒãƒ³å¯èƒ½:</strong><br>';
            if (analysis.pon.length > 0) {
                analysis.pon.forEach(p => {
                    html += `${p.tile} (${p.count}æš)<br>`;
                });
            } else {
                html += 'ãªã—<br>';
            }
            html += '</div>';

            // ãƒãƒ¼  
            html += '<div class="meld-option chi"><strong>ãƒãƒ¼å¯èƒ½:</strong><br>';
            if (analysis.chi.length > 0) {
                analysis.chi.forEach(c => {
                    html += `${c.have} + ${c.need}<br>`;
                });
            } else {
                html += 'ãªã—<br>';
            }
            html += '</div>';

            // ã‚«ãƒ³
            html += '<div class="meld-option kan"><strong>ã‚«ãƒ³å¯èƒ½:</strong><br>';
            if (analysis.kan.length > 0) {
                analysis.kan.forEach(k => {
                    html += `${k.tile} (${k.count}æš)<br>`;
                });
            } else {
                html += 'ãªã—<br>';
            }
            html += '</div>';

            // ã‚¢ãƒ³ã‚«ãƒ³
            html += '<div class="meld-option ankan"><strong>ã‚¢ãƒ³ã‚«ãƒ³å¯èƒ½:</strong><br>';
            if (analysis.ankan.length > 0) {
                analysis.ankan.forEach(a => {
                    html += `${a.tile} (${a.count}æš)<br>`;
                });
            } else {
                html += 'ãªã—<br>';
            }
            html += '</div>';

            container.innerHTML = html;
        }

        // å½“ãŸã‚Šç‰Œåˆ†ææ›´æ–°
        function updateWinningTilesAnalysis() {
            const container = document.getElementById('winningTilesAnalysis');
            
            // å‰¯éœ²ã‚’è€ƒæ…®ã—ãŸå®Ÿè³ªæ‰‹ç‰Œæšæ•°ã‚’ãƒã‚§ãƒƒã‚¯
            const totalTiles = currentHand.length + melds.reduce((sum, meld) => sum + meld.tiles.length, 0);
            const expectedTiles = totalTiles === 13 ? 13 : (totalTiles === 14 ? 14 : 0);
            
            if (expectedTiles === 0) {
                container.innerHTML = '<div style="color: #999;">æ‰‹ç‰Œ+å‰¯éœ²=13æšã¾ãŸã¯14æšã§ãƒ†ãƒ³ãƒ‘ã‚¤åˆ¤å®š</div>';
                return;
            }
            
            // ãƒ†ãƒ³ãƒ‘ã‚¤åˆ¤å®šï¼š13æšç›¸å½“ã®å ´åˆ
            let waitingTiles = [];
            if (expectedTiles === 13) {
                waitingTiles = getCustomWaitingTiles(currentHand);
            } else if (expectedTiles === 14) {
                // 14æšã®å ´åˆã€1æšæ¨ã¦ã¦ãƒ†ãƒ³ãƒ‘ã‚¤ã«ãªã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                for (let i = 0; i < currentHand.length; i++) {
                    const testHand = [...currentHand];
                    testHand.splice(i, 1);
                    const testWaiting = getCustomWaitingTiles(testHand);
                    waitingTiles.push(...testWaiting);
                }
                // é‡è¤‡é™¤å»
                waitingTiles = waitingTiles.filter((tile, index, self) => 
                    index === self.findIndex(t => getTileKey(t) === getTileKey(tile))
                );
            }
            
            if (waitingTiles.length === 0) {
                container.innerHTML = '<div style="color: #999;">ãƒ†ãƒ³ãƒ‘ã‚¤ã—ã¦ã„ã¾ã›ã‚“</div>';
                return;
            }
            
            let html = '<div class="winning-tile-header">ğŸ¯ å½“ãŸã‚Šç‰Œåˆ†æ</div>';
            
            // å„å½“ãŸã‚Šç‰Œã«ã¤ã„ã¦è©³ç´°åˆ†æ
            waitingTiles.forEach(tile => {
                const testHand = [...currentHand, tile];
                const yaku = calculateYaku(testHand);
                const totalHan = yaku.reduce((sum, y) => sum + y.han, 0);
                
                if (totalHan > 0) {
                    // ãƒ­ãƒ³ã¨ãƒ„ãƒ¢ã®ä¸¡æ–¹ã‚’è¨ˆç®—
                    const ronFuDetails = calculateDetailedFu(testHand, yaku, true, tile);
                    const tsumoFuDetails = calculateDetailedFu(testHand, yaku, false, tile);
                    
                    const ronPoints = calculateDetailedPoints(totalHan, ronFuDetails.total, gameSettings.playerWind === 'east');
                    const tsumoPoints = calculateDetailedPoints(totalHan, tsumoFuDetails.total, gameSettings.playerWind === 'east');
                    
                    const waitType = analyzeWaitPattern(currentHand, tile);
                    
                    html += `
                        <div class="winning-tile-item">
                            <div class="winning-tile-header">
                                ${getTileDisplayName(tile)} (${waitType.name})
                            </div>
                            <div class="winning-tile-details">
                                <div>å½¹: ${yaku.map(y => y.name).join(', ')} (${totalHan}ç¿»)</div>
                                <div>ãƒ­ãƒ³: ${ronFuDetails.total}ç¬¦ â†’ ${ronPoints.ronPoints}ç‚¹</div>
                                <div>ãƒ„ãƒ¢: ${tsumoFuDetails.total}ç¬¦ â†’ ${tsumoPoints.tsumoPoints}</div>
                            </div>
                        </div>
                    `;
                } else {
                    // å½¹ãªã—ã®å ´åˆ
                    html += `
                        <div class="winning-tile-item" style="border-left-color: #e74c3c;">
                            <div class="winning-tile-header">
                                ${getTileDisplayName(tile)} (å½¹ãªã—)
                            </div>
                            <div class="winning-tile-details">
                                <div style="color: #e74c3c;">ä¸ŠãŒã‚Œã¾ã›ã‚“ï¼ˆå½¹ãªã—ï¼‰</div>
                            </div>
                        </div>
                    `;
                }
            });
            
            // å½“ãŸã‚Šç‰Œçµ±è¨ˆ
            const validWins = waitingTiles.filter(tile => {
                const testHand = [...currentHand, tile];
                const yaku = calculateYaku(testHand);
                return yaku.reduce((sum, y) => sum + y.han, 0) > 0;
            });
            
            html += `
                <div class="winning-tile-item" style="border-left-color: #3498db;">
                    <div class="winning-tile-header">ğŸ“Š çµ±è¨ˆ</div>
                    <div class="winning-tile-details">
                        <div>å¾…ã¡: ${waitingTiles.length}ç¨®é¡</div>
                        <div>æœ‰åŠ¹: ${validWins.length}ç¨®é¡</div>
                        <div>ç„¡åŠ¹: ${waitingTiles.length - validWins.length}ç¨®é¡</div>
                    </div>
                </div>
            `;
            
            container.innerHTML = html;
        }

        // å‰¯éœ²ã‚’è€ƒæ…®ã—ãŸå¾…ã¡ç‰Œè¨ˆç®—
        function getCustomWaitingTiles(hand) {
            if (!hand || hand.length === 0) return [];
            
            const waitingTiles = [];
            
            for (const testTile of allTileTypes) {
                const testHand = [...hand, testTile];
                if (isCustomWinningShape(testHand)) {
                    waitingTiles.push(testTile);
                }
            }
            
            return waitingTiles;
        }

        // å‰¯éœ²ã‚’è€ƒæ…®ã—ãŸå’Œäº†å½¢åˆ¤å®š
        function isCustomWinningShape(hand) {
            if (!hand || hand.length === 0) return false;
            
            // å‰¯éœ²ã‚’è€ƒæ…®ã—ãŸç·ç‰Œæ•°ãƒã‚§ãƒƒã‚¯
            const totalTiles = hand.length + melds.reduce((sum, meld) => sum + meld.tiles.length, 0);
            if (totalTiles !== 14) return false;
            
            // æ‰‹ç‰Œã®å’Œäº†å½¢ãƒã‚§ãƒƒã‚¯
            const counts = getTileCounts(hand);
            
            // å‰¯éœ²ã®é¢å­ã¯æ—¢ã«å®Œæˆã—ã¦ã„ã‚‹ã¨ã—ã¦é™¤å¤–ã—ã€æ‰‹ç‰Œã®ã¿ã§æ®‹ã‚Šã®é¢å­+é›€é ­ã‚’ä½œã‚Œã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            const requiredMelds = 4 - melds.length; // å¿…è¦ãªé¢å­æ•°
            const requiredPairs = 1; // é›€é ­ã¯å¸¸ã«1ã¤
            
            return checkCustomMeldsRecursive(counts, 0, requiredMelds, requiredPairs);
        }

        // å‰¯éœ²ã‚’è€ƒæ…®ã—ãŸé¢å­åˆ¤å®šï¼ˆå†å¸°ï¼‰
        function checkCustomMeldsRecursive(counts, pairCount, requiredMelds, requiredPairs) {
            const entries = Object.entries(counts).filter(([_, count]) => count > 0);
            
            if (entries.length === 0) {
                return pairCount === requiredPairs && requiredMelds === 0;
            }
            
            for (const [tileKey, count] of entries) {
                // é›€é ­ã‚’ä½œã‚‹
                if (count >= 2 && pairCount < requiredPairs) {
                    const newCounts = { ...counts };
                    newCounts[tileKey] -= 2;
                    if (checkCustomMeldsRecursive(newCounts, pairCount + 1, requiredMelds, requiredPairs)) {
                        return true;
                    }
                }
                
                // åˆ»å­ã‚’ä½œã‚‹
                if (count >= 3 && requiredMelds > 0) {
                    const newCounts = { ...counts };
                    newCounts[tileKey] -= 3;
                    if (checkCustomMeldsRecursive(newCounts, pairCount, requiredMelds - 1, requiredPairs)) {
                        return true;
                    }
                }
                
                // é †å­ã‚’ä½œã‚‹
                const [suit, rank] = tileKey.split('_');
                if (suit !== 'honors' && parseInt(rank) <= 7 && requiredMelds > 0) {
                    const key1 = `${suit}_${parseInt(rank)}`;
                    const key2 = `${suit}_${parseInt(rank) + 1}`;
                    const key3 = `${suit}_${parseInt(rank) + 2}`;
                    
                    if (counts[key1] >= 1 && counts[key2] >= 1 && counts[key3] >= 1) {
                        const newCounts = { ...counts };
                        newCounts[key1] -= 1;
                        newCounts[key2] -= 1;
                        newCounts[key3] -= 1;
                        if (checkCustomMeldsRecursive(newCounts, pairCount, requiredMelds - 1, requiredPairs)) {
                            return true;
                        }
                    }
                }
                
                break; // æœ€åˆã®ç‰Œã®ã¿è©¦è¡Œã—ã¦åŠ¹ç‡åŒ–
            }
            
            return false;
        }

        // å‰¯éœ²ãƒ‡ãƒ¼ã‚¿ç®¡ç†
        let melds = []; // æ™’ã—ãŸé¢å­ã‚’ä¿å­˜
        
        // ä¸ŠãŒã‚Šç‰Œç®¡ç†
        let winTile = null; // ä¸ŠãŒã‚Šç‰Œ
        let isRon = false; // ãƒ­ãƒ³å’Œäº†ã‹ã©ã†ã‹

        // ä¸ŠãŒã‚Šç‰Œé¸æŠ
        function selectWinTile() {
            if (currentHand.length === 0) {
                alert('æ‰‹ç‰ŒãŒã‚ã‚Šã¾ã›ã‚“');
                return;
            }

            const tiles = [...currentHand];
            const options = tiles.map((tile, index) => `${index + 1}: ${getTileDisplayName(tile)}`).join('\n');
            const input = prompt(`ä¸ŠãŒã‚Šç‰Œã‚’é¸æŠã—ã¦ãã ã•ã„:\n${options}\n\nç•ªå·ã‚’å…¥åŠ›:`);
            
            if (input) {
                const index = parseInt(input) - 1;
                if (index >= 0 && index < tiles.length) {
                    winTile = tiles[index];
                    
                    // ãƒ­ãƒ³/ãƒ„ãƒ¢ã®é¸æŠ
                    const ronChoice = confirm('ãƒ­ãƒ³å’Œäº†ã§ã™ã‹ï¼Ÿ\nOK: ãƒ­ãƒ³, ã‚­ãƒ£ãƒ³ã‚»ãƒ«: ãƒ„ãƒ¢');
                    isRon = ronChoice;
                    
                    updateWinTileDisplay();
                    calculateStatus();
                } else {
                    alert('ç„¡åŠ¹ãªé¸æŠã§ã™');
                }
            }
        }

        // ä¸ŠãŒã‚Šç‰Œã‚¯ãƒªã‚¢
        function clearWinTile() {
            winTile = null;
            isRon = false;
            updateWinTileDisplay();
            calculateStatus();
        }

        // ä¸ŠãŒã‚Šç‰Œè¡¨ç¤ºæ›´æ–°
        function updateWinTileDisplay() {
            const display = document.getElementById('winTileDisplay');
            if (winTile) {
                const method = isRon ? 'ãƒ­ãƒ³' : 'ãƒ„ãƒ¢';
                display.textContent = `ä¸ŠãŒã‚Šç‰Œ: ${getTileDisplayName(winTile)} (${method})`;
            } else {
                display.textContent = 'ä¸ŠãŒã‚Šç‰Œ: ãªã—';
            }
        }

        // é³´ãå®Ÿè¡Œé–¢æ•°
        function executePon() {
            const analysis = analyzeMeldPossibilities(currentHand);
            if (analysis.pon.length === 0) {
                alert('ãƒãƒ³ã§ãã‚‹ç‰ŒãŒã‚ã‚Šã¾ã›ã‚“');
                return;
            }

            // é¸æŠè‚¢ã‚’è¡¨ç¤º
            let choice = '';
            if (analysis.pon.length === 1) {
                choice = analysis.pon[0].tile;
            } else {
                const options = analysis.pon.map((p, i) => `${i + 1}: ${p.tile} (${p.count}æš)`).join('\n');
                const input = prompt(`ãƒãƒ³ã™ã‚‹ç‰Œã‚’é¸æŠã—ã¦ãã ã•ã„:\n${options}\n\nç•ªå·ã‚’å…¥åŠ›:`);
                const index = parseInt(input) - 1;
                if (index >= 0 && index < analysis.pon.length) {
                    choice = analysis.pon[index].tile;
                } else {
                    alert('ç„¡åŠ¹ãªé¸æŠã§ã™');
                    return;
                }
            }

            // ãƒãƒ³å®Ÿè¡Œ
            if (choice) {
                executeMeld('pon', choice, analysis.pon.find(p => p.tile === choice));
            }
        }

        function executeChi() {
            const analysis = analyzeMeldPossibilities(currentHand);
            if (analysis.chi.length === 0) {
                alert('ãƒãƒ¼ã§ãã‚‹çµ„ã¿åˆã‚ã›ãŒã‚ã‚Šã¾ã›ã‚“');
                return;
            }

            // é¸æŠè‚¢ã‚’è¡¨ç¤º
            let choice = null;
            if (analysis.chi.length === 1) {
                choice = analysis.chi[0];
            } else {
                const options = analysis.chi.map((c, i) => `${i + 1}: ${c.sequence}`).join('\n');
                const input = prompt(`ãƒãƒ¼ã™ã‚‹çµ„ã¿åˆã‚ã›ã‚’é¸æŠã—ã¦ãã ã•ã„:\n${options}\n\nç•ªå·ã‚’å…¥åŠ›:`);
                const index = parseInt(input) - 1;
                if (index >= 0 && index < analysis.chi.length) {
                    choice = analysis.chi[index];
                } else {
                    alert('ç„¡åŠ¹ãªé¸æŠã§ã™');
                    return;
                }
            }

            // ãƒãƒ¼å®Ÿè¡Œ
            if (choice) {
                executeMeld('chi', choice.sequence, choice);
            }
        }

        function executeKan() {
            const analysis = analyzeMeldPossibilities(currentHand);
            if (analysis.kan.length === 0) {
                alert('ã‚«ãƒ³ã§ãã‚‹ç‰ŒãŒã‚ã‚Šã¾ã›ã‚“');
                return;
            }

            // é¸æŠè‚¢ã‚’è¡¨ç¤º
            let choice = '';
            if (analysis.kan.length === 1) {
                choice = analysis.kan[0].tile;
            } else {
                const options = analysis.kan.map((k, i) => `${i + 1}: ${k.tile} (${k.count}æš)`).join('\n');
                const input = prompt(`ã‚«ãƒ³ã™ã‚‹ç‰Œã‚’é¸æŠã—ã¦ãã ã•ã„:\n${options}\n\nç•ªå·ã‚’å…¥åŠ›:`);
                const index = parseInt(input) - 1;
                if (index >= 0 && index < analysis.kan.length) {
                    choice = analysis.kan[index].tile;
                } else {
                    alert('ç„¡åŠ¹ãªé¸æŠã§ã™');
                    return;
                }
            }

            // ã‚«ãƒ³å®Ÿè¡Œ
            if (choice) {
                executeMeld('kan', choice, analysis.kan.find(k => k.tile === choice));
            }
        }

        function executeAnkan() {
            const analysis = analyzeMeldPossibilities(currentHand);
            if (analysis.ankan.length === 0) {
                alert('ã‚¢ãƒ³ã‚«ãƒ³ã§ãã‚‹ç‰ŒãŒã‚ã‚Šã¾ã›ã‚“');
                return;
            }

            // é¸æŠè‚¢ã‚’è¡¨ç¤º
            let choice = '';
            if (analysis.ankan.length === 1) {
                choice = analysis.ankan[0].tile;
            } else {
                const options = analysis.ankan.map((a, i) => `${i + 1}: ${a.tile} (${a.count}æš)`).join('\n');
                const input = prompt(`ã‚¢ãƒ³ã‚«ãƒ³ã™ã‚‹ç‰Œã‚’é¸æŠã—ã¦ãã ã•ã„:\n${options}\n\nç•ªå·ã‚’å…¥åŠ›:`);
                const index = parseInt(input) - 1;
                if (index >= 0 && index < analysis.ankan.length) {
                    choice = analysis.ankan[index].tile;
                } else {
                    alert('ç„¡åŠ¹ãªé¸æŠã§ã™');
                    return;
                }
            }

            // ã‚¢ãƒ³ã‚«ãƒ³å®Ÿè¡Œ
            if (choice) {
                executeMeld('ankan', choice, analysis.ankan.find(a => a.tile === choice));
            }
        }

        // é³´ãå®Ÿè¡Œå‡¦ç†
        function executeMeld(type, displayName, data) {
            const counts = getTileCounts(currentHand);
            
            switch (type) {
                case 'pon':
                    // ãƒãƒ³: åŒã˜ç‰Œ3æšã‚’æ‰‹ç‰Œã‹ã‚‰å‰Šé™¤
                    removeTilesFromHand(data.key, 3);
                    melds.push({
                        type: 'pon',
                        tiles: [data.key, data.key, data.key],
                        display: displayName + displayName + displayName
                    });
                    break;
                    
                case 'chi':
                    // ãƒãƒ¼: é †å­3æšã‚’æ‰‹ç‰Œã‹ã‚‰å‰Šé™¤
                    // data.needKeyã‹ã‚‰é †å­ã®3æšã®ã‚­ãƒ¼ã‚’è¨ˆç®—
                    const [needSuit, needRank] = data.needKey.split('_');
                    const needRankNum = parseInt(needRank);
                    
                    // é †å­ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç‰¹å®š
                    let chiKeys = [];
                    if (counts[`${needSuit}_${needRankNum - 2}`] && counts[`${needSuit}_${needRankNum - 1}`]) {
                        // ABC ã® C ã‚’å–ã‚‹å ´åˆ
                        chiKeys = [`${needSuit}_${needRankNum - 2}`, `${needSuit}_${needRankNum - 1}`, data.needKey];
                    } else if (counts[`${needSuit}_${needRankNum - 1}`] && counts[`${needSuit}_${needRankNum + 1}`]) {
                        // ABC ã® B ã‚’å–ã‚‹å ´åˆ
                        chiKeys = [`${needSuit}_${needRankNum - 1}`, data.needKey, `${needSuit}_${needRankNum + 1}`];
                    } else if (counts[`${needSuit}_${needRankNum + 1}`] && counts[`${needSuit}_${needRankNum + 2}`]) {
                        // ABC ã® A ã‚’å–ã‚‹å ´åˆ
                        chiKeys = [data.needKey, `${needSuit}_${needRankNum + 1}`, `${needSuit}_${needRankNum + 2}`];
                    }
                    
                    // æ‰‹ç‰Œã‹ã‚‰å‰Šé™¤ï¼ˆå–å¾—ç‰Œä»¥å¤–ã®2æšï¼‰
                    chiKeys.forEach(key => {
                        if (key !== data.needKey) {
                            removeTilesFromHand(key, 1);
                        }
                    });
                    
                    melds.push({
                        type: 'chi',
                        tiles: chiKeys,
                        display: chiKeys.map(key => {
                            const [suit, rank] = key.split('_');
                            return getTileDisplayName({suit, rank: parseInt(rank)});
                        }).join('')
                    });
                    break;
                    
                case 'kan':
                    // ã‚«ãƒ³: åŒã˜ç‰Œ4æšã‚’æ‰‹ç‰Œã‹ã‚‰å‰Šé™¤
                    removeTilesFromHand(data.key, 4);
                    melds.push({
                        type: 'kan',
                        tiles: [data.key, data.key, data.key, data.key],
                        display: displayName + displayName + displayName + displayName
                    });
                    break;
                    
                case 'ankan':
                    // ã‚¢ãƒ³ã‚«ãƒ³: åŒã˜ç‰Œ4æšã‚’æ‰‹ç‰Œã‹ã‚‰å‰Šé™¤
                    removeTilesFromHand(data.key, 4);
                    melds.push({
                        type: 'ankan',
                        tiles: [data.key, data.key, data.key, data.key],
                        display: displayName + displayName + displayName + displayName
                    });
                    break;
            }
            
            // æ‰‹ç‰Œè¡¨ç¤ºæ›´æ–°
            updateHandDisplay();
            calculateStatus();
            updateMeldsDisplay();
            
            alert(`${type.toUpperCase()}ã‚’å®Ÿè¡Œã—ã¾ã—ãŸ: ${displayName}`);
        }

        // æ‰‹ç‰Œã‹ã‚‰æŒ‡å®šç‰Œã‚’å‰Šé™¤
        function removeTilesFromHand(tileKey, count) {
            const [suit, rank] = tileKey.split('_');
            
            let removed = 0;
            const newHand = [];
            
            for (const tile of currentHand) {
                if (removed < count && getTileKey(tile) === tileKey) {
                    removed++;
                    // ã“ã®ç‰Œã¯å‰Šé™¤ï¼ˆnewHandã«è¿½åŠ ã—ãªã„ï¼‰
                } else {
                    newHand.push(tile);
                }
            }
            
            currentHand = newHand;
            console.log(`å‰Šé™¤: ${tileKey} x${removed}, æ®‹ã‚Šæ‰‹ç‰Œæ•°: ${currentHand.length}`);
        }

        // å‰¯éœ²è¡¨ç¤ºæ›´æ–°
        function updateMeldsDisplay() {
            const container = document.getElementById('meldsDisplay');
            if (!container) return;
            
            if (melds.length === 0) {
                container.innerHTML = '<div style="color: #999;">å‰¯éœ²ãªã—</div>';
                return;
            }
            
            let html = '';
            melds.forEach((meld, index) => {
                const typeColor = {
                    'pon': '#e74c3c',
                    'chi': '#f39c12', 
                    'kan': '#9b59b6',
                    'ankan': '#27ae60'
                };
                
                html += `
                    <div class="meld-item" style="
                        margin-bottom: 8px;
                        padding: 6px 10px;
                        background: rgba(255,255,255,0.1);
                        border-radius: 4px;
                        border-left: 3px solid ${typeColor[meld.type]};
                    ">
                        <strong>${meld.type.toUpperCase()}:</strong> ${meld.display}
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        // æœ€é©ãªæ¨ã¦ç‰Œã‚’è¦‹ã¤ã‘ã‚‹
        function findBestDiscard(analysis) {
            return analysis.reduce((best, current) => {
                const bestScore = (8 - best.shanten) * 100 + best.waitingTiles * 10 + best.efficiency;
                const currentScore = (8 - current.shanten) * 100 + current.waitingTiles * 10 + current.efficiency;
                
                return currentScore > bestScore ? current : best;
            }, analysis[0]);
        }

        // ã‚¹ãƒ¼ãƒˆåˆ†å¸ƒå–å¾—
        function getSuitDistribution(hand) {
            const distribution = { man: 0, pin: 0, sou: 0, honors: 0 };
            hand.forEach(tile => {
                distribution[tile.suit]++;
            });
            return distribution;
        }

        // å°†æ¥æ€§è¨ˆç®—
        function calculateFutureProspects(hand) {
            const shanten = calculateShanten(hand);
            const waitingTiles = getWaitingTiles(hand);
            
            // å‘è´æ•°ãŒå°‘ãªãã€å¾…ã¡ç‰ŒãŒå¤šã„ã»ã©å°†æ¥æ€§ãŒé«˜ã„
            return Math.max(0, (6 - shanten) * 20 + waitingTiles.length * 5);
        }

        // æ¨ã¦ç‰Œãƒªã‚¹ã‚¯è©•ä¾¡
        function assessDiscardRisk(tile) {
            // ç°¡æ˜“å®Ÿè£…ï¼šä¸­å¼µç‰Œã¯å®‰å…¨ã€ç«¯ç‰Œã¨å­—ç‰Œã¯ãƒªã‚¹ã‚¯ãŒé«˜ã„
            if (tile.suit === 'honors') return 30; // å­—ç‰Œã¯ãƒªã‚¹ã‚¯ä¸­
            if (tile.rank === 1 || tile.rank === 9) return 50; // ç«¯ç‰Œã¯ãƒªã‚¹ã‚¯é«˜
            if (tile.rank >= 4 && tile.rank <= 6) return 10; // ä¸­å¼µç‰Œã¯å®‰å…¨
            return 25; // ãã®ä»–
        }

        // æ¨ã¦ç‰Œç·åˆã‚¹ã‚³ã‚¢è¨ˆç®—
        function calculateDiscardScore(option) {
            let score = 0;
            
            // å‘è´æ•°ãŒæ”¹å–„ã™ã‚‹ã»ã©é«˜å¾—ç‚¹
            score += (8 - option.resultingShanten) * 100;
            
            // å¾…ã¡ç‰ŒãŒå¤šã„ã»ã©é«˜å¾—ç‚¹
            score += option.waitingTiles.length * 20;
            
            // å°†æ¥æ€§ãŒé«˜ã„ã»ã©é«˜å¾—ç‚¹
            score += option.futureProspects;
            
            // ãƒªã‚¹ã‚¯ãŒä½ã„ã»ã©é«˜å¾—ç‚¹
            score -= option.riskAssessment;
            
            return score;
        }

        // ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ç”Ÿæˆ
        function generateTestCases() {
            const testCases = [
                // åŸºæœ¬çš„ãªãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹
                generateBasicTestCase(),
                generateTenpaiTestCase(),
                generateIishantenTestCase(),
                generateComplexTestCase()
            ];

            testCases.forEach((testCase, index) => {
                logDebug(`=== ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ ${index + 1}: ${testCase.name} ===`);
                logDebug(`æ‰‹ç‰Œ: ${testCase.hand.map(getTileDisplayName).join(' ')}`);
                logDebug(`æœŸå¾…ã•ã‚Œã‚‹çŠ¶æ…‹: ${testCase.expectedState}`);
                
                // ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã‚’å®Ÿéš›ã®æ‰‹ç‰Œã«ã‚»ãƒƒãƒˆ
                if (index === 0) {
                    currentHand = [...testCase.hand];
                    updateHandDisplay();
                    calculateStatus();
                }
            });
        }

        // åŸºæœ¬ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ç”Ÿæˆ
        function generateBasicTestCase() {
            return {
                name: 'åŸºæœ¬å½¢ãƒ†ã‚¹ãƒˆ',
                hand: [
                    {suit: 'man', rank: 1}, {suit: 'man', rank: 2}, {suit: 'man', rank: 3},
                    {suit: 'pin', rank: 4}, {suit: 'pin', rank: 5}, {suit: 'pin', rank: 6},
                    {suit: 'sou', rank: 7}, {suit: 'sou', rank: 8}, {suit: 'sou', rank: 9},
                    {suit: 'honors', type: 'east'}, {suit: 'honors', type: 'east'}, {suit: 'honors', type: 'east'},
                    {suit: 'man', rank: 5}, {suit: 'man', rank: 5}
                ],
                expectedState: 'å’Œäº†å½¢'
            };
        }

        // ãƒ†ãƒ³ãƒ‘ã‚¤ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹
        function generateTenpaiTestCase() {
            return {
                name: 'ãƒ†ãƒ³ãƒ‘ã‚¤ãƒ†ã‚¹ãƒˆ',
                hand: [
                    {suit: 'man', rank: 1}, {suit: 'man', rank: 2}, {suit: 'man', rank: 3},
                    {suit: 'pin', rank: 4}, {suit: 'pin', rank: 5}, {suit: 'pin', rank: 6},
                    {suit: 'sou', rank: 7}, {suit: 'sou', rank: 8}, {suit: 'sou', rank: 9},
                    {suit: 'honors', type: 'east'}, {suit: 'honors', type: 'east'}, {suit: 'honors', type: 'east'},
                    {suit: 'man', rank: 5}
                ],
                expectedState: 'ãƒ†ãƒ³ãƒ‘ã‚¤'
            };
        }

        // ã‚¤ãƒ¼ã‚·ãƒ£ãƒ³ãƒ†ãƒ³ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹
        function generateIishantenTestCase() {
            return {
                name: 'ã‚¤ãƒ¼ã‚·ãƒ£ãƒ³ãƒ†ãƒ³ãƒ†ã‚¹ãƒˆ',
                hand: [
                    {suit: 'man', rank: 1}, {suit: 'man', rank: 2}, {suit: 'man', rank: 4},
                    {suit: 'pin', rank: 4}, {suit: 'pin', rank: 5}, {suit: 'pin', rank: 6},
                    {suit: 'sou', rank: 7}, {suit: 'sou', rank: 8}, {suit: 'sou', rank: 9},
                    {suit: 'honors', type: 'east'}, {suit: 'honors', type: 'east'}, {suit: 'honors', type: 'east'},
                    {suit: 'man', rank: 5}, {suit: 'man', rank: 8}
                ],
                expectedState: 'ã‚¤ãƒ¼ã‚·ãƒ£ãƒ³ãƒ†ãƒ³'
            };
        }

        // è¤‡é›‘ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹
        function generateComplexTestCase() {
            return {
                name: 'è¤‡é›‘å½¢ãƒ†ã‚¹ãƒˆ',
                hand: [
                    {suit: 'man', rank: 1}, {suit: 'man', rank: 1}, {suit: 'pin', rank: 2},
                    {suit: 'pin', rank: 2}, {suit: 'sou', rank: 3}, {suit: 'sou', rank: 3},
                    {suit: 'honors', type: 'east'}, {suit: 'honors', type: 'east'}, {suit: 'honors', type: 'south'},
                    {suit: 'honors', type: 'south'}, {suit: 'honors', type: 'west'}, {suit: 'honors', type: 'west'},
                    {suit: 'honors', type: 'north'}, {suit: 'honors', type: 'north'}
                ],
                expectedState: 'ä¸ƒå¯¾å­å½¢'
            };
        }

        // åˆ†æçµæœè¡¨ç¤º
        function displayDiscardAnalysis(analysis, bestDiscard) {
            const debugInfo = {
                åˆ†æå¯¾è±¡: `${analysis.length}æš`,
                æœ€é©æ¨ã¦ç‰Œ: getTileDisplayName(bestDiscard.discardTile),
                çµæœå‘è´æ•°: bestDiscard.shanten,
                å¾…ã¡ç‰Œæ•°: bestDiscard.waitingTiles,
                åŠ¹ç‡å€¤: bestDiscard.efficiency,
                å…¨é¸æŠè‚¢: analysis.map(a => ({
                    ç‰Œ: getTileDisplayName(a.discardTile),
                    å‘è´: a.shanten,
                    å¾…ã¡: a.waitingTiles,
                    åŠ¹ç‡: a.efficiency
                }))
            };
            
            document.getElementById('debugInfo').textContent = JSON.stringify(debugInfo, null, 2);
        }

        // è©³ç´°åˆ†æè¡¨ç¤º
        function displayDetailedAnalysis(analysis) {
            const debugInfo = {
                æ‰‹ç‰Œçµ±è¨ˆ: {
                    ç·æšæ•°: analysis.totalTiles,
                    ç¨®é¡æ•°: analysis.uniqueTiles,
                    ã‚¹ãƒ¼ãƒˆåˆ†å¸ƒ: analysis.suitDistribution
                },
                æ¨å¥¨æ‰“ç‰Œé †: analysis.discardOptions.slice(0, 5).map((option, index) => ({
                    é †ä½: index + 1,
                    ç‰Œ: getTileDisplayName(option.tile),
                    å‘è´æ•°: option.resultingShanten,
                    å¾…ã¡ç‰Œæ•°: option.waitingTiles.length,
                    å°†æ¥æ€§: option.futureProspects,
                    ãƒªã‚¹ã‚¯: option.riskAssessment,
                    ç·åˆã‚¹ã‚³ã‚¢: Math.round(option.score)
                }))
            };
            
            document.getElementById('debugInfo').textContent = JSON.stringify(debugInfo, null, 2);
        }

        // ===== é«˜åº¦ãªCPUéº»é›€ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ  =====

        // CPUæ€è€ƒã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ å®Ÿè¡Œ
        function runCpuAlgorithm() {
            if (currentHand.length !== 14) {
                alert('æ‰‹ç‰Œã‚’14æšã«ã—ã¦ãã ã•ã„');
                return;
            }

            logDebug('=== CPUæ€è€ƒã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ é–‹å§‹ ===');
            
            const cpuAnalysis = performAdvancedCpuAnalysis(currentHand);
            displayCpuThinking(cpuAnalysis);
            
            // æœ€é©è§£ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
            highlightRecommendedDiscard(cpuAnalysis.bestChoice);
        }

        // é«˜åº¦ãªCPUåˆ†æ
        function performAdvancedCpuAnalysis(hand) {
            const analysis = {
                currentState: analyzeCurrentGameState(hand),
                discardOptions: [],
                strategicGoals: determineStrategicGoals(hand),
                riskAssessment: assessOverallRisk(hand),
                timeFactors: calculateTimeFactors(hand),
                bestChoice: null
            };

            // å„æ¨ã¦ç‰Œé¸æŠè‚¢ã‚’å¤šè§’çš„ã«è©•ä¾¡
            for (let i = 0; i < hand.length; i++) {
                const testHand = [...hand];
                const discardTile = testHand.splice(i, 1)[0];
                
                const option = evaluateDiscardOption(testHand, discardTile, analysis.strategicGoals);
                analysis.discardOptions.push(option);
            }

            // æœ€é©è§£ã‚’æ±ºå®š
            analysis.bestChoice = selectBestOption(analysis.discardOptions, analysis.strategicGoals);
            
            return analysis;
        }

        // ç¾åœ¨ã®ã‚²ãƒ¼ãƒ çŠ¶æ…‹åˆ†æ
        function analyzeCurrentGameState(hand) {
            const handState = analyzeHandState(hand);
            
            return {
                shanten: handState.shanten,
                tenpai: handState.shanten === 0,
                complete: handState.isComplete,
                yakuPotential: assessYakuPotential(hand),
                handType: determineHandType(hand),
                efficiency: calculateHandEfficiency(hand),
                flexibility: calculateHandFlexibility(hand)
            };
        }

        // æˆ¦ç•¥ç›®æ¨™æ±ºå®š
        function determineStrategicGoals(hand) {
            const handState = analyzeHandState(hand);
            const yakuPotential = assessYakuPotential(hand);
            
            const goals = {
                primary: 'speed',  // speed, yaku, safety
                yakuTarget: null,
                acceptableRisk: 'medium',
                timeUrgency: 'normal'
            };

            // æ‰‹ç‰ŒçŠ¶æ³ã«å¿œã˜ãŸæˆ¦ç•¥æ±ºå®š
            if (handState.shanten <= 1) {
                goals.primary = 'speed';
                goals.timeUrgency = 'high';
            } else if (yakuPotential.highValueYaku.length > 0) {
                goals.primary = 'yaku';
                goals.yakuTarget = yakuPotential.highValueYaku[0];
            } else if (handState.shanten >= 4) {
                goals.primary = 'safety';
                goals.acceptableRisk = 'low';
            }

            return goals;
        }

        // æ¨ã¦ç‰Œé¸æŠè‚¢è©•ä¾¡
        function evaluateDiscardOption(resultHand, discardTile, goals) {
            const evaluation = {
                tile: discardTile,
                resultingHand: resultHand,
                scores: {
                    speed: calculateSpeedScore(resultHand),
                    yaku: calculateYakuScore(resultHand),
                    safety: calculateSafetyScore(discardTile),
                    flexibility: calculateFlexibilityScore(resultHand),
                    efficiency: calculateEfficiencyScore(resultHand)
                },
                totalScore: 0,
                reasoning: []
            };

            // æˆ¦ç•¥ã«åŸºã¥ãé‡ã¿ä»˜ã‘ã‚¹ã‚³ã‚¢è¨ˆç®—
            evaluation.totalScore = calculateWeightedScore(evaluation.scores, goals);
            evaluation.reasoning = generateReasoning(evaluation, goals);

            return evaluation;
        }

        // ã‚¹ãƒ”ãƒ¼ãƒ‰ã‚¹ã‚³ã‚¢è¨ˆç®—
        function calculateSpeedScore(hand) {
            const shanten = calculateShanten(hand);
            const waitingTiles = getWaitingTiles(hand);
            const waitingCount = waitingTiles.length;
            
            // å‘è´æ•°ãŒå°‘ãªãã€å¾…ã¡ç‰ŒãŒå¤šã„ã»ã©é«˜ã‚¹ã‚³ã‚¢
            let score = (8 - shanten) * 20;
            score += waitingCount * 5;
            
            // ãƒ†ãƒ³ãƒ‘ã‚¤ãƒœãƒ¼ãƒŠã‚¹
            if (shanten === 0) score += 50;
            
            return Math.max(0, score);
        }

        // å½¹ã‚¹ã‚³ã‚¢è¨ˆç®—
        function calculateYakuScore(hand) {
            const yaku = calculateYaku(hand);
            const yakuPotential = assessYakuPotential(hand);
            
            let score = 0;
            
            // ç¢ºå®šå½¹ã®ã‚¹ã‚³ã‚¢
            yaku.forEach(y => {
                if (y.han >= 13) score += 200; // å½¹æº€
                else if (y.han >= 6) score += 100; // è·³æº€ä»¥ä¸Š
                else if (y.han >= 3) score += 50;  // æº€è²«å€™è£œ
                else score += y.han * 10;
            });
            
            // æ½œåœ¨å½¹ã®ã‚¹ã‚³ã‚¢
            yakuPotential.possibleYaku.forEach(yaku => {
                score += yaku.probability * yaku.value * 5;
            });
            
            return score;
        }

        // å®‰å…¨æ€§ã‚¹ã‚³ã‚¢è¨ˆç®—
        function calculateSafetyScore(discardTile) {
            // å±é™ºåº¦ã®é€†æ•°ãŒã‚¹ã‚³ã‚¢
            const dangerLevel = assessTileDanger(discardTile);
            return Math.max(0, 100 - dangerLevel);
        }

        // ç‰Œã®å±é™ºåº¦è©•ä¾¡
        function assessTileDanger(tile) {
            let danger = 0;
            
            if (tile.suit === 'honors') {
                danger += 30; // å­—ç‰Œã¯ä¸­ç¨‹åº¦ã®å±é™º
            } else {
                if (tile.rank === 1 || tile.rank === 9) {
                    danger += 50; // ç«¯ç‰Œã¯å±é™º
                } else if (tile.rank >= 4 && tile.rank <= 6) {
                    danger += 10; // ä¸­å¼µç‰Œã¯å®‰å…¨
                } else {
                    danger += 25; // ãã®ä»–
                }
            }
            
            return danger;
        }

        // æŸ”è»Ÿæ€§ã‚¹ã‚³ã‚¢è¨ˆç®—
        function calculateFlexibilityScore(hand) {
            let score = 0;
            
            // å¯¾å­ã®æ•°ï¼ˆé›€é ­å€™è£œï¼‰
            const counts = getTileCounts(hand);
            const pairs = Object.values(counts).filter(count => count === 2).length;
            score += pairs * 10;
            
            // é †å­ã®å¯èƒ½æ€§
            ['man', 'pin', 'sou'].forEach(suit => {
                for (let rank = 1; rank <= 7; rank++) {
                    const key1 = `${suit}_${rank}`;
                    const key2 = `${suit}_${rank + 1}`;
                    const key3 = `${suit}_${rank + 2}`;
                    
                    let sequenceScore = 0;
                    if (counts[key1] && counts[key2] && counts[key3]) {
                        sequenceScore = 15; // å®Œå…¨ãªé †å­
                    } else if ((counts[key1] && counts[key2]) || 
                              (counts[key2] && counts[key3]) || 
                              (counts[key1] && counts[key3])) {
                        sequenceScore = 5; // é †å­ã®å¯èƒ½æ€§
                    }
                    score += sequenceScore;
                }
            });
            
            return score;
        }

        // åŠ¹ç‡æ€§ã‚¹ã‚³ã‚¢è¨ˆç®—
        function calculateEfficiencyScore(hand) {
            return calculateEfficiency(hand); // æ—¢å­˜ã®é–¢æ•°ã‚’å†åˆ©ç”¨
        }

        // é‡ã¿ä»˜ãã‚¹ã‚³ã‚¢è¨ˆç®—
        function calculateWeightedScore(scores, goals) {
            const weights = getWeights(goals);
            
            return (scores.speed * weights.speed) +
                   (scores.yaku * weights.yaku) +
                   (scores.safety * weights.safety) +
                   (scores.flexibility * weights.flexibility) +
                   (scores.efficiency * weights.efficiency);
        }

        // æˆ¦ç•¥ã«å¿œã˜ãŸé‡ã¿å–å¾—
        function getWeights(goals) {
            const baseWeights = {
                speed: 0.3,
                yaku: 0.25,
                safety: 0.2,
                flexibility: 0.15,
                efficiency: 0.1
            };

            if (goals.primary === 'speed') {
                baseWeights.speed = 0.5;
                baseWeights.yaku = 0.15;
            } else if (goals.primary === 'yaku') {
                baseWeights.yaku = 0.4;
                baseWeights.speed = 0.25;
            } else if (goals.primary === 'safety') {
                baseWeights.safety = 0.4;
                baseWeights.speed = 0.2;
            }

            return baseWeights;
        }

        // æœ€é©é¸æŠè‚¢æ±ºå®š
        function selectBestOption(options, goals) {
            // ã‚¹ã‚³ã‚¢é †ã«ã‚½ãƒ¼ãƒˆ
            options.sort((a, b) => b.totalScore - a.totalScore);
            
            const bestOption = options[0];
            bestOption.confidence = calculateConfidence(options);
            
            return bestOption;
        }

        // åˆ¤æ–­ã®ä¿¡é ¼åº¦è¨ˆç®—
        function calculateConfidence(options) {
            if (options.length < 2) return 100;
            
            const best = options[0].totalScore;
            const second = options[1].totalScore;
            
            if (best === 0) return 0;
            
            const gap = (best - second) / best;
            return Math.min(100, Math.max(0, gap * 100));
        }

        // å½¹ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«è©•ä¾¡
        function assessYakuPotential(hand) {
            const potential = {
                possibleYaku: [],
                highValueYaku: [],
                completionDistance: {}
            };

            // å„å½¹ã¸ã®è¿‘ã•ã‚’è©•ä¾¡
            const yakuChecks = [
                { name: 'ã‚¿ãƒ³ãƒ¤ã‚ª', check: checkTanyao, value: 1 },
                { name: 'ãƒ”ãƒ³ãƒ•', check: checkPinfu, value: 1 },
                { name: 'ä¸ƒå¯¾å­', check: checkChiitoi, value: 2 },
                { name: 'å¯¾ã€…å’Œ', check: checkToitoi, value: 2 },
                { name: 'ä¸‰è‰²åŒé †', check: checkSanshoku, value: 2 },
                { name: 'ä¸€æ°—é€šè²«', check: checkIttsu, value: 2 },
                { name: 'æ··ä¸€è‰²', check: checkHonitsu, value: 3 },
                { name: 'æ¸…ä¸€è‰²', check: checkChinitsu, value: 6 }
            ];

            yakuChecks.forEach(({ name, check, value }) => {
                const probability = estimateYakuProbability(hand, check);
                if (probability > 0.1) {
                    potential.possibleYaku.push({ name, probability, value });
                    if (value >= 3) {
                        potential.highValueYaku.push(name);
                    }
                }
            });

            return potential;
        }

        // å½¹å®Œæˆç¢ºç‡æ¨å®š
        function estimateYakuProbability(hand, yakuCheck) {
            if (yakuCheck(hand)) return 1.0; // æ—¢ã«å®Œæˆ
            
            // ç°¡æ˜“ç¢ºç‡è¨ˆç®—ï¼ˆå®Ÿéš›ã¯ã‚ˆã‚Šè¤‡é›‘ãªè¨ˆç®—ãŒå¿…è¦ï¼‰
            const handFeatures = getHandFeatures(hand);
            
            // ç‰¹å¾´ã«åŸºã¥ãç°¡æ˜“ç¢ºç‡
            if (handFeatures.includes('ã‚¿ãƒ³ãƒ¤ã‚ªå½¢')) return 0.8;
            if (handFeatures.includes('ä¸€è‰²')) return 0.9;
            if (handFeatures.includes('å­—ç‰Œå«ã¿')) return 0.3;
            
            return 0.2; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆç¢ºç‡
        }

        // æ¨è«–ç†ç”±ç”Ÿæˆ
        function generateReasoning(evaluation, goals) {
            const reasoning = [];
            
            if (evaluation.scores.speed > 80) {
                reasoning.push('é«˜é€Ÿé€²è¡ŒãŒæœŸå¾…ã§ãã‚‹');
            }
            if (evaluation.scores.yaku > 50) {
                reasoning.push('å½¹ã®å®Œæˆå¯èƒ½æ€§ãŒé«˜ã„');
            }
            if (evaluation.scores.safety > 70) {
                reasoning.push('å®‰å…¨ãªæ¨ã¦ç‰Œ');
            }
            if (evaluation.scores.flexibility > 60) {
                reasoning.push('æ‰‹ç‰Œã®æŸ”è»Ÿæ€§ã‚’ä¿æŒ');
            }
            
            if (goals.primary === 'speed' && evaluation.scores.speed < 30) {
                reasoning.push('ã‚¹ãƒ”ãƒ¼ãƒ‰é‡è¦–æˆ¦ç•¥ã«ä¸é©åˆ');
            }
            
            return reasoning;
        }

        // CPUæ€è€ƒçµæœè¡¨ç¤º
        function displayCpuThinking(analysis) {
            const debugInfo = {
                "CPUæ€è€ƒåˆ†æ": {
                    "ç¾åœ¨ã®çŠ¶æ…‹": analysis.currentState,
                    "æˆ¦ç•¥ç›®æ¨™": analysis.strategicGoals,
                    "ãƒªã‚¹ã‚¯è©•ä¾¡": analysis.riskAssessment
                },
                "æœ€é©è§£": {
                    "æ¨å¥¨æ¨ã¦ç‰Œ": getTileDisplayName(analysis.bestChoice.tile),
                    "ä¿¡é ¼åº¦": `${Math.round(analysis.bestChoice.confidence)}%`,
                    "ç·åˆã‚¹ã‚³ã‚¢": Math.round(analysis.bestChoice.totalScore),
                    "ç†ç”±": analysis.bestChoice.reasoning
                },
                "ã‚¹ã‚³ã‚¢è©³ç´°": {
                    "ã‚¹ãƒ”ãƒ¼ãƒ‰": Math.round(analysis.bestChoice.scores.speed),
                    "å½¹ä¾¡å€¤": Math.round(analysis.bestChoice.scores.yaku),
                    "å®‰å…¨æ€§": Math.round(analysis.bestChoice.scores.safety),
                    "æŸ”è»Ÿæ€§": Math.round(analysis.bestChoice.scores.flexibility),
                    "åŠ¹ç‡æ€§": Math.round(analysis.bestChoice.scores.efficiency)
                },
                "å…¨é¸æŠè‚¢": analysis.discardOptions.slice(0, 5).map((option, index) => ({
                    "é †ä½": index + 1,
                    "ç‰Œ": getTileDisplayName(option.tile),
                    "ã‚¹ã‚³ã‚¢": Math.round(option.totalScore),
                    "ç‰¹å¾´": option.reasoning.slice(0, 2)
                }))
            };
            
            document.getElementById('debugInfo').textContent = JSON.stringify(debugInfo, null, 2);
        }

        // æ¨å¥¨æ¨ã¦ç‰Œã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
        function highlightRecommendedDiscard(bestChoice) {
            // æ—¢å­˜ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’å‰Šé™¤
            document.querySelectorAll('.tile.recommended').forEach(tile => {
                tile.classList.remove('recommended');
            });
            
            // æ¨å¥¨ç‰Œã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
            const handTiles = document.querySelectorAll('#handTiles .tile');
            const recommendedTile = bestChoice.tile;
            
            handTiles.forEach((tileElement, index) => {
                if (index < currentHand.length) {
                    const handTile = currentHand[index];
                    if (getTileKey(handTile) === getTileKey(recommendedTile)) {
                        tileElement.classList.add('recommended');
                        tileElement.style.border = '3px solid #FFD700';
                        tileElement.style.boxShadow = '0 0 10px rgba(255, 215, 0, 0.6)';
                    }
                }
            });
        }

        // å…¨é¸æŠè‚¢æ¯”è¼ƒ
        function compareDiscardOptions() {
            if (currentHand.length !== 14) {
                alert('æ‰‹ç‰Œã‚’14æšã«ã—ã¦ãã ã•ã„');
                return;
            }

            const comparison = [];
            
            for (let i = 0; i < currentHand.length; i++) {
                const testHand = [...currentHand];
                const discardTile = testHand.splice(i, 1)[0];
                const analysis = evaluateDiscardOption(testHand, discardTile, { primary: 'speed' });
                
                comparison.push({
                    tile: getTileDisplayName(discardTile),
                    shanten: calculateShanten(testHand),
                    waiting: getWaitingTiles(testHand).length,
                    score: Math.round(analysis.totalScore),
                    safety: Math.round(analysis.scores.safety),
                    recommendation: analysis.totalScore > 100 ? 'æ¨å¥¨' : analysis.totalScore > 50 ? 'æ™®é€š' : 'éæ¨å¥¨'
                });
            }
            
            comparison.sort((a, b) => b.score - a.score);
            
            const debugInfo = {
                "å…¨æ¨ã¦ç‰Œé¸æŠè‚¢æ¯”è¼ƒ": comparison
            };
            
            document.getElementById('debugInfo').textContent = JSON.stringify(debugInfo, null, 2);
        }

        // ã‚²ãƒ¼ãƒ é€²è¡Œã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
        function simulateGameProgress() {
            if (currentHand.length !== 14) {
                alert('æ‰‹ç‰Œã‚’14æšã«ã—ã¦ãã ã•ã„');
                return;
            }

            logDebug('=== ã‚²ãƒ¼ãƒ é€²è¡Œã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆé–‹å§‹ ===');
            
            const simulation = {
                turns: [],
                finalState: null,
                strategy: 'optimal'
            };
            
            let simulationHand = [...currentHand];
            let turnCount = 0;
            
            while (turnCount < 10 && calculateShanten(simulationHand.slice(0, 13)) > 0) {
                turnCount++;
                
                // CPUæ€è€ƒã§æœ€é©ãªæ¨ã¦ç‰Œã‚’æ±ºå®š
                const cpuAnalysis = performAdvancedCpuAnalysis(simulationHand);
                const bestDiscard = cpuAnalysis.bestChoice;
                
                // æ¨ã¦ç‰Œå®Ÿè¡Œ
                const discardIndex = simulationHand.findIndex(tile => 
                    getTileKey(tile) === getTileKey(bestDiscard.tile)
                );
                
                if (discardIndex >= 0) {
                    const discarded = simulationHand.splice(discardIndex, 1)[0];
                    
                    // æ–°ã—ã„ç‰Œã‚’ãƒ„ãƒ¢ï¼ˆãƒ©ãƒ³ãƒ€ãƒ ï¼‰
                    const newTile = allTileTypes[Math.floor(Math.random() * allTileTypes.length)];
                    simulationHand.push(newTile);
                    
                    simulation.turns.push({
                        turn: turnCount,
                        discarded: getTileDisplayName(discarded),
                        drawn: getTileDisplayName(newTile),
                        shanten: calculateShanten(simulationHand.slice(0, 13)),
                        reasoning: bestDiscard.reasoning[0] || 'æœ€é©åŒ–åˆ¤æ–­'
                    });
                }
                
                if (simulationHand.length > 14) {
                    simulationHand = simulationHand.slice(0, 14);
                }
            }
            
            simulation.finalState = analyzeHandState(simulationHand.slice(0, 13));
            
            const debugInfo = {
                "ã‚²ãƒ¼ãƒ é€²è¡Œã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆçµæœ": {
                    "ç·ã‚¿ãƒ¼ãƒ³æ•°": turnCount,
                    "æœ€çµ‚çŠ¶æ…‹": simulation.finalState.message,
                    "æœ€çµ‚å‘è´æ•°": simulation.finalState.shanten,
                    "ã‚¿ãƒ¼ãƒ³è©³ç´°": simulation.turns
                }
            };
            
            document.getElementById('debugInfo').textContent = JSON.stringify(debugInfo, null, 2);
        }

        // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
        function calculateHandEfficiency(hand) {
            return calculateEfficiency(hand);
        }

        function calculateHandFlexibility(hand) {
            return calculateFlexibilityScore(hand);
        }

        function determineHandType(hand) {
            if (checkChiitoi(hand)) return 'chiitoi';
            if (checkKokushi(hand)) return 'kokushi';
            return 'normal';
        }

        function assessOverallRisk(hand) {
            // å…¨ä½“çš„ãªãƒªã‚¹ã‚¯è©•ä¾¡ï¼ˆç°¡æ˜“ç‰ˆï¼‰
            const honorCount = hand.filter(tile => tile.suit === 'honors').length;
            const terminalCount = hand.filter(tile => 
                tile.suit !== 'honors' && (tile.rank === 1 || tile.rank === 9)
            ).length;
            
            const riskLevel = (honorCount + terminalCount) / hand.length;
            
            if (riskLevel > 0.5) return 'high';
            if (riskLevel > 0.3) return 'medium';
            return 'low';
        }

        function calculateTimeFactors(hand) {
            const shanten = calculateShanten(hand);
            return {
                urgency: shanten <= 1 ? 'high' : shanten <= 3 ? 'medium' : 'low',
                patience: shanten >= 4 ? 'high' : 'medium'
            };
        }
    </script>
</body>
</html>